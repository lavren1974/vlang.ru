"use strict";(self.webpackChunkvlang_ru=self.webpackChunkvlang_ru||[]).push([[4622],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>c});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},u=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),d=p(t),c=i,h=d["".concat(s,".").concat(c)]||d[c]||m[c]||r;return t?a.createElement(h,l(l({ref:n},u),{},{components:t})):a.createElement(h,l({ref:n},u))}));function c(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,l=new Array(r);l[0]=d;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var p=2;p<r;p++)l[p]=t[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},4018:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>m,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var a=t(7462),i=(t(7294),t(3905));const r={sidebar_position:1001},l="V \u0414\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u044f",o={unversionedId:"doc-ru",id:"doc-ru",title:"V \u0414\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u044f",description:"(\u0421\u043c\u043e\u0442\u0440\u0438 https://modules.vlang.io/ \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u044e \u043f\u043e \u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u043e\u0439 \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0435 V)",source:"@site/docs/doc-ru.md",sourceDirName:".",slug:"/doc-ru",permalink:"/docs/doc-ru",draft:!1,tags:[],version:"current",sidebarPosition:1001,frontMatter:{sidebar_position:1001},sidebar:"tutorialSidebar",previous:{title:"V Documentation",permalink:"/docs/doc-en"}},s={},p=[{value:"\u0412\u0432\u0435\u0434\u0435\u043d\u0438\u0435",id:"\u0432\u0432\u0435\u0434\u0435\u043d\u0438\u0435",level:2},{value:"\u0423\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 V \u0438\u0437 \u0438\u0441\u0445\u043e\u0434\u043d\u0438\u043a\u043e\u0432",id:"\u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430-v-\u0438\u0437-\u0438\u0441\u0445\u043e\u0434\u043d\u0438\u043a\u043e\u0432",level:2},{value:"\u041e\u0433\u043b\u0430\u0432\u043b\u0435\u043d\u0438\u0435",id:"\u043e\u0433\u043b\u0430\u0432\u043b\u0435\u043d\u0438\u0435",level:2},{value:"\u041f\u0440\u0438\u0432\u0435\u0442 \u043c\u0438\u0440",id:"\u043f\u0440\u0438\u0432\u0435\u0442-\u043c\u0438\u0440",level:2},{value:"\u0417\u0430\u043f\u0443\u0441\u043a \u043f\u0430\u043f\u043a\u0438 \u043f\u0440\u043e\u0435\u043a\u0442\u0430 \u0441 \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u0438\u043c\u0438 \u0444\u0430\u0439\u043b\u0430\u043c\u0438",id:"\u0437\u0430\u043f\u0443\u0441\u043a-\u043f\u0430\u043f\u043a\u0438-\u043f\u0440\u043e\u0435\u043a\u0442\u0430-\u0441-\u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u0438\u043c\u0438-\u0444\u0430\u0439\u043b\u0430\u043c\u0438",level:2},{value:"\u041a\u043e\u043c\u043c\u0435\u043d\u0442\u0430\u0440\u0438\u0438",id:"\u043a\u043e\u043c\u043c\u0435\u043d\u0442\u0430\u0440\u0438\u0438",level:2},{value:"\u0424\u0443\u043d\u043a\u0446\u0438\u0438",id:"\u0444\u0443\u043d\u043a\u0446\u0438\u0438",level:2},{value:"\u041f\u043e\u0434\u044a\u0435\u043c\u044b",id:"\u043f\u043e\u0434\u044a\u0435\u043c\u044b",level:3},{value:"\u0412\u043e\u0437\u0432\u0440\u0430\u0442 \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u0438\u0445 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439",id:"\u0432\u043e\u0437\u0432\u0440\u0430\u0442-\u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u0438\u0445-\u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439",level:3},{value:"\u0412\u0438\u0434\u0438\u043c\u043e\u0441\u0442\u044c",id:"\u0432\u0438\u0434\u0438\u043c\u043e\u0441\u0442\u044c",level:2},{value:"\u041f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435",id:"\u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435",level:2},{value:"\u0418\u0437\u043c\u0435\u043d\u044f\u0435\u043c\u044b\u0435 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435",id:"\u0438\u0437\u043c\u0435\u043d\u044f\u0435\u043c\u044b\u0435-\u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435",level:3},{value:"\u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f vs \u043d\u0430\u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435",id:"\u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f-vs-\u043d\u0430\u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435",level:3},{value:"\u041e\u0448\u0438\u0431\u043a\u0438 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u044f",id:"\u043e\u0448\u0438\u0431\u043a\u0438-\u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u044f",level:3},{value:"V \u0422\u0438\u043f\u044b",id:"v-\u0442\u0438\u043f\u044b",level:2},{value:"\u041f\u0440\u0438\u043c\u0438\u0442\u0438\u0432\u043d\u044b\u0435 \u0442\u0438\u043f\u044b",id:"\u043f\u0440\u0438\u043c\u0438\u0442\u0438\u0432\u043d\u044b\u0435-\u0442\u0438\u043f\u044b",level:3},{value:"\u0421\u0442\u0440\u043e\u043a\u0438",id:"\u0441\u0442\u0440\u043e\u043a\u0438",level:3},{value:"\u0418\u043d\u0442\u0435\u0440\u043f\u043e\u043b\u044f\u0446\u0438\u044f \u0441\u0442\u0440\u043e\u043a",id:"\u0438\u043d\u0442\u0435\u0440\u043f\u043e\u043b\u044f\u0446\u0438\u044f-\u0441\u0442\u0440\u043e\u043a",level:3},{value:"String operators",id:"string-operators",level:3},{value:"Runes",id:"runes",level:3},{value:"Numbers",id:"numbers",level:3},{value:"Arrays",id:"arrays",level:3},{value:"Array Fields",id:"array-fields",level:4},{value:"Array Initialization",id:"array-initialization",level:4},{value:"Array Types",id:"array-types",level:4},{value:"Multidimensional Arrays",id:"multidimensional-arrays",level:4},{value:"Array methods",id:"array-methods",level:4},{value:"Sorting Arrays",id:"sorting-arrays",level:5},{value:"Array Slices",id:"array-slices",level:4},{value:"Slices with negative indexes",id:"slices-with-negative-indexes",level:5},{value:"Array method chaining",id:"array-method-chaining",level:4},{value:"Fixed size arrays",id:"fixed-size-arrays",level:3},{value:"Maps",id:"maps",level:3},{value:"Module imports",id:"module-imports",level:2},{value:"Selective imports",id:"selective-imports",level:3},{value:"Module import aliasing",id:"module-import-aliasing",level:3},{value:"Statements &amp; expressions",id:"statements--expressions",level:2},{value:"If",id:"if",level:3},{value:"Type checks and casts",id:"type-checks-and-casts",level:4},{value:"In operator",id:"in-operator",level:3},{value:"For loop",id:"for-loop",level:3},{value:"<code>for</code>/<code>in</code>",id:"forin",level:4},{value:"Array <code>for</code>",id:"array-for",level:5},{value:"Custom iterators",id:"custom-iterators",level:5},{value:"Map <code>for</code>",id:"map-for",level:5},{value:"Range <code>for</code>",id:"range-for",level:5},{value:"Condition <code>for</code>",id:"condition-for",level:4},{value:"Bare <code>for</code>",id:"bare-for",level:4},{value:"C <code>for</code>",id:"c-for",level:4},{value:"Labelled break &amp; continue",id:"labelled-break--continue",level:4},{value:"Match",id:"match",level:3},{value:"Defer",id:"defer",level:3},{value:"Structs",id:"structs",level:2},{value:"Heap structs",id:"heap-structs",level:3},{value:"Default field values",id:"default-field-values",level:3},{value:"Required fields",id:"required-fields",level:3},{value:"Short struct literal syntax",id:"short-struct-literal-syntax",level:3},{value:"Trailing struct literal arguments",id:"trailing-struct-literal-arguments",level:4},{value:"Access modifiers",id:"access-modifiers",level:3},{value:"Anonymous structs",id:"anonymous-structs",level:3},{value:"Methods",id:"methods",level:3},{value:"Embedded structs",id:"embedded-structs",level:3},{value:"Unions",id:"unions",level:2},{value:"Functions 2",id:"functions-2",level:2},{value:"Immutable function args by default",id:"immutable-function-args-by-default",level:3},{value:"Mutable arguments",id:"mutable-arguments",level:3},{value:"Struct update syntax",id:"struct-update-syntax",level:4},{value:"Variable number of arguments",id:"variable-number-of-arguments",level:3},{value:"Anonymous &amp; higher order functions",id:"anonymous--higher-order-functions",level:3},{value:"Closures",id:"closures",level:3},{value:"References",id:"references",level:2},{value:"Parameter evaluation order",id:"parameter-evaluation-order",level:3},{value:"Constants",id:"constants",level:2},{value:"Required module prefix",id:"required-module-prefix",level:3},{value:"Builtin functions",id:"builtin-functions",level:2},{value:"println",id:"println",level:3},{value:"Printing custom types",id:"printing-custom-types",level:3},{value:"Dumping expressions at runtime",id:"dumping-expressions-at-runtime",level:3},{value:"Modules",id:"modules",level:2},{value:"<code>init</code> functions",id:"init-functions",level:3},{value:"Type Declarations",id:"type-declarations",level:2},{value:"Interfaces",id:"interfaces",level:3},{value:"Implement an interface",id:"implement-an-interface",level:4},{value:"Casting an interface",id:"casting-an-interface",level:4},{value:"Interface method definitions",id:"interface-method-definitions",level:4},{value:"Embedded interface",id:"embedded-interface",level:4},{value:"Function Types",id:"function-types",level:3},{value:"Enums",id:"enums",level:3},{value:"Sum types",id:"sum-types",level:3},{value:"Dynamic casts",id:"dynamic-casts",level:4},{value:"Smart casting",id:"smart-casting",level:4},{value:"Matching sum types",id:"matching-sum-types",level:4},{value:"Type aliases",id:"type-aliases",level:3},{value:"Option/Result types and error handling",id:"optionresult-types-and-error-handling",level:3},{value:"Handling optionals",id:"handling-optionals",level:3},{value:"Custom error types",id:"custom-error-types",level:2},{value:"Generics",id:"generics",level:2},{value:"Concurrency",id:"concurrency",level:2},{value:"Spawning Concurrent Tasks",id:"spawning-concurrent-tasks",level:3},{value:"Channels",id:"channels",level:3},{value:"Syntax and Usage",id:"syntax-and-usage",level:4},{value:"Channel Select",id:"channel-select",level:4},{value:"Special Channel Features",id:"special-channel-features",level:4},{value:"Shared Objects",id:"shared-objects",level:3},{value:"JSON",id:"json",level:2},{value:"Decoding JSON",id:"decoding-json",level:3},{value:"Encoding JSON",id:"encoding-json",level:3},{value:"Testing",id:"testing",level:2},{value:"Asserts",id:"asserts",level:3},{value:"Asserts with an extra message",id:"asserts-with-an-extra-message",level:3},{value:"Test files",id:"test-files",level:3},{value:"Running tests",id:"running-tests",level:4},{value:"Memory management",id:"memory-management",level:2},{value:"Control",id:"control",level:3},{value:"Examples",id:"examples",level:3},{value:"Stack and Heap",id:"stack-and-heap",level:3},{value:"Stack and Heap Basics",id:"stack-and-heap-basics",level:4},{value:"V&#39;s default approach",id:"vs-default-approach",level:4},{value:"Manual Control for Stack and Heap",id:"manual-control-for-stack-and-heap",level:4},{value:"ORM",id:"orm",level:2},{value:"Writing Documentation",id:"writing-documentation",level:2},{value:"Newlines in Documentation Comments",id:"newlines-in-documentation-comments",level:3},{value:"Tools",id:"tools",level:2},{value:"v fmt",id:"v-fmt",level:3},{value:"v shader",id:"v-shader",level:3},{value:"Profiling",id:"profiling",level:3},{value:"Package management",id:"package-management",level:2},{value:"module options:",id:"module-options",level:6},{value:"Publish package",id:"publish-package",level:3},{value:"Memory-unsafe code",id:"memory-unsafe-code",level:2},{value:"Structs with reference fields",id:"structs-with-reference-fields",level:2},{value:"sizeof and __offsetof",id:"sizeof-and-__offsetof",level:2},{value:"Calling C from V",id:"calling-c-from-v",level:2},{value:"Example",id:"example",level:3},{value:"Calling V from C",id:"calling-v-from-c",level:2},{value:"Atomics",id:"atomics",level:2},{value:"Global Variables",id:"global-variables",level:2},{value:"Passing C compilation flags",id:"passing-c-compilation-flags",level:3},{value:"#pkgconfig",id:"pkgconfig",level:3},{value:"Including C code",id:"including-c-code",level:3},{value:"C types",id:"c-types",level:3},{value:"C Declarations",id:"c-declarations",level:3},{value:"Debugging",id:"debugging",level:2},{value:"C Backend binaries (Default)",id:"c-backend-binaries-default",level:3},{value:"Native Backend binaries",id:"native-backend-binaries",level:3},{value:"Javascript Backend",id:"javascript-backend",level:3},{value:"Conditional compilation",id:"conditional-compilation",level:2},{value:"Compile time code",id:"compile-time-code",level:3},{value:"<code>$if</code> condition",id:"if-condition",level:4},{value:"<code>$embed_file</code>",id:"embed_file",level:4},{value:"<code>$tmpl</code> for embedding and parsing V template files",id:"tmpl-for-embedding-and-parsing-v-template-files",level:4},{value:"<code>$env</code>",id:"env",level:4},{value:"<code>$compile_error</code> and <code>$compile_warn</code>",id:"compile_error-and-compile_warn",level:4},{value:"Environment specific files",id:"environment-specific-files",level:3},{value:"Compile time pseudo variables",id:"compile-time-pseudo-variables",level:2},{value:"Performance tuning",id:"performance-tuning",level:2},{value:"Compile-time reflection",id:"compile-time-reflection",level:2},{value:"Limited operator overloading",id:"limited-operator-overloading",level:2},{value:"Inline assembly",id:"inline-assembly",level:2},{value:"Translating C to V",id:"translating-c-to-v",level:2},{value:"Hot code reloading",id:"hot-code-reloading",level:2},{value:"Cross compilation",id:"cross-compilation",level:2},{value:"Cross-platform shell scripts in V",id:"cross-platform-shell-scripts-in-v",level:2},{value:"Attributes",id:"attributes",level:2},{value:"Goto",id:"goto",level:2},{value:"Appendix I: Keywords",id:"appendix-i-keywords",level:2},{value:"Appendix II: Operators",id:"appendix-ii-operators",level:2}],u={toc:p};function m(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"v-\u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u044f"},"V \u0414\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u044f"),(0,i.kt)("p",null,"(\u0421\u043c\u043e\u0442\u0440\u0438 ",(0,i.kt)("a",{parentName:"p",href:"https://modules.vlang.io/"},"https://modules.vlang.io/")," \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u044e \u043f\u043e \u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u043e\u0439 \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0435 V)"),(0,i.kt)("h2",{id:"\u0432\u0432\u0435\u0434\u0435\u043d\u0438\u0435"},"\u0412\u0432\u0435\u0434\u0435\u043d\u0438\u0435"),(0,i.kt)("p",null,"V \u2014 \u044d\u0442\u043e \u0441\u0442\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438 \u0442\u0438\u043f\u0438\u0437\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u0439 \u0441\u043a\u043e\u043c\u043f\u0438\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u0439 \u044f\u0437\u044b\u043a \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u043f\u0440\u0435\u0434\u043d\u0430\u0437\u043d\u0430\u0447\u0435\u043d\u043d\u044b\u0439 \u0434\u043b\u044f \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u043c\u043e\u0433\u043e \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u043d\u043e\u0433\u043e \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0435\u043d\u0438\u044f."),(0,i.kt)("p",null,"\u041e\u043d \u043f\u043e\u0445\u043e\u0436 \u043d\u0430 Go, \u0438 \u043d\u0430 \u0435\u0433\u043e \u0434\u0438\u0437\u0430\u0439\u043d \u0442\u0430\u043a\u0436\u0435 \u043f\u043e\u0432\u043b\u0438\u044f\u043b\u0438 Oberon, Rust, Swift, Kotlin \u0438 Python."),(0,i.kt)("p",null,"V \u2014 \u043e\u0447\u0435\u043d\u044c \u043f\u0440\u043e\u0441\u0442\u043e\u0439 \u044f\u0437\u044b\u043a. \u0418\u0437\u0443\u0447\u0435\u043d\u0438\u0435 \u044d\u0442\u043e\u0439 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0438 \u0437\u0430\u0439\u043c\u0435\u0442 \u0443 \u0432\u0430\u0441 \u043e\u043a\u043e\u043b\u043e \u0447\u0430\u0441\u0430, \u0438 \u043a \u0435\u0433\u043e \u043a\u043e\u043d\u0446\u0443 \u0432\u044b \u0432 \u0437\u043d\u0430\u0447\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0439 \u0441\u0442\u0435\u043f\u0435\u043d\u0438 \u0432\u044b\u0443\u0447\u0438\u0442\u0435 \u0432\u0435\u0441\u044c \u044f\u0437\u044b\u043a."),(0,i.kt)("p",null,"\u042f\u0437\u044b\u043a \u0441\u043f\u043e\u0441\u043e\u0431\u0441\u0442\u0432\u0443\u0435\u0442 \u043d\u0430\u043f\u0438\u0441\u0430\u043d\u0438\u044e \u043f\u0440\u043e\u0441\u0442\u043e\u0433\u043e \u0438 \u043f\u043e\u043d\u044f\u0442\u043d\u043e\u0433\u043e \u043a\u043e\u0434\u0430 \u0441 \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0439 \u0430\u0431\u0441\u0442\u0440\u0430\u043a\u0446\u0438\u0435\u0439."),(0,i.kt)("p",null,"\u041d\u0435\u0441\u043c\u043e\u0442\u0440\u044f \u043d\u0430 \u043f\u0440\u043e\u0441\u0442\u043e\u0442\u0443, V \u0434\u0430\u0435\u0442 \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u0443 \u043c\u043d\u043e\u0433\u043e \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u0435\u0439. \u0412\u0441\u0435, \u0447\u0442\u043e \u0432\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u0434\u0435\u043b\u0430\u0442\u044c \u043d\u0430 \u0434\u0440\u0443\u0433\u0438\u0445 \u044f\u0437\u044b\u043a\u0430\u0445, \u0432\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u0434\u0435\u043b\u0430\u0442\u044c \u0438 \u043d\u0430 V."),(0,i.kt)("h2",{id:"\u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430-v-\u0438\u0437-\u0438\u0441\u0445\u043e\u0434\u043d\u0438\u043a\u043e\u0432"},"\u0423\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 V \u0438\u0437 \u0438\u0441\u0445\u043e\u0434\u043d\u0438\u043a\u043e\u0432"),(0,i.kt)("p",null,"\u041b\u0443\u0447\u0448\u0438\u0439 \u0441\u043f\u043e\u0441\u043e\u0431 \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0441\u0430\u043c\u0443\u044e \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u044e\u044e \u0432\u0435\u0440\u0441\u0438\u044e V \u2014 \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u044c \u0435\u0435 \u0438\u0437 \u0438\u0441\u0445\u043e\u0434\u043d\u043e\u0433\u043e \u043a\u043e\u0434\u0430. \u042d\u0442\u043e \u043b\u0435\u0433\u043a\u043e \u0438 \u0437\u0430\u043d\u0438\u043c\u0430\u0435\u0442 \u0432\u0441\u0435\u0433\u043e \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u0441\u0435\u043a\u0443\u043d\u0434:"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/vlang/v#installing-v---from-source-preferred-method"},"https://github.com/vlang/v#installing-v")),(0,i.kt)("h2",{id:"\u043e\u0433\u043b\u0430\u0432\u043b\u0435\u043d\u0438\u0435"},"\u041e\u0433\u043b\u0430\u0432\u043b\u0435\u043d\u0438\u0435"),(0,i.kt)("h2",{id:"\u043f\u0440\u0438\u0432\u0435\u0442-\u043c\u0438\u0440"},"\u041f\u0440\u0438\u0432\u0435\u0442 \u043c\u0438\u0440"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"fn main() {\n    println('\u041f\u0440\u0438\u0432\u0435\u0442 \u043c\u0438\u0440')\n}\n")),(0,i.kt)("p",null,"\u0421\u043e\u0445\u0440\u0430\u043d\u0438\u0442\u0435 \u044d\u0442\u043e\u0442 \u0444\u0440\u0430\u0433\u043c\u0435\u043d\u0442 \u0432 \u0444\u0430\u0439\u043b \u0441 \u0438\u043c\u0435\u043d\u0435\u043c ",(0,i.kt)("inlineCode",{parentName:"p"},"hello.v"),". \u0422\u0435\u043f\u0435\u0440\u044c \u0441\u0434\u0435\u043b\u0430\u0439\u0442\u0435: ",(0,i.kt)("inlineCode",{parentName:"p"},"v run hello.v"),"."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"\u042d\u0442\u043e \u043f\u0440\u0435\u0434\u043f\u043e\u043b\u0430\u0433\u0430\u0435\u0442, \u0447\u0442\u043e \u0432\u044b \u0441\u0434\u0435\u043b\u0430\u043b\u0438 \u0441\u0438\u043c\u0432\u043e\u043b\u0438\u0447\u0435\u0441\u043a\u0443\u044e \u0441\u0441\u044b\u043b\u043a\u0443 \u043d\u0430 V \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e ",(0,i.kt)("inlineCode",{parentName:"p"},"v symlink"),", \u043a\u0430\u043a \u043e\u043f\u0438\u0441\u0430\u043d\u043e\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/vlang/v/blob/master/README.md#symlinking"},"\u0437\u0434\u0435\u0441\u044c"),".\n\u0415\u0441\u043b\u0438 \u0432\u044b \u0435\u0449\u0435 \u044d\u0442\u043e\u0433\u043e \u043d\u0435 \u0441\u0434\u0435\u043b\u0430\u043b\u0438, \u0432\u0430\u043c \u043d\u0443\u0436\u043d\u043e \u0432\u0432\u0435\u0441\u0442\u0438 \u043f\u0443\u0442\u044c \u043a V \u0432\u0440\u0443\u0447\u043d\u0443\u044e.")),(0,i.kt)("p",null,"\u041f\u043e\u0437\u0434\u0440\u0430\u0432\u043b\u044f\u0435\u043c \u2014 \u0432\u044b \u0442\u043e\u043b\u044c\u043a\u043e \u0447\u0442\u043e \u043d\u0430\u043f\u0438\u0441\u0430\u043b\u0438 \u0438 \u0432\u044b\u043f\u043e\u043b\u043d\u0438\u043b\u0438 \u0441\u0432\u043e\u044e \u043f\u0435\u0440\u0432\u0443\u044e \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0443 \u043d\u0430 V!"),(0,i.kt)("p",null,"\u0412\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u0441\u043a\u043e\u043c\u043f\u0438\u043b\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0443 \u0431\u0435\u0437 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e ",(0,i.kt)("inlineCode",{parentName:"p"},"v hello.v"),".\n\u0421\u043c\u043e\u0442\u0440\u0438 ",(0,i.kt)("inlineCode",{parentName:"p"},"v help")," \u0432\u0441\u0435 \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u043c\u044b\u0435 \u043a\u043e\u043c\u0430\u043d\u0434\u044b."),(0,i.kt)("p",null,"\u0418\u0437 \u043f\u0440\u0438\u0432\u0435\u0434\u0435\u043d\u043d\u043e\u0433\u043e \u0432\u044b\u0448\u0435 \u043f\u0440\u0438\u043c\u0435\u0440\u0430 \u0432\u0438\u0434\u043d\u043e, \u0447\u0442\u043e \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u043e\u0431\u044a\u044f\u0432\u043b\u044f\u044e\u0442\u0441\u044f \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e ",(0,i.kt)("inlineCode",{parentName:"p"},"fn")," \u043a\u043b\u044e\u0447\u0435\u0432\u043e\u0433\u043e \u0441\u043b\u043e\u0432\u0430.\n\u0422\u0438\u043f \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u043e\u0433\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0435\u0442\u0441\u044f \u043f\u043e\u0441\u043b\u0435 \u0438\u043c\u0435\u043d\u0438 \u0444\u0443\u043d\u043a\u0446\u0438\u0438. \u0412 \u044d\u0442\u043e\u043c \u0441\u043b\u0443\u0447\u0430\u0435 ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," \u043d\u0438\u0447\u0435\u0433\u043e \u043d\u0435 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442, \u043f\u043e\u044d\u0442\u043e\u043c\u0443 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u044b\u0439 \u0442\u0438\u043f \u043e\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u0435\u0442."),(0,i.kt)("p",null,"\u041a\u0430\u043a \u0438 \u0432\u043e \u043c\u043d\u043e\u0433\u0438\u0445 \u0434\u0440\u0443\u0433\u0438\u0445 \u044f\u0437\u044b\u043a\u0430\u0445 (\u0442\u0430\u043a\u0438\u0445 \u043a\u0430\u043a C, Go \u0438 Rust), ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," \u044d\u0442\u043e \u0442\u043e\u0447\u043a\u0430 \u0432\u0445\u043e\u0434\u0430 \u0432 \u0432\u0430\u0448\u0443 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0443."),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"#println"},(0,i.kt)("inlineCode",{parentName:"a"},"println"))," \u043e\u0434\u043d\u0430 \u0438\u0437 \u043d\u0435\u043c\u043d\u043e\u0433\u0438\u0445 ",(0,i.kt)("a",{parentName:"p",href:"#builtin-functions"},"\u0432\u0441\u0442\u0440\u043e\u0435\u043d\u043d\u044b\u0445 \u0444\u0443\u043d\u043a\u0446\u0438\u0439"),".\n\u041e\u043d \u043f\u0435\u0447\u0430\u0442\u0430\u0435\u0442 \u043f\u0435\u0440\u0435\u0434\u0430\u043d\u043d\u043e\u0435 \u0435\u043c\u0443 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043d\u0430 \u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u044b\u0439 \u0432\u044b\u0432\u043e\u0434."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"fn main()")," \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u043c\u043e\u0436\u043d\u043e \u043f\u0440\u043e\u043f\u0443\u0441\u0442\u0438\u0442\u044c \u0432 \u043e\u0434\u043d\u043e\u043c \u0444\u0430\u0439\u043b\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b. \u042d\u0442\u043e \u043f\u043e\u043b\u0435\u0437\u043d\u043e \u043f\u0440\u0438 \u043d\u0430\u043f\u0438\u0441\u0430\u043d\u0438\u0438 \u043d\u0435\u0431\u043e\u043b\u044c\u0448\u0438\u0445 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c, \xab\u0441\u043a\u0440\u0438\u043f\u0442\u043e\u0432\xbb \u0438\u043b\u0438 \u043f\u0440\u043e\u0441\u0442\u043e \u043f\u0440\u0438 \u0438\u0437\u0443\u0447\u0435\u043d\u0438\u0438 \u044f\u0437\u044b\u043a\u0430. \u0414\u043b\u044f \u043a\u0440\u0430\u0442\u043a\u043e\u0441\u0442\u0438, ",(0,i.kt)("inlineCode",{parentName:"p"},"fn main()")," \u0432 \u044d\u0442\u043e\u043c \u0443\u0440\u043e\u043a\u0435 \u043e\u043d\u0438 \u0431\u0443\u0434\u0443\u0442 \u043f\u0440\u043e\u043f\u0443\u0449\u0435\u043d\u044b."),(0,i.kt)("p",null,"\u042d\u0442\u043e \u043e\u0437\u043d\u0430\u0447\u0430\u0435\u0442, \u0447\u0442\u043e \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0430 \xabhello world\xbb \u0432 V \u0442\u0430\u043a \u0436\u0435 \u043f\u0440\u043e\u0441\u0442\u0430, \u043a\u0430\u043a"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"println('hello world')\n")),(0,i.kt)("h2",{id:"\u0437\u0430\u043f\u0443\u0441\u043a-\u043f\u0430\u043f\u043a\u0438-\u043f\u0440\u043e\u0435\u043a\u0442\u0430-\u0441-\u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u0438\u043c\u0438-\u0444\u0430\u0439\u043b\u0430\u043c\u0438"},"\u0417\u0430\u043f\u0443\u0441\u043a \u043f\u0430\u043f\u043a\u0438 \u043f\u0440\u043e\u0435\u043a\u0442\u0430 \u0441 \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u0438\u043c\u0438 \u0444\u0430\u0439\u043b\u0430\u043c\u0438"),(0,i.kt)("p",null,"\u041f\u0440\u0435\u0434\u043f\u043e\u043b\u043e\u0436\u0438\u043c, \u0443 \u0432\u0430\u0441 \u0435\u0441\u0442\u044c \u043f\u0430\u043f\u043a\u0430 \u0441 \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u0438\u043c\u0438 \u0444\u0430\u0439\u043b\u0430\u043c\u0438 .v, \u0433\u0434\u0435 \u043e\u0434\u0438\u043d \u0438\u0437 \u043d\u0438\u0445 \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u0432\u0430\u0448\u0443 ",(0,i.kt)("inlineCode",{parentName:"p"},"main()")," \u0444\u0443\u043d\u043a\u0446\u0438\u044e, \u0430 \u0434\u0440\u0443\u0433\u0438\u0435 \u0444\u0430\u0439\u043b\u044b \u0438\u043c\u0435\u044e\u0442 \u0434\u0440\u0443\u0433\u0438\u0435 \u0432\u0441\u043f\u043e\u043c\u043e\u0433\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u0438. \u041e\u043d\u0438 \u043c\u043e\u0433\u0443\u0442 \u0431\u044b\u0442\u044c \u043e\u0440\u0433\u0430\u043d\u0438\u0437\u043e\u0432\u0430\u043d\u044b \u043f\u043e \u0442\u0435\u043c\u0430\u043c, \u043d\u043e \u0435\u0449\u0435 \u043d\u0435\u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0438\u0440\u043e\u0432\u0430\u043d\u044b, \u0447\u0442\u043e\u0431\u044b \u0431\u044b\u0442\u044c \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u044b\u043c\u0438 \u043c\u043e\u0434\u0443\u043b\u044f\u043c\u0438 \u043c\u043d\u043e\u0433\u043e\u043a\u0440\u0430\u0442\u043d\u043e\u0433\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f, \u0438 \u0432\u044b \u0445\u043e\u0442\u0438\u0442\u0435 \u0441\u043a\u043e\u043c\u043f\u0438\u043b\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0438\u0445 \u0432\u0441\u0435 \u0432 \u043e\u0434\u043d\u0443 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0443."),(0,i.kt)("p",null,"\u0412 \u0434\u0440\u0443\u0433\u0438\u0445 \u044f\u0437\u044b\u043a\u0430\u0445 \u0432\u0430\u043c \u043f\u0440\u0438\u0448\u043b\u043e\u0441\u044c \u0431\u044b \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0432\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u0438\u043b\u0438 \u0441\u0438\u0441\u0442\u0435\u043c\u0443 \u0441\u0431\u043e\u0440\u043a\u0438 \u0434\u043b\u044f \u043f\u0435\u0440\u0435\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f \u0432\u0441\u0435\u0445 \u0444\u0430\u0439\u043b\u043e\u0432, \u043a\u043e\u043c\u043f\u0438\u043b\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0438\u0445 \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u043e \u0432 \u043e\u0431\u044a\u0435\u043a\u0442\u043d\u044b\u0435 \u0444\u0430\u0439\u043b\u044b, \u0430 \u0437\u0430\u0442\u0435\u043c \u0441\u0432\u044f\u0437\u044b\u0432\u0430\u0442\u044c \u0438\u0445 \u0432 \u043e\u0434\u0438\u043d \u043e\u043a\u043e\u043d\u0447\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u0439 \u0438\u0441\u043f\u043e\u043b\u043d\u044f\u0435\u043c\u044b\u0439 \u0444\u0430\u0439\u043b."),(0,i.kt)("p",null,"\u041e\u0434\u043d\u0430\u043a\u043e \u0432 V \u0432\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u0441\u043a\u043e\u043c\u043f\u0438\u043b\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0438 \u0437\u0430\u043f\u0443\u0441\u0442\u0438\u0442\u044c \u0432\u0441\u044e \u043f\u0430\u043f\u043a\u0443 \u0444\u0430\u0439\u043b\u043e\u0432 .v \u0432\u043c\u0435\u0441\u0442\u0435, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044f \u0442\u043e\u043b\u044c\u043a\u043e \u0444\u0430\u0439\u043b\u044b ",(0,i.kt)("inlineCode",{parentName:"p"},"v run ."),". \u041f\u0435\u0440\u0435\u0434\u0430\u0447\u0430 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u0442\u0430\u043a\u0436\u0435 \u0440\u0430\u0431\u043e\u0442\u0430\u0435\u0442, \u043f\u043e\u044d\u0442\u043e\u043c\u0443 \u0432\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u0441\u0434\u0435\u043b\u0430\u0442\u044c: ",(0,i.kt)("inlineCode",{parentName:"p"},"v run . --yourparam some_other_stuff")),(0,i.kt)("p",null,"\u041f\u0440\u0438\u0432\u0435\u0434\u0435\u043d\u043d\u043e\u0435 \u0432\u044b\u0448\u0435 \u0441\u043d\u0430\u0447\u0430\u043b\u0430 \u0441\u043a\u043e\u043c\u043f\u0438\u043b\u0438\u0440\u0443\u0435\u0442 \u0432\u0430\u0448\u0438 \u0444\u0430\u0439\u043b\u044b \u0432 \u0435\u0434\u0438\u043d\u0443\u044e \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0443 (\u043d\u0430\u0437\u0432\u0430\u043d\u043d\u0443\u044e \u0432 \u0447\u0435\u0441\u0442\u044c \u0432\u0430\u0448\u0435\u0439 \u043f\u0430\u043f\u043a\u0438/\u043f\u0440\u043e\u0435\u043a\u0442\u0430), \u0430 \u0437\u0430\u0442\u0435\u043c \u0432\u044b\u043f\u043e\u043b\u043d\u0438\u0442 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0443 \u0441 ",(0,i.kt)("inlineCode",{parentName:"p"},"--yourparam some_other_stuff")," \u043f\u0435\u0440\u0435\u0434\u0430\u043d\u043d\u044b\u043c\u0438 \u0435\u0439 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0430\u043c\u0438 CLI."),(0,i.kt)("p",null,"\u0417\u0430\u0442\u0435\u043c \u0432\u0430\u0448\u0430 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0430 \u043c\u043e\u0436\u0435\u0442 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b CLI \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u043c \u043e\u0431\u0440\u0430\u0437\u043e\u043c:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"import os\n\nprintln(os.args)\n\n// D:\\MyDevTest\\vlang>v run hello.v --aaa --bbb\n// ['D:\\MyDevTest\\vlang\\hello.exe', '--aaa', '--bbb']\n\n// D:\\MyDevTest\\vlang>v run hello.v aaa bbb\n// ['D:\\MyDevTest\\vlang\\hello.exe', 'aaa', 'bbb']\n")),(0,i.kt)("p",null,"NB: \u043f\u043e\u0441\u043b\u0435 \u0443\u0441\u043f\u0435\u0448\u043d\u043e\u0433\u043e \u0437\u0430\u043f\u0443\u0441\u043a\u0430 V \u0443\u0434\u0430\u043b\u0438\u0442 \u0441\u0433\u0435\u043d\u0435\u0440\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u0439 \u0438\u0441\u043f\u043e\u043b\u043d\u044f\u0435\u043c\u044b\u0439 \u0444\u0430\u0439\u043b. \u0415\u0441\u043b\u0438 \u0432\u044b \u0445\u043e\u0442\u0438\u0442\u0435 \u0441\u043e\u0445\u0440\u0430\u043d\u0438\u0442\u044c \u0435\u0433\u043e, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 ",(0,i.kt)("inlineCode",{parentName:"p"},"v -keepc run .")," \u0432\u043c\u0435\u0441\u0442\u043e \u043d\u0435\u0433\u043e \u0438\u043b\u0438 \u043f\u0440\u043e\u0441\u0442\u043e \u0441\u043a\u043e\u043c\u043f\u0438\u043b\u0438\u0440\u0443\u0439\u0442\u0435 \u0432\u0440\u0443\u0447\u043d\u0443\u044e \u0441 \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043d\u0438\u0435\u043c ",(0,i.kt)("inlineCode",{parentName:"p"},"v .")," ."),(0,i.kt)("p",null,"NB: \u043b\u044e\u0431\u044b\u0435 \u0444\u043b\u0430\u0433\u0438 \u043a\u043e\u043c\u043f\u0438\u043b\u044f\u0442\u043e\u0440\u0430 V \u0434\u043e\u043b\u0436\u043d\u044b \u0431\u044b\u0442\u044c \u043f\u0435\u0440\u0435\u0434\u0430\u043d\u044b \u043f\u0435\u0440\u0435\u0434 \u043a\u043e\u043c\u0430\u043d\u0434\u043e\u0439 ",(0,i.kt)("inlineCode",{parentName:"p"},"run")," \u0412\u0441\u0435, \u0447\u0442\u043e \u043d\u0430\u0445\u043e\u0434\u0438\u0442\u0441\u044f \u043f\u043e\u0441\u043b\u0435 \u0438\u0441\u0445\u043e\u0434\u043d\u043e\u0433\u043e \u0444\u0430\u0439\u043b\u0430/\u043f\u0430\u043f\u043a\u0438, \u0431\u0443\u0434\u0435\u0442 \u043f\u0435\u0440\u0435\u0434\u0430\u043d\u043e \u0432 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0443 \u043a\u0430\u043a \u0435\u0441\u0442\u044c \u2014 \u043e\u043d\u043e \u043d\u0435 \u0431\u0443\u0434\u0435\u0442 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0430\u043d\u043e V."),(0,i.kt)("h2",{id:"\u043a\u043e\u043c\u043c\u0435\u043d\u0442\u0430\u0440\u0438\u0438"},"\u041a\u043e\u043c\u043c\u0435\u043d\u0442\u0430\u0440\u0438\u0438"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"// \u042d\u0442\u043e \u043e\u0434\u043d\u043e\u0441\u0442\u0440\u043e\u0447\u043d\u044b\u0439 \u043a\u043e\u043c\u043c\u0435\u043d\u0442\u0430\u0440\u0438\u0439.\n/*\n\u042d\u0442\u043e \u043c\u043d\u043e\u0433\u043e\u0441\u0442\u0440\u043e\u0447\u043d\u044b\u0439 \u043a\u043e\u043c\u043c\u0435\u043d\u0442\u0430\u0440\u0438\u0439.\n    /* \u041c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u0432\u043b\u043e\u0436\u0435\u043d\u043d\u044b\u043c. */\n*/\n")),(0,i.kt)("h2",{id:"\u0444\u0443\u043d\u043a\u0446\u0438\u0438"},"\u0424\u0443\u043d\u043a\u0446\u0438\u0438"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"fn main() {\n    println(add(77, 33))\n    println(sub(100, 50))\n}\n\nfn add(x int, y int) int {\n    return x + y\n}\n\nfn sub(x int, y int) int {\n    return x - y\n}\n")),(0,i.kt)("p",null,"\u041e\u043f\u044f\u0442\u044c \u0436\u0435, \u0442\u0438\u043f \u0438\u0434\u0435\u0442 \u043f\u043e\u0441\u043b\u0435 \u0438\u043c\u0435\u043d\u0438 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u0430."),(0,i.kt)("p",null,"\u041a\u0430\u043a \u0438 \u0432 Go \u0438 C, \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u043d\u0435\u043b\u044c\u0437\u044f \u043f\u0435\u0440\u0435\u0433\u0440\u0443\u0436\u0430\u0442\u044c. \u042d\u0442\u043e \u0443\u043f\u0440\u043e\u0449\u0430\u0435\u0442 \u043a\u043e\u0434 \u0438 \u043f\u043e\u0432\u044b\u0448\u0430\u0435\u0442 \u0443\u0434\u043e\u0431\u0441\u0442\u0432\u043e \u0441\u043e\u043f\u0440\u043e\u0432\u043e\u0436\u0434\u0435\u043d\u0438\u044f \u0438 \u0443\u0434\u043e\u0431\u043e\u0447\u0438\u0442\u0430\u0435\u043c\u043e\u0441\u0442\u044c."),(0,i.kt)("h3",{id:"\u043f\u043e\u0434\u044a\u0435\u043c\u044b"},"\u041f\u043e\u0434\u044a\u0435\u043c\u044b"),(0,i.kt)("p",null,"\u0424\u0443\u043d\u043a\u0446\u0438\u0438 \u043c\u043e\u0436\u043d\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0434\u043e \u0438\u0445 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u044f: ",(0,i.kt)("inlineCode",{parentName:"p"},"add")," \u0438 ",(0,i.kt)("inlineCode",{parentName:"p"},"sub")," \u043e\u0431\u044a\u044f\u0432\u043b\u044f\u044e\u0442\u0441\u044f \u043f\u043e\u0441\u043b\u0435 ",(0,i.kt)("inlineCode",{parentName:"p"},"main"),", \u043d\u043e \u0432\u0441\u0435 \u0440\u0430\u0432\u043d\u043e \u043c\u043e\u0433\u0443\u0442 \u0431\u044b\u0442\u044c \u0432\u044b\u0437\u0432\u0430\u043d\u044b \u0438\u0437 ",(0,i.kt)("inlineCode",{parentName:"p"},"main"),". \u042d\u0442\u043e \u0432\u0435\u0440\u043d\u043e \u0434\u043b\u044f \u0432\u0441\u0435\u0445 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0439 \u0432 V \u0438 \u0443\u0441\u0442\u0440\u0430\u043d\u044f\u0435\u0442 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e\u0441\u0442\u044c \u0432 \u0444\u0430\u0439\u043b\u0430\u0445 \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043a\u043e\u0432 \u0438\u043b\u0438 \u0440\u0430\u0437\u043c\u044b\u0448\u043b\u0435\u043d\u0438\u044f\u0445 \u043e \u043f\u043e\u0440\u044f\u0434\u043a\u0435 \u0444\u0430\u0439\u043b\u043e\u0432 \u0438 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0439."),(0,i.kt)("h3",{id:"\u0432\u043e\u0437\u0432\u0440\u0430\u0442-\u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u0438\u0445-\u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439"},"\u0412\u043e\u0437\u0432\u0440\u0430\u0442 \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u0438\u0445 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"fn foo() (int, int) {\n    return 2, 3\n}\n\na, b := foo()\nprintln(a) // 2\nprintln(b) // 3\nc, _ := foo() // \u0438\u0433\u043d\u043e\u0440\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044f `_`\n")),(0,i.kt)("h2",{id:"\u0432\u0438\u0434\u0438\u043c\u043e\u0441\u0442\u044c"},"\u0412\u0438\u0434\u0438\u043c\u043e\u0441\u0442\u044c"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"pub fn public_function() {\n}\n\nfn private_function() {\n}\n")),(0,i.kt)("p",null,"\u0424\u0443\u043d\u043a\u0446\u0438\u0438 \u044f\u0432\u043b\u044f\u044e\u0442\u0441\u044f \u0447\u0430\u0441\u0442\u043d\u044b\u043c\u0438 (\u043d\u0435 \u044d\u043a\u0441\u043f\u043e\u0440\u0442\u0438\u0440\u0443\u044e\u0442\u0441\u044f) \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e. \u0427\u0442\u043e\u0431\u044b \u0434\u0440\u0443\u0433\u0438\u0435 \u043c\u043e\u0434\u0443\u043b\u0438 \u043c\u043e\u0433\u043b\u0438 \u0438\u0445 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c, \u0434\u043e\u0431\u0430\u0432\u044c\u0442\u0435 ",(0,i.kt)("inlineCode",{parentName:"p"},"pub"),". \u0422\u043e \u0436\u0435 \u0441\u0430\u043c\u043e\u0435 \u043e\u0442\u043d\u043e\u0441\u0438\u0442\u0441\u044f \u043a \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u0430\u043c \u0438 \u0442\u0438\u043f\u0430\u043c."),(0,i.kt)("p",null,"\u041f\u0440\u0438\u043c\u0435\u0447\u0430\u043d\u0438\u0435: ",(0,i.kt)("inlineCode",{parentName:"p"},"pub")," \u043c\u043e\u0436\u0435\u0442 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c\u0441\u044f \u0442\u043e\u043b\u044c\u043a\u043e \u0438\u0437 \u0438\u043c\u0435\u043d\u043e\u0432\u0430\u043d\u043d\u043e\u0433\u043e \u043c\u043e\u0434\u0443\u043b\u044f. \u0414\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u043e \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0438 \u043c\u043e\u0434\u0443\u043b\u044f \u0441\u043c. \u0440\u0430\u0437\u0434\u0435\u043b ",(0,i.kt)("a",{parentName:"p",href:"#modules"},"\u041c\u043e\u0434\u0443\u043b\u0438"),"."),(0,i.kt)("h2",{id:"\u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435"},"\u041f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"name := 'Bob'\nage := 20\nlarge_number := i64(9999999999)\nprintln(name)\nprintln(age)\nprintln(large_number)\n")),(0,i.kt)("p",null,"\u041f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435 \u043e\u0431\u044a\u044f\u0432\u043b\u044f\u044e\u0442\u0441\u044f \u0438 \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0438\u0440\u0443\u044e\u0442\u0441\u044f \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e ",(0,i.kt)("inlineCode",{parentName:"p"},":="),". \u042d\u0442\u043e \u0435\u0434\u0438\u043d\u0441\u0442\u0432\u0435\u043d\u043d\u044b\u0439 \u0441\u043f\u043e\u0441\u043e\u0431 \u043e\u0431\u044a\u044f\u0432\u0438\u0442\u044c \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435 \u0432 V. \u042d\u0442\u043e \u043e\u0437\u043d\u0430\u0447\u0430\u0435\u0442, \u0447\u0442\u043e \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435 \u0432\u0441\u0435\u0433\u0434\u0430 \u0438\u043c\u0435\u044e\u0442 \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435."),(0,i.kt)("p",null,"\u0422\u0438\u043f \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439 \u0432\u044b\u0432\u043e\u0434\u0438\u0442\u0441\u044f \u0438\u0437 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0432 \u043f\u0440\u0430\u0432\u043e\u0439 \u0447\u0430\u0441\u0442\u0438. \u0427\u0442\u043e\u0431\u044b \u0432\u044b\u0431\u0440\u0430\u0442\u044c \u0434\u0440\u0443\u0433\u043e\u0439 \u0442\u0438\u043f, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0442\u0438\u043f\u043e\u0432: \u0432\u044b\u0440\u0430\u0436\u0435\u043d\u0438\u0435 ",(0,i.kt)("inlineCode",{parentName:"p"},"T(v)")," \u043f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u0443\u0435\u0442 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," \u0432 \u0442\u0438\u043f ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),"."),(0,i.kt)("p",null,"\u0412 \u043e\u0442\u043b\u0438\u0447\u0438\u0435 \u043e\u0442 \u0431\u043e\u043b\u044c\u0448\u0438\u043d\u0441\u0442\u0432\u0430 \u0434\u0440\u0443\u0433\u0438\u0445 \u044f\u0437\u044b\u043a\u043e\u0432, V \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u0435\u0442 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0442\u044c \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435 \u0442\u043e\u043b\u044c\u043a\u043e \u0432 \u0444\u0443\u043d\u043a\u0446\u0438\u044f\u0445. \u0413\u043b\u043e\u0431\u0430\u043b\u044c\u043d\u044b\u0435 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435 (\u0443\u0440\u043e\u0432\u043d\u044f \u043c\u043e\u0434\u0443\u043b\u044f) \u043d\u0435 \u0434\u043e\u043f\u0443\u0441\u043a\u0430\u044e\u0442\u0441\u044f. \u0412 V \u043d\u0435\u0442 \u0433\u043b\u043e\u0431\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u044f."),(0,i.kt)("p",null,"\u0414\u043b\u044f \u0441\u043e\u0433\u043b\u0430\u0441\u043e\u0432\u0430\u043d\u043d\u043e\u0441\u0442\u0438 \u043c\u0435\u0436\u0434\u0443 \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u043c\u0438 \u0431\u0430\u0437\u0430\u043c\u0438 \u043a\u043e\u0434\u0430 \u0432\u0441\u0435 \u0438\u043c\u0435\u043d\u0430 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0445 \u0438 \u0444\u0443\u043d\u043a\u0446\u0438\u0439 \u0434\u043e\u043b\u0436\u043d\u044b \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c ",(0,i.kt)("inlineCode",{parentName:"p"},"snake_case")," \u0441\u0442\u0438\u043b\u044c, \u0432 \u043e\u0442\u043b\u0438\u0447\u0438\u0435 \u043e\u0442 \u0438\u043c\u0435\u043d \u0442\u0438\u043f\u043e\u0432, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u0434\u043e\u043b\u0436\u043d\u044b \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c ",(0,i.kt)("inlineCode",{parentName:"p"},"PascalCase"),"."),(0,i.kt)("h3",{id:"\u0438\u0437\u043c\u0435\u043d\u044f\u0435\u043c\u044b\u0435-\u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435"},"\u0418\u0437\u043c\u0435\u043d\u044f\u0435\u043c\u044b\u0435 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"mut age := 20\nprintln(age)\nage = 21\nprintln(age)\n")),(0,i.kt)("p",null,"\u0427\u0442\u043e\u0431\u044b \u0438\u0437\u043c\u0435\u043d\u0438\u0442\u044c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 ",(0,i.kt)("inlineCode",{parentName:"p"},"="),". \u0412 V \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435 \u043d\u0435\u0438\u0437\u043c\u0435\u043d\u044f\u0435\u043c\u044b \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e. \u0427\u0442\u043e\u0431\u044b \u0438\u043c\u0435\u0442\u044c \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c \u0438\u0437\u043c\u0435\u043d\u0438\u0442\u044c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439, \u0432\u044b \u0434\u043e\u043b\u0436\u043d\u044b \u043e\u0431\u044a\u044f\u0432\u0438\u0442\u044c \u0435\u0435 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e ",(0,i.kt)("inlineCode",{parentName:"p"},"mut"),"."),(0,i.kt)("p",null,"\u041f\u043e\u043f\u0440\u043e\u0431\u0443\u0439\u0442\u0435 \u0441\u043a\u043e\u043c\u043f\u0438\u043b\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0443 \u0432\u044b\u0448\u0435 \u043f\u043e\u0441\u043b\u0435 \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044f ",(0,i.kt)("inlineCode",{parentName:"p"},"mut")," \u0438\u0437 \u043f\u0435\u0440\u0432\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0438."),(0,i.kt)("h3",{id:"\u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f-vs-\u043d\u0430\u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435"},"\u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f vs \u043d\u0430\u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435"),(0,i.kt)("p",null,"\u041e\u0431\u0440\u0430\u0442\u0438\u0442\u0435 \u0432\u043d\u0438\u043c\u0430\u043d\u0438\u0435 \u043d\u0430 (\u0432\u0430\u0436\u043d\u0443\u044e) \u0440\u0430\u0437\u043d\u0438\u0446\u0443 \u043c\u0435\u0436\u0434\u0443 ",(0,i.kt)("inlineCode",{parentName:"p"},":=")," \u0438 ",(0,i.kt)("inlineCode",{parentName:"p"},"="),".\n",(0,i.kt)("inlineCode",{parentName:"p"},":=")," \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u0434\u043b\u044f \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u044f \u0438 \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438, ",(0,i.kt)("inlineCode",{parentName:"p"},"=")," \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u0434\u043b\u044f \u043f\u0440\u0438\u0441\u0432\u0430\u0438\u0432\u0430\u043d\u0438\u044f."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"failcompile",failcompile:!0},"fn main() {\n    age = 21\n}\n")),(0,i.kt)("p",null,"\u042d\u0442\u043e\u0442 \u043a\u043e\u0434 \u043d\u0435 \u0441\u043a\u043e\u043c\u043f\u0438\u043b\u0438\u0440\u0443\u0435\u0442\u0441\u044f, \u043f\u043e\u0442\u043e\u043c\u0443 \u0447\u0442\u043e \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0430\u044f ",(0,i.kt)("inlineCode",{parentName:"p"},"age")," \u043d\u0435 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0430. \u0412\u0441\u0435 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435 \u0434\u043e\u043b\u0436\u043d\u044b \u0431\u044b\u0442\u044c \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u044b \u0432 V."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"fn main() {\n    age := 21\n}\n")),(0,i.kt)("p",null,"\u0417\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u0438\u0445 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0445 \u043c\u043e\u0436\u043d\u043e \u0438\u0437\u043c\u0435\u043d\u0438\u0442\u044c \u0432 \u043e\u0434\u043d\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0435. \u0422\u0430\u043a\u0438\u043c \u043e\u0431\u0440\u0430\u0437\u043e\u043c, \u0438\u0445 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043c\u043e\u0436\u043d\u043e \u043f\u043e\u043c\u0435\u043d\u044f\u0442\u044c \u043c\u0435\u0441\u0442\u0430\u043c\u0438 \u0431\u0435\u0437 \u043f\u0440\u043e\u043c\u0435\u0436\u0443\u0442\u043e\u0447\u043d\u043e\u0439 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"mut a := 0\nmut b := 1\nprintln('$a, $b') // 0, 1\na, b = b, a\nprintln('$a, $b') // 1, 0\n")),(0,i.kt)("h3",{id:"\u043e\u0448\u0438\u0431\u043a\u0438-\u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u044f"},"\u041e\u0448\u0438\u0431\u043a\u0438 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u044f"),(0,i.kt)("p",null,'\u0412 \u0440\u0435\u0436\u0438\u043c\u0435 \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u043a\u0438 \u043a\u043e\u043c\u043f\u0438\u043b\u044f\u0442\u043e\u0440 \u043f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0434\u0438\u0442 \u0432\u0430\u0441, \u0447\u0442\u043e \u0432\u044b \u043d\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043b\u0438 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0443\u044e (\u0432\u044b \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u0435 \u043f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u0435 "\u043d\u0435\u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u0430\u044f \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0430\u044f"). \u0412 \u0440\u0430\u0431\u043e\u0447\u0435\u043c \u0440\u0435\u0436\u0438\u043c\u0435 (\u0432\u043a\u043b\u044e\u0447\u0430\u0435\u043c\u043e\u043c \u043f\u0435\u0440\u0435\u0434\u0430\u0447\u0435\u0439 ',(0,i.kt)("inlineCode",{parentName:"p"},"-prod")," \u0444\u043b\u0430\u0433\u0430 v \u2014 ",(0,i.kt)("inlineCode",{parentName:"p"},"v -prod foo.v"),") \u043e\u043d \u0432\u043e\u043e\u0431\u0449\u0435 \u043d\u0435 \u0431\u0443\u0434\u0435\u0442 \u043a\u043e\u043c\u043f\u0438\u043b\u0438\u0440\u043e\u0432\u0430\u0442\u044c\u0441\u044f (\u043a\u0430\u043a \u0432 Go)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"fn main() {\n    a := 10\n    if true {\n        a := 20 // \u043e\u0448\u0438\u0431\u043a\u0430: \u043f\u0435\u0440\u0435\u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 `a`\n    }\n    // \u043f\u0440\u0435\u0434\u0443\u043f\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u0435: \u043d\u0435\u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u0430\u044f \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0430\u044f `a`\n}\n")),(0,i.kt)("p",null,"\u0412 \u043e\u0442\u043b\u0438\u0447\u0438\u0435 \u043e\u0442 \u0431\u043e\u043b\u044c\u0448\u0438\u043d\u0441\u0442\u0432\u0430 \u044f\u0437\u044b\u043a\u043e\u0432, \u0437\u0430\u0442\u0435\u043d\u0435\u043d\u0438\u0435 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0445 \u043d\u0435 \u0434\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u0442\u0441\u044f. \u041e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439 \u0441 \u0438\u043c\u0435\u043d\u0435\u043c, \u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u0443\u0436\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u0432 \u0440\u043e\u0434\u0438\u0442\u0435\u043b\u044c\u0441\u043a\u043e\u0439 \u043e\u0431\u043b\u0430\u0441\u0442\u0438, \u0432\u044b\u0437\u043e\u0432\u0435\u0442 \u043e\u0448\u0438\u0431\u043a\u0443 \u043a\u043e\u043c\u043f\u0438\u043b\u044f\u0446\u0438\u0438."),(0,i.kt)("p",null,"\u041e\u0434\u043d\u0430\u043a\u043e \u0432\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u0441\u043a\u0440\u044b\u0432\u0430\u0442\u044c \u0438\u043c\u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u0435 \u043c\u043e\u0434\u0443\u043b\u0438, \u0442\u0430\u043a \u043a\u0430\u043a \u0432 \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u0441\u0438\u0442\u0443\u0430\u0446\u0438\u044f\u0445 \u044d\u0442\u043e \u043e\u0447\u0435\u043d\u044c \u043f\u043e\u043b\u0435\u0437\u043d\u043e:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"import ui\nimport gg\n\nfn draw(ctx &gg.Context) {\n    gg := ctx.parent.get_ui().gg\n    gg.draw_rect(10, 10, 100, 50)\n}\n")),(0,i.kt)("h2",{id:"v-\u0442\u0438\u043f\u044b"},"V \u0422\u0438\u043f\u044b"),(0,i.kt)("h3",{id:"\u043f\u0440\u0438\u043c\u0438\u0442\u0438\u0432\u043d\u044b\u0435-\u0442\u0438\u043f\u044b"},"\u041f\u0440\u0438\u043c\u0438\u0442\u0438\u0432\u043d\u044b\u0435 \u0442\u0438\u043f\u044b"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"ignore",ignore:!0},"bool\n\nstring\n\ni8    i16  int  i64      i128 (\u0441\u043a\u043e\u0440\u043e)\nu8    u16  u32  u64      u128 (\u0441\u043a\u043e\u0440\u043e)\n\nrune // \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u0442 \u043a\u043e\u0434\u043e\u0432\u0443\u044e \u0442\u043e\u0447\u043a\u0443 Unicode\n\nf32 f64\n\nisize, usize // \u0437\u0430\u0432\u0438\u0441\u0438\u0442 \u043e\u0442 \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u044b, \u0440\u0430\u0437\u043c\u0435\u0440 \u2014 \u044d\u0442\u043e \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0431\u0430\u0439\u0442\u043e\u0432, \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e\u0435 \u0434\u043b\u044f \u0441\u0441\u044b\u043b\u043a\u0438 \u043d\u0430 \u043b\u044e\u0431\u043e\u0435 \u043c\u0435\u0441\u0442\u043e \u0432 \u043f\u0430\u043c\u044f\u0442\u0438.\n\nvoidptr // \u044d\u0442\u043e\u0442 \u0432 \u043e\u0441\u043d\u043e\u0432\u043d\u043e\u043c \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u0434\u043b\u044f \u0441\u043e\u0432\u043c\u0435\u0441\u0442\u0438\u043c\u043e\u0441\u0442\u0438 C\n\nany // \u043f\u043e\u0445\u043e\u0436 \u043d\u0430 void* \u0432 C \u0438 \u0438\u043d\u0442\u0435\u0440\u0444\u0435\u0439\u0441 Go{}\n")),(0,i.kt)("p",null,"\u041e\u0431\u0440\u0430\u0442\u0438\u0442\u0435 \u0432\u043d\u0438\u043c\u0430\u043d\u0438\u0435, \u0447\u0442\u043e \u0432 \u043e\u0442\u043b\u0438\u0447\u0438\u0435 \u043e\u0442 C \u0438 Go, ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," \u044d\u0442\u043e \u0432\u0441\u0435\u0433\u0434\u0430 32-\u0431\u0438\u0442\u043d\u043e\u0435 \u0446\u0435\u043b\u043e\u0435 \u0447\u0438\u0441\u043b\u043e."),(0,i.kt)("p",null,"\u0421\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u0438\u0437 \u043f\u0440\u0430\u0432\u0438\u043b\u0430, \u0441\u043e\u0433\u043b\u0430\u0441\u043d\u043e \u043a\u043e\u0442\u043e\u0440\u043e\u043c\u0443 \u0432\u0441\u0435 \u043e\u043f\u0435\u0440\u0430\u0442\u043e\u0440\u044b \u0432 V \u0434\u043e\u043b\u0436\u043d\u044b \u0438\u043c\u0435\u0442\u044c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043e\u0434\u043d\u043e\u0433\u043e \u0438 \u0442\u043e\u0433\u043e \u0436\u0435 \u0442\u0438\u043f\u0430 \u0441 \u043e\u0431\u0435\u0438\u0445 \u0441\u0442\u043e\u0440\u043e\u043d. \u041d\u0435\u0431\u043e\u043b\u044c\u0448\u043e\u0439 \u043f\u0440\u0438\u043c\u0438\u0442\u0438\u0432\u043d\u044b\u0439 \u0442\u0438\u043f \u043d\u0430 \u043e\u0434\u043d\u043e\u0439 \u0441\u0442\u043e\u0440\u043e\u043d\u0435 \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438 \u043f\u043e\u0432\u044b\u0448\u0435\u043d, \u0435\u0441\u043b\u0438 \u043e\u043d \u043f\u043e\u043b\u043d\u043e\u0441\u0442\u044c\u044e \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u0435\u0442 \u0434\u0438\u0430\u043f\u0430\u0437\u043e\u043d\u0443 \u0434\u0430\u043d\u043d\u044b\u0445 \u0442\u0438\u043f\u0430 \u043d\u0430 \u0434\u0440\u0443\u0433\u043e\u0439 \u0441\u0442\u043e\u0440\u043e\u043d\u0435. \u042d\u0442\u043e \u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d\u043d\u044b\u0435 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u0438:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"   i8 \u2192 i16 \u2192 int \u2192 i64\n                  \u2198     \u2198\n                    f32 \u2192 f64\n                  \u2197     \u2197\n   u8 \u2192 u16 \u2192 u32 \u2192 u64 \u2b0e\n      \u2198     \u2198     \u2198      ptr\n   i8 \u2192 i16 \u2192 int \u2192 i64 \u2b0f\n")),(0,i.kt)("p",null,"\u041d\u0430\u043f\u0440\u0438\u043c\u0435\u0440 ",(0,i.kt)("inlineCode",{parentName:"p"},"int"),", \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438 \u043f\u043e\u0432\u044b\u0448\u0435\u043d\u043e \u0434\u043e ",(0,i.kt)("inlineCode",{parentName:"p"},"f64")," \u0438\u043b\u0438 , ",(0,i.kt)("inlineCode",{parentName:"p"},"i64")," \u043d\u043e \u043d\u0435 \u0434\u043e ",(0,i.kt)("inlineCode",{parentName:"p"},"u32"),". ( ",(0,i.kt)("inlineCode",{parentName:"p"},"u32")," \u043e\u0437\u043d\u0430\u0447\u0430\u043b\u043e \u0431\u044b \u043f\u043e\u0442\u0435\u0440\u044e \u0437\u043d\u0430\u043a\u0430 \u0434\u043b\u044f \u043e\u0442\u0440\u0438\u0446\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u0445 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439). \u041e\u0434\u043d\u0430\u043a\u043e \u043f\u0435\u0440\u0435\u0445\u043e\u0434 \u043e\u0442 ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," \u043a ",(0,i.kt)("inlineCode",{parentName:"p"},"f32")," \u0432 \u043d\u0430\u0441\u0442\u043e\u044f\u0449\u0435\u0435 \u0432\u0440\u0435\u043c\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0435\u0442\u0441\u044f \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438 (\u043d\u043e \u043c\u043e\u0436\u0435\u0442 \u043f\u0440\u0438\u0432\u0435\u0441\u0442\u0438 \u043a \u043f\u043e\u0442\u0435\u0440\u0435 \u0442\u043e\u0447\u043d\u043e\u0441\u0442\u0438 \u0434\u043b\u044f \u0431\u043e\u043b\u044c\u0448\u0438\u0445 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439)."),(0,i.kt)("p",null,"\u041b\u0438\u0442\u0435\u0440\u0430\u043b\u044b \u0442\u0438\u043f\u0430 ",(0,i.kt)("inlineCode",{parentName:"p"},"123")," \u0438\u043b\u0438 ",(0,i.kt)("inlineCode",{parentName:"p"},"4.56")," \u043e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u044e\u0442\u0441\u044f \u043e\u0441\u043e\u0431\u044b\u043c \u043e\u0431\u0440\u0430\u0437\u043e\u043c. \u041e\u043d\u0438 \u043d\u0435 \u043f\u0440\u0438\u0432\u043e\u0434\u044f\u0442 \u043a \u043f\u043e\u0432\u044b\u0448\u0435\u043d\u0438\u044e \u0442\u0438\u043f\u0430, \u043e\u0434\u043d\u0430\u043a\u043e \u043e\u043d\u0438 \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," \u0438 ",(0,i.kt)("inlineCode",{parentName:"p"},"f64"),", \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0435\u043d\u043d\u043e, \u043a\u043e\u0433\u0434\u0430 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0438\u0442\u044c \u0438\u0445 \u0442\u0438\u043f:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"u := u16(12)\nv := 13 + u    // v \u0438\u043c\u0435\u0435\u0442 \u0442\u0438\u043f `u16` - \u0431\u0435\u0437 \u043f\u0440\u043e\u0434\u0432\u0438\u0436\u0435\u043d\u0438\u044f\nx := f32(45.6)\ny := x + 3.14  // x \u0438\u043c\u0435\u0435\u0442 \u0442\u0438\u043f `f32` - \u0431\u0435\u0437 \u043f\u0440\u043e\u0434\u0432\u0438\u0436\u0435\u043d\u0438\u044f\na := 75        // a \u0438\u043c\u0435\u0435\u0442 \u0442\u0438\u043f `int` - \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e \u0434\u043b\u044f \u043b\u0438\u0442\u0435\u0440\u0430\u043b\u0430 int\nb := 14.7      // b \u0438\u043c\u0435\u0435\u0442 \u0442\u0438\u043f `f64` - \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e \u0434\u043b\u044f \u043b\u0438\u0442\u0435\u0440\u0430\u043b\u0430 \u0441 \u043f\u043b\u0430\u0432\u0430\u044e\u0449\u0435\u0439 \u0437\u0430\u043f\u044f\u0442\u043e\u0439\nc := u + a     // c \u0438\u043c\u0435\u0435\u0442 \u0442\u0438\u043f `int` - \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0435 \u043f\u043e\u0432\u044b\u0448\u0435\u043d\u0438\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f `u`\nd := b + x     // d \u0438\u043c\u0435\u0435\u0442 \u0442\u0438\u043f `f64` - \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0435 \u043f\u0440\u043e\u0434\u0432\u0438\u0436\u0435\u043d\u0438\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f `x`\n")),(0,i.kt)("h3",{id:"\u0441\u0442\u0440\u043e\u043a\u0438"},"\u0421\u0442\u0440\u043e\u043a\u0438"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"name := 'Bob'\nassert name.len == 3       // \u043d\u0430\u043f\u0435\u0447\u0430\u0442\u0430\u0435\u0442 3\nassert name[0] == u8(66) // \u0438\u043d\u0434\u0435\u043a\u0441\u0430\u0446\u0438\u044f \u0434\u0430\u0435\u0442 byte, u8(66) == `B`\nassert name[1..3] == 'ob'  // slicing \u0434\u0430\u0435\u0442 \u0441\u0442\u0440\u043e\u043a\u0443 'ob'\n\n// escape codes\nwindows_newline := '\\r\\n'      // \u044d\u043a\u0440\u0430\u043d\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0441\u043f\u0435\u0446\u0438\u0430\u043b\u044c\u043d\u044b\u0435 \u0441\u0438\u043c\u0432\u043e\u043b\u044b, \u043a\u0430\u043a \u0432 C\nassert windows_newline.len == 2\n\n// arbitrary bytes can be directly specified using `\\x##` notation where `#` is\n// a hex digit aardvark_str := '\\x61ardvark' assert aardvark_str == 'aardvark'\nassert '\\xc0'[0] == u8(0xc0)\n\n// or using octal escape `\\###` notation where `#` is an octal digit\naardvark_str2 := '\\141ardvark'\nassert aardvark_str2 == 'aardvark'\n\n// Unicode can be specified directly as `\\u####` where # is a hex digit\n// and will be converted internally to its UTF-8 representation\nstar_str := '\\u2605' // \u2605\nassert star_str == '\u2605'\nassert star_str == '\\xe2\\x98\\x85' // \u0422\u0430\u043a\u0438\u043c \u0436\u0435 \u043e\u0431\u0440\u0430\u0437\u043e\u043c \u043c\u043e\u0436\u043d\u043e \u0443\u043a\u0430\u0437\u0430\u0442\u044c UTF-8\n")),(0,i.kt)("p",null,"\u0412 V \u0441\u0442\u0440\u043e\u043a\u0430 \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u0442 \u0441\u043e\u0431\u043e\u0439 \u043c\u0430\u0441\u0441\u0438\u0432 \u0431\u0430\u0439\u0442\u043e\u0432, \u0434\u043e\u0441\u0442\u0443\u043f\u043d\u044b\u0439 \u0442\u043e\u043b\u044c\u043a\u043e \u0434\u043b\u044f \u0447\u0442\u0435\u043d\u0438\u044f. \u0412\u0441\u0435 \u0441\u0438\u043c\u0432\u043e\u043b\u044b Unicode \u043a\u043e\u0434\u0438\u0440\u0443\u044e\u0442\u0441\u044f \u0441 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c UTF-8:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"s := 'hello \ud83c\udf0e' // \u044d\u043c\u043e\u0434\u0437\u0438 \u0437\u0430\u043d\u0438\u043c\u0430\u0435\u0442 4 \u0431\u0430\u0439\u0442\u0430\nassert s.len == 10\n\narr := s.bytes() // \u043f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u0442\u044c `string` \u0432 `[]u8`\nassert arr.len == 10\n\ns2 := arr.bytestr() // \u043f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u0442\u044c `[]byte` \u0432 `string`\nassert s2 == s\n")),(0,i.kt)("p",null,"\u0421\u0442\u0440\u043e\u043a\u043e\u0432\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043d\u0435\u0438\u0437\u043c\u0435\u043d\u044f\u0435\u043c\u044b. \u0412\u044b \u043d\u0435 \u043c\u043e\u0436\u0435\u0442\u0435 \u0438\u0437\u043c\u0435\u043d\u044f\u0442\u044c \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"failcompile",failcompile:!0},"mut s := 'hello \ud83c\udf0e'\ns[0] = `H` // \u043d\u0435 \u0434\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u0442\u0441\u044f\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"\u043e\u0448\u0438\u0431\u043a\u0430: \u043d\u0435\u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e \u043d\u0430\u0437\u043d\u0430\u0447\u0438\u0442\u044c, s","[i]","\u043f\u043e\u0441\u043a\u043e\u043b\u044c\u043a\u0443 \u0441\u0442\u0440\u043e\u043a\u0438 V \u043d\u0435\u0438\u0437\u043c\u0435\u043d\u044f\u0435\u043c\u044b")),(0,i.kt)("p",null,"\u041e\u0431\u0440\u0430\u0442\u0438\u0442\u0435 \u0432\u043d\u0438\u043c\u0430\u043d\u0438\u0435, \u0447\u0442\u043e \u043f\u0440\u0438 \u0438\u043d\u0434\u0435\u043a\u0441\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0438 \u0441\u0442\u0440\u043e\u043a\u0438 \u0431\u0443\u0434\u0435\u0442 \u043f\u043e\u043b\u0443\u0447\u0435\u043d ",(0,i.kt)("inlineCode",{parentName:"p"},"byte"),", \u0430 \u043d\u0435 ",(0,i.kt)("inlineCode",{parentName:"p"},"rune")," \u043b\u0438\u0431\u043e \u0434\u0440\u0443\u0433\u043e\u0439",(0,i.kt)("inlineCode",{parentName:"p"},"string"),". \u0418\u043d\u0434\u0435\u043a\u0441\u044b \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u044e\u0442 \u0431\u0430\u0439\u0442\u0430\u043c \u0432 \u0441\u0442\u0440\u043e\u043a\u0435, \u0430 \u043d\u0435 \u043a\u043e\u0434\u043e\u0432\u044b\u043c \u0442\u043e\u0447\u043a\u0430\u043c Unicode. \u0415\u0441\u043b\u0438 \u0432\u044b \u0445\u043e\u0442\u0438\u0442\u0435 \u043f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u0442\u044c ",(0,i.kt)("inlineCode",{parentName:"p"},"byte")," \u0432 ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),", \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 ",(0,i.kt)("inlineCode",{parentName:"p"},".ascii_str()")," \u043c\u0435\u0442\u043e\u0434:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"country := 'Netherlands'\nprintln(country[0]) // \u0412\u044b\u0432\u043e\u0434: 78\nprintln(country[0].ascii_str()) // \u0412\u044b\u0432\u043e\u0434: N\n")),(0,i.kt)("p",null,"\u0414\u043b\u044f \u043e\u0431\u043e\u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0441\u0442\u0440\u043e\u043a \u043c\u043e\u0436\u043d\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u043a\u0430\u043a \u043e\u0434\u0438\u043d\u0430\u0440\u043d\u044b\u0435, \u0442\u0430\u043a \u0438 \u0434\u0432\u043e\u0439\u043d\u044b\u0435 \u043a\u0430\u0432\u044b\u0447\u043a\u0438. \u0414\u043b\u044f \u0441\u043e\u0433\u043b\u0430\u0441\u043e\u0432\u0430\u043d\u043d\u043e\u0441\u0442\u0438 ",(0,i.kt)("inlineCode",{parentName:"p"},"vfmt")," \u043f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u0443\u0435\u0442 \u0434\u0432\u043e\u0439\u043d\u044b\u0435 \u043a\u0430\u0432\u044b\u0447\u043a\u0438 \u0432 \u043e\u0434\u0438\u043d\u0430\u0440\u043d\u044b\u0435, \u0435\u0441\u043b\u0438 \u0442\u043e\u043b\u044c\u043a\u043e \u0441\u0442\u0440\u043e\u043a\u0430 \u043d\u0435 \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u0441\u0438\u043c\u0432\u043e\u043b \u043e\u0434\u0438\u043d\u0430\u0440\u043d\u043e\u0439 \u043a\u0430\u0432\u044b\u0447\u043a\u0438."),(0,i.kt)("p",null,"\u0414\u043b\u044f \u043d\u0435\u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0430\u043d\u043d\u044b\u0445 \u0441\u0442\u0440\u043e\u043a \u0434\u043e\u0431\u0430\u0432\u044c\u0442\u0435 ",(0,i.kt)("inlineCode",{parentName:"p"},"r"),". \u041e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u044d\u043a\u0440\u0430\u043d\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u043d\u0435 \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0435\u0442\u0441\u044f \u0434\u043b\u044f \u043d\u0435\u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0430\u043d\u043d\u044b\u0445 \u0441\u0442\u0440\u043e\u043a:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"s := r'hello\\nworld' // `\\n` \u0431\u0443\u0434\u0435\u0442 \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d \u043a\u0430\u043a \u0434\u0432\u0430 \u0441\u0438\u043c\u0432\u043e\u043b\u0430\nprintln(s) // \"hello\\nworld\"\n")),(0,i.kt)("p",null,"\u0421\u0442\u0440\u043e\u043a\u0438 \u043c\u043e\u0436\u043d\u043e \u043b\u0435\u0433\u043a\u043e \u043f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u0442\u044c \u0432 \u0446\u0435\u043b\u044b\u0435 \u0447\u0438\u0441\u043b\u0430:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"s := '42'\nn := s.int() // 42\n\n// \u0432\u0441\u0435 \u043b\u0438\u0442\u0435\u0440\u0430\u043b\u044b int \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u044e\u0442\u0441\u044f\nassert '0xc3'.int() == 195\nassert '0o10'.int() == 8\nassert '0b1111_0000_1010'.int() == 3850\nassert '-0b1111_0000_1010'.int() == -3850\n")),(0,i.kt)("p",null,"\u0414\u043b\u044f \u0431\u043e\u043b\u0435\u0435 \u0441\u043b\u043e\u0436\u043d\u043e\u0439 ",(0,i.kt)("inlineCode",{parentName:"p"},"string")," \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 \u0438 \u043f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u043e\u0431\u0440\u0430\u0442\u0438\u0442\u0435\u0441\u044c \u043a \u043c\u043e\u0434\u0443\u043b\u044e\n",(0,i.kt)("a",{parentName:"p",href:"https://modules.vlang.io/strconv.html"},"vlib/strconv"),"."),(0,i.kt)("h3",{id:"\u0438\u043d\u0442\u0435\u0440\u043f\u043e\u043b\u044f\u0446\u0438\u044f-\u0441\u0442\u0440\u043e\u043a"},"\u0418\u043d\u0442\u0435\u0440\u043f\u043e\u043b\u044f\u0446\u0438\u044f \u0441\u0442\u0440\u043e\u043a"),(0,i.kt)("p",null,"Basic interpolation syntax is pretty simple - use ",(0,i.kt)("inlineCode",{parentName:"p"},"$")," before a variable name. The variable will be\nconverted to a string and embedded into the literal:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"name := 'Bob'\nprintln('Hello, $name!') // Hello, Bob!\n")),(0,i.kt)("p",null,"It also works with fields: ",(0,i.kt)("inlineCode",{parentName:"p"},"'age = $user.age'"),". If you need more complex expressions, use ",(0,i.kt)("inlineCode",{parentName:"p"},"${}"),":\n",(0,i.kt)("inlineCode",{parentName:"p"},"'can register = ${user.age > 13}'"),"."),(0,i.kt)("p",null,"Format specifiers similar to those in C's ",(0,i.kt)("inlineCode",{parentName:"p"},"printf()")," are also supported. ",(0,i.kt)("inlineCode",{parentName:"p"},"f"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"g"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"x"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"o"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"b"),",\netc. are optional and specify the output format. The compiler takes care of the storage size, so\nthere is no ",(0,i.kt)("inlineCode",{parentName:"p"},"hd")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"llu"),"."),(0,i.kt)("p",null,"To use a format specifier, follow this pattern:"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"${varname:[flags][width][.precision][type]}")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"flags: may be zero or more of the following: ",(0,i.kt)("inlineCode",{parentName:"li"},"-")," to left-align output within the field, ",(0,i.kt)("inlineCode",{parentName:"li"},"0")," to use\n",(0,i.kt)("inlineCode",{parentName:"li"},"0")," as the padding character instead of the default ",(0,i.kt)("inlineCode",{parentName:"li"},"space")," character. (Note: V does not currently\nsupport the use of ",(0,i.kt)("inlineCode",{parentName:"li"},"'")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"#")," as format flags, and V supports but doesn't need ",(0,i.kt)("inlineCode",{parentName:"li"},"+")," to right-align\nsince that's the default.)"),(0,i.kt)("li",{parentName:"ul"},"width: may be an integer value describing the minimum width of total field to output."),(0,i.kt)("li",{parentName:"ul"},"precision: an integer value preceded by a ",(0,i.kt)("inlineCode",{parentName:"li"},".")," will guarantee that many digits after the decimal\npoint, if the input variable is a float. Ignored if variable is an integer."),(0,i.kt)("li",{parentName:"ul"},"type: ",(0,i.kt)("inlineCode",{parentName:"li"},"f")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"F")," specify the input is a float and should be rendered as such, ",(0,i.kt)("inlineCode",{parentName:"li"},"e")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"E")," specify\nthe input is a float and should be rendered as an exponent (partially broken), ",(0,i.kt)("inlineCode",{parentName:"li"},"g")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"G")," specify\nthe input is a float--the renderer will use floating point notation for small values and exponent\nnotation for large values, ",(0,i.kt)("inlineCode",{parentName:"li"},"d")," specifies the input is an integer and should be rendered in base-10\ndigits, ",(0,i.kt)("inlineCode",{parentName:"li"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"X")," require an integer and will render it as hexadecimal digits, ",(0,i.kt)("inlineCode",{parentName:"li"},"o")," requires an\ninteger and will render it as octal digits, ",(0,i.kt)("inlineCode",{parentName:"li"},"b")," requires an integer and will render it as binary\ndigits, ",(0,i.kt)("inlineCode",{parentName:"li"},"s")," requires a string (almost never used).")),(0,i.kt)("p",null,"Note: when a numeric type can render alphabetic characters, such as hex strings or special values\nlike ",(0,i.kt)("inlineCode",{parentName:"p"},"infinity"),", the lowercase version of the type forces lowercase alphabetics and the uppercase\nversion forces uppercase alphabetics."),(0,i.kt)("p",null,"Also note: in most cases, it's best to leave the format type empty. Floats will be rendered by\ndefault as ",(0,i.kt)("inlineCode",{parentName:"p"},"g"),", integers will be rendered by default as ",(0,i.kt)("inlineCode",{parentName:"p"},"d"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"s")," is almost always redundant.\nThere are only three cases where specifying a type is recommended:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"format strings are parsed at compile time, so specifying a type can help detect errors then"),(0,i.kt)("li",{parentName:"ul"},"format strings default to using lowercase letters for hex digits and the ",(0,i.kt)("inlineCode",{parentName:"li"},"e")," in exponents. Use a\nuppercase type to force the use of uppercase hex digits and an uppercase ",(0,i.kt)("inlineCode",{parentName:"li"},"E")," in exponents."),(0,i.kt)("li",{parentName:"ul"},"format strings are the most convenient way to get hex, binary or octal strings from an integer.")),(0,i.kt)("p",null,"See\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Printf_format_string#Format_placeholder_specification"},"Format Placeholder Specification"),"\nfor more information."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"x := 123.4567\nprintln('[${x:.2}]') // round to two decimal places => [123.46]\nprintln('[${x:10}]') // right-align with spaces on the left => [   123.457]\nprintln('[${int(x):-10}]') // left-align with spaces on the right => [123       ]\nprintln('[${int(x):010}]') // pad with zeros on the left => [0000000123]\nprintln('[${int(x):b}]') // output as binary => [1111011]\nprintln('[${int(x):o}]') // output as octal => [173]\nprintln('[${int(x):X}]') // output as uppercase hex => [7B]\n\nprintln('[${10.0000:.2}]') // remove insignificant 0s at the end => [10]\nprintln('[${10.0000:.2f}]') // do show the 0s at the end, even though they do not change the number => [10.00]\n")),(0,i.kt)("h3",{id:"string-operators"},"String operators"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"name := 'Bob'\nbobby := name + 'by' // + is used to concatenate strings\nprintln(bobby) // \"Bobby\"\nmut s := 'hello '\ns += 'world' // `+=` is used to append to a string\nprintln(s) // \"hello world\"\n")),(0,i.kt)("p",null,"All operators in V must have values of the same type on both sides. You cannot concatenate an\ninteger to a string:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"failcompile",failcompile:!0},"age := 10\nprintln('age = ' + age) // not allowed\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"error: infix expr: cannot use ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," (right expression) as ",(0,i.kt)("inlineCode",{parentName:"p"},"string"))),(0,i.kt)("p",null,"We have to either convert ",(0,i.kt)("inlineCode",{parentName:"p"},"age")," to a ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"age := 11\nprintln('age = ' + age.str())\n")),(0,i.kt)("p",null,"or use string interpolation (preferred):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"age := 12\nprintln('age = $age')\n")),(0,i.kt)("h3",{id:"runes"},"Runes"),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"rune")," represents a single Unicode character and is an alias for ",(0,i.kt)("inlineCode",{parentName:"p"},"u32"),". To denote them, use `\n(backticks) :"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"rocket := `\ud83d\ude80`\n")),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"rune")," can be converted to a UTF-8 string by using the ",(0,i.kt)("inlineCode",{parentName:"p"},".str()")," method."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"rocket := `\ud83d\ude80`\nassert rocket.str() == '\ud83d\ude80'\n")),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"rune")," can be converted to UTF-8 bytes by using the ",(0,i.kt)("inlineCode",{parentName:"p"},".bytes()")," method."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"rocket := `\ud83d\ude80`\nassert rocket.bytes() == [u8(0xf0), 0x9f, 0x9a, 0x80]\n")),(0,i.kt)("p",null,"Hex, Unicode, and Octal escape sequences also work in a ",(0,i.kt)("inlineCode",{parentName:"p"},"rune")," literal:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"assert `\\x61` == `a`\nassert `\\141` == `a`\nassert `\\u0061` == `a`\n\n// multibyte literals work too\nassert `\\u2605` == `\u2605`\nassert `\\u2605`.bytes() == [u8(0xe2), 0x98, 0x85]\nassert `\\xe2\\x98\\x85`.bytes() == [u8(0xe2), 0x98, 0x85]\nassert `\\342\\230\\205`.bytes() == [u8(0xe2), 0x98, 0x85]\n")),(0,i.kt)("p",null,"Note that ",(0,i.kt)("inlineCode",{parentName:"p"},"rune")," literals use the same escape syntax as strings, but they can only hold one unicode\ncharacter. Therefore, if your code does not specify a single Unicode character, you will receive an\nerror at compile time."),(0,i.kt)("p",null,"Also remember that strings are indexed as bytes, not runes, so beware:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"rocket_string := '\ud83d\ude80'\nassert rocket_string[0] != `\ud83d\ude80`\nassert 'aloha!'[0] == `a`\n")),(0,i.kt)("p",null,"A string can be converted to runes by the ",(0,i.kt)("inlineCode",{parentName:"p"},".runes()")," method."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"hello := 'Hello World \ud83d\udc4b'\nhello_runes := hello.runes() // [`H`, `e`, `l`, `l`, `o`, ` `, `W`, `o`, `r`, `l`, `d`, ` `, `\ud83d\udc4b`]\nassert hello_runes.string() == hello\n")),(0,i.kt)("h3",{id:"numbers"},"Numbers"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"a := 123\n")),(0,i.kt)("p",null,"This will assign the value of 123 to ",(0,i.kt)("inlineCode",{parentName:"p"},"a"),". By default ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," will have the\ntype ",(0,i.kt)("inlineCode",{parentName:"p"},"int"),"."),(0,i.kt)("p",null,"You can also use hexadecimal, binary or octal notation for integer literals:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"a := 0x7B\nb := 0b01111011\nc := 0o173\n")),(0,i.kt)("p",null,"All of these will be assigned the same value, 123. They will all have type\n",(0,i.kt)("inlineCode",{parentName:"p"},"int"),", no matter what notation you used."),(0,i.kt)("p",null,"V also supports writing numbers with ",(0,i.kt)("inlineCode",{parentName:"p"},"_")," as separator:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"num := 1_000_000 // same as 1000000\nthree := 0b0_11 // same as 0b11\nfloat_num := 3_122.55 // same as 3122.55\nhexa := 0xF_F // same as 255\noct := 0o17_3 // same as 0o173\n")),(0,i.kt)("p",null,"If you want a different type of integer, you can use casting:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"a := i64(123)\nb := u8(42)\nc := i16(12345)\n")),(0,i.kt)("p",null,"Assigning floating point numbers works the same way:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"f := 1.0\nf1 := f64(3.14)\nf2 := f32(3.14)\n")),(0,i.kt)("p",null,"If you do not specify the type explicitly, by default float literals\nwill have the type of ",(0,i.kt)("inlineCode",{parentName:"p"},"f64"),"."),(0,i.kt)("p",null,"Float literals can also be declared as a power of ten:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"f0 := 42e1 // 420\nf1 := 123e-2 // 1.23\nf2 := 456e+2 // 45600\n")),(0,i.kt)("h3",{id:"arrays"},"Arrays"),(0,i.kt)("p",null,"An array is a collection of data elements of the same type. An array literal is a\nlist of expressions surrounded by square brackets. An individual element can be\naccessed using an ",(0,i.kt)("em",{parentName:"p"},"index")," expression. Indexes start from ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"mut nums := [1, 2, 3]\nprintln(nums) // `[1, 2, 3]`\nprintln(nums[0]) // `1`\nprintln(nums[1]) // `2`\n\nnums[1] = 5\nprintln(nums) // `[1, 5, 3]`\n")),(0,i.kt)("a",{id:"array-operations"}),(0,i.kt)("p",null,"An element can be appended to the end of an array using the push operator ",(0,i.kt)("inlineCode",{parentName:"p"},"<<"),".\nIt can also append an entire array."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},'mut nums := [1, 2, 3]\nnums << 4\nprintln(nums) // "[1, 2, 3, 4]"\n\n// append array\nnums << [5, 6, 7]\nprintln(nums) // "[1, 2, 3, 4, 5, 6, 7]"\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"mut names := ['John']\nnames << 'Peter'\nnames << 'Sam'\n// names << 10  <-- This will not compile. `names` is an array of strings.\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"val in array")," returns true if the array contains ",(0,i.kt)("inlineCode",{parentName:"p"},"val"),". See ",(0,i.kt)("a",{parentName:"p",href:"#in-operator"},(0,i.kt)("inlineCode",{parentName:"a"},"in")," operator"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"names := ['John', 'Peter', 'Sam']\nprintln('Alex' in names) // \"false\"\n")),(0,i.kt)("h4",{id:"array-fields"},"Array Fields"),(0,i.kt)("p",null,'There are two fields that control the "size" of an array:'),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"len"),": ",(0,i.kt)("em",{parentName:"li"},"length")," - the number of pre-allocated and initialized elements in the array"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cap"),": ",(0,i.kt)("em",{parentName:"li"},"capacity")," - the amount of memory space which has been reserved for elements,\nbut not initialized or counted as elements. The array can grow up to this size without\nbeing reallocated. Usually, V takes care of this field automatically but there are\ncases where the user may want to do manual optimizations (see ",(0,i.kt)("a",{parentName:"li",href:"#array-initialization"},"below"),").")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},'mut nums := [1, 2, 3]\nprintln(nums.len) // "3"\nprintln(nums.cap) // "3" or greater\nnums = [] // The array is now empty\nprintln(nums.len) // "0"\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"data")," is a field (of type ",(0,i.kt)("inlineCode",{parentName:"p"},"voidptr"),") with the address of the first\nelement. This is for low-level ",(0,i.kt)("a",{parentName:"p",href:"#memory-unsafe-code"},(0,i.kt)("inlineCode",{parentName:"a"},"unsafe"))," code."),(0,i.kt)("p",null,"Note that the fields are read-only and can't be modified by the user."),(0,i.kt)("h4",{id:"array-initialization"},"Array Initialization"),(0,i.kt)("p",null,"The type of an array is determined by the first element:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[1, 2, 3]")," is an array of ints (",(0,i.kt)("inlineCode",{parentName:"li"},"[]int"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"['a', 'b']")," is an array of strings (",(0,i.kt)("inlineCode",{parentName:"li"},"[]string"),").")),(0,i.kt)("p",null,"The user can explicitly specify the type for the first element: ",(0,i.kt)("inlineCode",{parentName:"p"},"[u8(16), 32, 64, 128]"),".\nV arrays are homogeneous (all elements must have the same type).\nThis means that code like ",(0,i.kt)("inlineCode",{parentName:"p"},"[1, 'a']")," will not compile."),(0,i.kt)("p",null,"The above syntax is fine for a small number of known elements but for very large or empty\narrays there is a second initialization syntax:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"mut a := []int{len: 10000, cap: 30000, init: 3}\n")),(0,i.kt)("p",null,"This creates an array of 10000 ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," elements that are all initialized with ",(0,i.kt)("inlineCode",{parentName:"p"},"3"),". Memory\nspace is reserved for 30000 elements. The parameters ",(0,i.kt)("inlineCode",{parentName:"p"},"len"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"cap")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"init")," are optional;\n",(0,i.kt)("inlineCode",{parentName:"p"},"len")," defaults to ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"init")," to the default initialization of the element type (",(0,i.kt)("inlineCode",{parentName:"p"},"0"),"\nfor numerical type, ",(0,i.kt)("inlineCode",{parentName:"p"},"''")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),", etc). The run time system makes sure that the\ncapacity is not smaller than ",(0,i.kt)("inlineCode",{parentName:"p"},"len")," (even if a smaller value is specified explicitly):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"arr := []int{len: 5, init: -1}\n// `arr == [-1, -1, -1, -1, -1]`, arr.cap == 5\n\n// Declare an empty array:\nusers := []int{}\n")),(0,i.kt)("p",null,"Setting the capacity improves performance of pushing elements to the array\nas reallocations can be avoided:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"mut numbers := []int{cap: 1000}\nprintln(numbers.len) // 0\n// Now appending elements won't reallocate\nfor i in 0 .. 1000 {\n    numbers << i\n}\n")),(0,i.kt)("p",null,"Note: The above code uses a ",(0,i.kt)("a",{parentName:"p",href:"#range-for"},"range ",(0,i.kt)("inlineCode",{parentName:"a"},"for"))," statement."),(0,i.kt)("p",null,"You can initialize the array by accessing the ",(0,i.kt)("inlineCode",{parentName:"p"},"it")," variable which gives\nthe index as shown here:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"count := []int{len: 4, init: it}\nassert count == [0, 1, 2, 3]\n\nmut square := []int{len: 6, init: it * it}\n// square == [0, 1, 4, 9, 16, 25]\n")),(0,i.kt)("h4",{id:"array-types"},"Array Types"),(0,i.kt)("p",null,"An array can be of these types:\n| Types        | Example Definition                   |\n| ------------ | ------------------------------------ |\n| Number       | ",(0,i.kt)("inlineCode",{parentName:"p"},"[]int,[]i64"),"                        |\n| String       | ",(0,i.kt)("inlineCode",{parentName:"p"},"[]string"),"                           |\n| Rune         | ",(0,i.kt)("inlineCode",{parentName:"p"},"[]rune"),"                             |\n| Boolean      | ",(0,i.kt)("inlineCode",{parentName:"p"},"[]bool"),"                             |\n| Array        | ",(0,i.kt)("inlineCode",{parentName:"p"},"[][]int"),"                            |\n| Struct       | ",(0,i.kt)("inlineCode",{parentName:"p"},"[]MyStructName"),"                     |\n| Channel      | ",(0,i.kt)("inlineCode",{parentName:"p"},"[]chan f64"),"                         |\n| Function     | ",(0,i.kt)("inlineCode",{parentName:"p"},"[]MyFunctionType")," ",(0,i.kt)("inlineCode",{parentName:"p"},"[]fn (int) bool")," |\n| Interface    | ",(0,i.kt)("inlineCode",{parentName:"p"},"[]MyInterfaceName"),"                  |\n| Sum Type     | ",(0,i.kt)("inlineCode",{parentName:"p"},"[]MySumTypeName"),"                    |\n| Generic Type | ",(0,i.kt)("inlineCode",{parentName:"p"},"[]T"),"                                |\n| Map          | ",(0,i.kt)("inlineCode",{parentName:"p"},"[]map[string]f64"),"                   |\n| Enum         | ",(0,i.kt)("inlineCode",{parentName:"p"},"[]MyEnumType"),"                       |\n| Alias        | ",(0,i.kt)("inlineCode",{parentName:"p"},"[]MyAliasTypeName"),"                  |\n| Thread       | ",(0,i.kt)("inlineCode",{parentName:"p"},"[]thread int"),"                       |\n| Reference    | ",(0,i.kt)("inlineCode",{parentName:"p"},"[]&f64"),"                             |\n| Shared       | ",(0,i.kt)("inlineCode",{parentName:"p"},"[]shared MyStructType"),"              |"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example Code:")),(0,i.kt)("p",null,"This example uses ",(0,i.kt)("a",{parentName:"p",href:"#structs"},"Structs")," and ",(0,i.kt)("a",{parentName:"p",href:"#sum-types"},"Sum Types")," to create an array\nwhich can handle different types (e.g. Points, Lines) of data elements."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"struct Point {\n    x int\n    y int\n}\n\nstruct Line {\n    p1 Point\n    p2 Point\n}\n\ntype ObjectSumType = Line | Point\n\nmut object_list := []ObjectSumType{}\nobject_list << Point{1, 1}\nobject_list << Line{\n    p1: Point{3, 3}\n    p2: Point{4, 4}\n}\ndump(object_list)\n/*\nobject_list: [ObjectSumType(Point{\n    x: 1\n    y: 1\n}), ObjectSumType(Line{\n    p1: Point{\n        x: 3\n        y: 3\n    }\n    p2: Point{\n        x: 4\n        y: 4\n    }\n})]\n*/\n")),(0,i.kt)("h4",{id:"multidimensional-arrays"},"Multidimensional Arrays"),(0,i.kt)("p",null,"Arrays can have more than one dimension."),(0,i.kt)("p",null,"2d array example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"mut a := [][]int{len: 2, init: []int{len: 3}}\na[0][1] = 2\nprintln(a) // [[0, 2, 0], [0, 0, 0]]\n")),(0,i.kt)("p",null,"3d array example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"mut a := [][][]int{len: 2, init: [][]int{len: 3, init: []int{len: 2}}}\na[0][1][1] = 2\nprintln(a) // [[[0, 0], [0, 2], [0, 0]], [[0, 0], [0, 0], [0, 0]]]\n")),(0,i.kt)("h4",{id:"array-methods"},"Array methods"),(0,i.kt)("p",null,"All arrays can be easily printed with ",(0,i.kt)("inlineCode",{parentName:"p"},"println(arr)")," and converted to a string\nwith ",(0,i.kt)("inlineCode",{parentName:"p"},"s := arr.str()"),"."),(0,i.kt)("p",null,"Copying the data from the array is done with ",(0,i.kt)("inlineCode",{parentName:"p"},".clone()"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"nums := [1, 2, 3]\nnums_copy := nums.clone()\n")),(0,i.kt)("p",null,"Arrays can be efficiently filtered and mapped with the ",(0,i.kt)("inlineCode",{parentName:"p"},".filter()")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},".map()")," methods:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"nums := [1, 2, 3, 4, 5, 6]\neven := nums.filter(it % 2 == 0)\nprintln(even) // [2, 4, 6]\n// filter can accept anonymous functions\neven_fn := nums.filter(fn (x int) bool {\n    return x % 2 == 0\n})\nprintln(even_fn)\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"words := ['hello', 'world']\nupper := words.map(it.to_upper())\nprintln(upper) // ['HELLO', 'WORLD']\n// map can also accept anonymous functions\nupper_fn := words.map(fn (w string) string {\n    return w.to_upper()\n})\nprintln(upper_fn) // ['HELLO', 'WORLD']\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"it")," is a builtin variable which refers to the element currently being\nprocessed in filter/map methods."),(0,i.kt)("p",null,"Additionally, ",(0,i.kt)("inlineCode",{parentName:"p"},".any()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},".all()")," can be used to conveniently test\nfor elements that satisfy a condition."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"nums := [1, 2, 3]\nprintln(nums.any(it == 2)) // true\nprintln(nums.all(it >= 2)) // false\n")),(0,i.kt)("p",null,"There are further built-in methods for arrays:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"a.repeat(n)")," concatenates the array elements ",(0,i.kt)("inlineCode",{parentName:"li"},"n")," times"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"a.insert(i, val)")," inserts a new element ",(0,i.kt)("inlineCode",{parentName:"li"},"val")," at index ",(0,i.kt)("inlineCode",{parentName:"li"},"i")," and\nshifts all following elements to the right"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"a.insert(i, [3, 4, 5])")," inserts several elements"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"a.prepend(val)")," inserts a value at the beginning, equivalent to ",(0,i.kt)("inlineCode",{parentName:"li"},"a.insert(0, val)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"a.prepend(arr)")," inserts elements of array ",(0,i.kt)("inlineCode",{parentName:"li"},"arr")," at the beginning"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"a.trim(new_len)")," truncates the length (if ",(0,i.kt)("inlineCode",{parentName:"li"},"new_length < a.len"),", otherwise does nothing)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"a.clear()")," empties the array without changing ",(0,i.kt)("inlineCode",{parentName:"li"},"cap")," (equivalent to ",(0,i.kt)("inlineCode",{parentName:"li"},"a.trim(0)"),")"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"a.delete_many(start, size)")," removes ",(0,i.kt)("inlineCode",{parentName:"li"},"size")," consecutive elements from index ",(0,i.kt)("inlineCode",{parentName:"li"},"start"),"\u2013"," triggers reallocation"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"a.delete(index)")," equivalent to ",(0,i.kt)("inlineCode",{parentName:"li"},"a.delete_many(index, 1)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"a.delete_last()")," removes the last element"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"a.first()")," equivalent to ",(0,i.kt)("inlineCode",{parentName:"li"},"a[0]")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"a.last()")," equivalent to ",(0,i.kt)("inlineCode",{parentName:"li"},"a[a.len - 1]")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"a.pop()")," removes the last element and returns it"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"a.reverse()")," makes a new array with the elements of ",(0,i.kt)("inlineCode",{parentName:"li"},"a")," in reverse order"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"a.reverse_in_place()")," reverses the order of elements in ",(0,i.kt)("inlineCode",{parentName:"li"},"a")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"a.join(joiner)")," concatenates an array of strings into one string\nusing ",(0,i.kt)("inlineCode",{parentName:"li"},"joiner")," string as a separator")),(0,i.kt)("p",null,"See also ",(0,i.kt)("a",{parentName:"p",href:"https://modules.vlang.io/arrays.html"},"vlib/arrays"),"."),(0,i.kt)("h5",{id:"sorting-arrays"},"Sorting Arrays"),(0,i.kt)("p",null,"Sorting arrays of all kinds is very simple and intuitive. Special variables ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"b"),"\nare used when providing a custom sorting condition."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"mut numbers := [1, 3, 2]\nnumbers.sort() // 1, 2, 3\nnumbers.sort(a > b) // 3, 2, 1\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"struct User {\n    age  int\n    name string\n}\n\nmut users := [User{21, 'Bob'}, User{20, 'Zarkon'}, User{25, 'Alice'}]\nusers.sort(a.age < b.age) // sort by User.age int field\nusers.sort(a.name > b.name) // reverse sort by User.name string field\n")),(0,i.kt)("p",null,"V also supports custom sorting, through the ",(0,i.kt)("inlineCode",{parentName:"p"},"sort_with_compare")," array method.\nWhich expects a comparing function which will define the sort order.\nUseful for sorting on multiple fields at the same time by custom sorting rules.\nThe code below sorts the array ascending on ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," and descending ",(0,i.kt)("inlineCode",{parentName:"p"},"age"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"struct User {\n    age  int\n    name string\n}\n\nmut users := [User{21, 'Bob'}, User{65, 'Bob'}, User{25, 'Alice'}]\n\ncustom_sort_fn := fn (a &User, b &User) int {\n    // return -1 when a comes before b\n    // return 0, when both are in same order\n    // return 1 when b comes before a\n    if a.name == b.name {\n        if a.age < b.age {\n            return 1\n        }\n        if a.age > b.age {\n            return -1\n        }\n        return 0\n    }\n    if a.name < b.name {\n        return -1\n    } else if a.name > b.name {\n        return 1\n    }\n    return 0\n}\nusers.sort_with_compare(custom_sort_fn)\n")),(0,i.kt)("h4",{id:"array-slices"},"Array Slices"),(0,i.kt)("p",null,"A slice is a part of a parent array. Initially it refers to the elements\nbetween two indices separated by a ",(0,i.kt)("inlineCode",{parentName:"p"},"..")," operator. The right-side index must\nbe greater than or equal to the left side index."),(0,i.kt)("p",null,"If a right-side index is absent, it is assumed to be the array length. If a\nleft-side index is absent, it is assumed to be 0."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"nums := [0, 10, 20, 30, 40]\nprintln(nums[1..4]) // [10, 20, 30]\nprintln(nums[..4]) // [0, 10, 20, 30]\nprintln(nums[1..]) // [10, 20, 30, 40]\n")),(0,i.kt)("p",null,"In V slices are arrays themselves (they are not distinct types). As a result\nall array operations may be performed on them. E.g. they can be pushed onto an\narray of the same type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"array_1 := [3, 5, 4, 7, 6]\nmut array_2 := [0, 1]\narray_2 << array_1[..3]\nprintln(array_2) // `[0, 1, 3, 5, 4]`\n")),(0,i.kt)("p",null,"A slice is always created with the smallest possible capacity ",(0,i.kt)("inlineCode",{parentName:"p"},"cap == len")," (see\n",(0,i.kt)("a",{parentName:"p",href:"#array-initialization"},(0,i.kt)("inlineCode",{parentName:"a"},"cap")," above"),") no matter what the capacity or length\nof the parent array is. As a result it is immediately reallocated and copied to another\nmemory location when the size increases thus becoming independent from the\nparent array (",(0,i.kt)("em",{parentName:"p"},"copy on grow"),"). In particular pushing elements to a slice\ndoes not alter the parent:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"mut a := [0, 1, 2, 3, 4, 5]\nmut b := a[2..4]\nb[0] = 7 // `b[0]` is referring to `a[2]`\nprintln(a) // `[0, 1, 7, 3, 4, 5]`\nb << 9\n// `b` has been reallocated and is now independent from `a`\nprintln(a) // `[0, 1, 7, 3, 4, 5]` - no change\nprintln(b) // `[7, 3, 9]`\n")),(0,i.kt)("p",null,"Appending to the parent array may or may not make it independent from its child slices.\nThe behaviour depends on the parent's capacity and is predictable:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"mut a := []int{len: 5, cap: 6, init: 2}\nmut b := a[1..4]\na << 3\n// no reallocation - fits in `cap`\nb[2] = 13 // `a[3]` is modified\na << 4\n// a has been reallocated and is now independent from `b` (`cap` was exceeded)\nb[1] = 3 // no change in `a`\nprintln(a) // `[2, 2, 2, 13, 2, 3, 4]`\nprintln(b) // `[2, 3, 13]`\n")),(0,i.kt)("p",null,"You can call .clone() on the slice, if you do want to have an independent copy right away:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"mut a := [0, 1, 2, 3, 4, 5]\nmut b := a[2..4].clone()\nb[0] = 7 // NB: `b[0]` is NOT referring to `a[2]`, as it would have been, without the .clone()\nprintln(a) // [0, 1, 2, 3, 4, 5]\nprintln(b) // [7, 3]\n")),(0,i.kt)("h5",{id:"slices-with-negative-indexes"},"Slices with negative indexes"),(0,i.kt)("p",null,"V supports array and string slices with negative indexes.\nNegative indexing starts from the end of the array towards the start,\nfor example ",(0,i.kt)("inlineCode",{parentName:"p"},"-3")," is equal to ",(0,i.kt)("inlineCode",{parentName:"p"},"array.len - 3"),".\nNegative slices have a different syntax from normal slices, i.e. you need\nto add a ",(0,i.kt)("inlineCode",{parentName:"p"},"gate")," between the array name and the square bracket: ",(0,i.kt)("inlineCode",{parentName:"p"},"a#[..-3]"),".\nThe ",(0,i.kt)("inlineCode",{parentName:"p"},"gate"),' specifies that this is a different type of slice and remember that\nthe result is "locked" inside the array.\nThe returned slice is always a valid array, though it may be empty:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"a := [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nprintln(a#[-3..]) // [7, 8, 9]\nprintln(a#[-20..]) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nprintln(a#[-20..-8]) // [0, 1]\nprintln(a#[..-3]) // [0, 1, 2, 3, 4, 5, 6]\n\n// empty arrays\nprintln(a#[-20..-10]) // []\nprintln(a#[20..10]) // []\nprintln(a#[20..30]) // []\n")),(0,i.kt)("h4",{id:"array-method-chaining"},"Array method chaining"),(0,i.kt)("p",null,"You can chain the calls of array methods like ",(0,i.kt)("inlineCode",{parentName:"p"},".filter()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},".map()")," and use\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"it")," built-in variable to achieve a classic ",(0,i.kt)("inlineCode",{parentName:"p"},"map/filter")," functional paradigm:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"// using filter, map and negatives array slices\nfiles := ['pippo.jpg', '01.bmp', '_v.txt', 'img_02.jpg', 'img_01.JPG']\nfiltered := files.filter(it#[-4..].to_lower() == '.jpg').map(it.to_upper())\n// ['PIPPO.JPG', 'IMG_02.JPG', 'IMG_01.JPG']\n")),(0,i.kt)("h3",{id:"fixed-size-arrays"},"Fixed size arrays"),(0,i.kt)("p",null,"V also supports arrays with fixed size. Unlike ordinary arrays, their\nlength is constant. You cannot append elements to them, nor shrink them.\nYou can only modify their elements in place."),(0,i.kt)("p",null,"However, access to the elements of fixed size arrays is more efficient,\nthey need less memory than ordinary arrays, and unlike ordinary arrays,\ntheir data is on the stack, so you may want to use them as buffers if you\ndo not want additional heap allocations."),(0,i.kt)("p",null,"Most methods are defined to work on ordinary arrays, not on fixed size arrays.\nYou can convert a fixed size array to an ordinary array with slicing:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"mut fnums := [3]int{} // fnums is a fixed size array with 3 elements.\nfnums[0] = 1\nfnums[1] = 10\nfnums[2] = 100\nprintln(fnums) // => [1, 10, 100]\nprintln(typeof(fnums).name) // => [3]int\n\nfnums2 := [1, 10, 100]! // short init syntax that does the same (the syntax will probably change)\n\nanums := fnums[..] // same as `anums := fnums[0..fnums.len]`\nprintln(anums) // => [1, 10, 100]\nprintln(typeof(anums).name) // => []int\n")),(0,i.kt)("p",null,"Note that slicing will cause the data of the fixed size array to be copied to\nthe newly created ordinary array."),(0,i.kt)("h3",{id:"maps"},"Maps"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"mut m := map[string]int{} // a map with `string` keys and `int` values\nm['one'] = 1\nm['two'] = 2\nprintln(m['one']) // \"1\"\nprintln(m['bad_key']) // \"0\"\nprintln('bad_key' in m) // Use `in` to detect whether such key exists\nprintln(m.keys()) // ['one', 'two']\nm.delete('two')\n")),(0,i.kt)("p",null,"Maps can have keys of type string, rune, integer, float or voidptr."),(0,i.kt)("p",null,"The whole map can be initialized using this short syntax:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"numbers := {\n    'one': 1\n    'two': 2\n}\nprintln(numbers)\n")),(0,i.kt)("p",null,"If a key is not found, a zero value is returned by default:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"sm := {\n    'abc': 'xyz'\n}\nval := sm['bad_key']\nprintln(val) // ''\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"intm := {\n    1: 1234\n    2: 5678\n}\ns := intm[3]\nprintln(s) // 0\n")),(0,i.kt)("p",null,"It's also possible to use an ",(0,i.kt)("inlineCode",{parentName:"p"},"or {}")," block to handle missing keys:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"mm := map[string]int{}\nval := mm['bad_key'] or { panic('key not found') }\n")),(0,i.kt)("p",null,"You can also check, if a key is present, and get its value, if it was present, in one go:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"m := {\n    'abc': 'def'\n}\nif v := m['abc'] {\n    println('the map value for that key is: $v')\n}\n")),(0,i.kt)("p",null,"The same optional check applies to arrays:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"arr := [1, 2, 3]\nlarge_index := 999\nval := arr[large_index] or { panic('out of bounds') }\nprintln(val)\n// you can also do this, if you want to *propagate* the access error:\nval2 := arr[333]?\nprintln(val2)\n")),(0,i.kt)("p",null,"Maps are ordered by insertion, like dictionaries in Python. The order is a\nguaranteed language feature. This may change in the future."),(0,i.kt)("h2",{id:"module-imports"},"Module imports"),(0,i.kt)("p",null,"For information about creating a module, see ",(0,i.kt)("a",{parentName:"p",href:"#modules"},"Modules"),"."),(0,i.kt)("p",null,"Modules can be imported using the ",(0,i.kt)("inlineCode",{parentName:"p"},"import")," keyword:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"import os\n\nfn main() {\n    // read text from stdin\n    name := os.input('Enter your name: ')\n    println('Hello, $name!')\n}\n")),(0,i.kt)("p",null,"This program can use any public definitions from the ",(0,i.kt)("inlineCode",{parentName:"p"},"os")," module, such\nas the ",(0,i.kt)("inlineCode",{parentName:"p"},"input")," function. See the ",(0,i.kt)("a",{parentName:"p",href:"https://modules.vlang.io/"},"standard library"),"\ndocumentation for a list of common modules and their public symbols."),(0,i.kt)("p",null,"By default, you have to specify the module prefix every time you call an external function.\nThis may seem verbose at first, but it makes code much more readable\nand easier to understand - it's always clear which function from\nwhich module is being called. This is especially useful in large code bases."),(0,i.kt)("p",null,"Cyclic module imports are not allowed, like in Go."),(0,i.kt)("h3",{id:"selective-imports"},"Selective imports"),(0,i.kt)("p",null,"You can also import specific functions and types from modules directly:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"import os { input }\n\nfn main() {\n    // read text from stdin\n    name := input('Enter your name: ')\n    println('Hello, $name!')\n}\n")),(0,i.kt)("p",null,"Note: This will import the module as well. Also, this is not allowed for\nconstants - they must always be prefixed."),(0,i.kt)("p",null,"You can import several specific symbols at once:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"import os { input, user_os }\n\nname := input('Enter your name: ')\nprintln('Name: $name')\nos := user_os()\nprintln('Your OS is ${os}.')\n")),(0,i.kt)("h3",{id:"module-import-aliasing"},"Module import aliasing"),(0,i.kt)("p",null,"Any imported module name can be aliased using the ",(0,i.kt)("inlineCode",{parentName:"p"},"as")," keyword:"),(0,i.kt)("p",null,"NOTE: this example will not compile unless you have created ",(0,i.kt)("inlineCode",{parentName:"p"},"mymod/sha256.v")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"failcompile",failcompile:!0},"import crypto.sha256\nimport mymod.sha256 as mysha256\n\nfn main() {\n    v_hash := sha256.sum('hi'.bytes()).hex()\n    my_hash := mysha256.sum('hi'.bytes()).hex()\n    assert my_hash == v_hash\n}\n")),(0,i.kt)("p",null,"You cannot alias an imported function or type.\nHowever, you ",(0,i.kt)("em",{parentName:"p"},"can")," redeclare a type."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"import time\nimport math\n\ntype MyTime = time.Time\n\nfn (mut t MyTime) century() int {\n    return int(1.0 + math.trunc(f64(t.year) * 0.009999794661191))\n}\n\nfn main() {\n    mut my_time := MyTime{\n        year: 2020\n        month: 12\n        day: 25\n    }\n    println(time.new_time(my_time).utc_string())\n    println('Century: $my_time.century()')\n}\n")),(0,i.kt)("h2",{id:"statements--expressions"},"Statements & expressions"),(0,i.kt)("h3",{id:"if"},"If"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"a := 10\nb := 20\nif a < b {\n    println('$a < $b')\n} else if a > b {\n    println('$a > $b')\n} else {\n    println('$a == $b')\n}\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"if")," statements are pretty straightforward and similar to most other languages.\nUnlike other C-like languages,\nthere are no parentheses surrounding the condition and the braces are always required."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"if")," can be used as an expression:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"num := 777\ns := if num % 2 == 0 { 'even' } else { 'odd' }\nprintln(s)\n// \"odd\"\n")),(0,i.kt)("h4",{id:"type-checks-and-casts"},"Type checks and casts"),(0,i.kt)("p",null,"You can check the current type of a sum type using ",(0,i.kt)("inlineCode",{parentName:"p"},"is")," and its negated form ",(0,i.kt)("inlineCode",{parentName:"p"},"!is"),"."),(0,i.kt)("p",null,"You can do it either in an ",(0,i.kt)("inlineCode",{parentName:"p"},"if"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"cgen",cgen:!0},"struct Abc {\n    val string\n}\n\nstruct Xyz {\n    foo string\n}\n\ntype Alphabet = Abc | Xyz\n\nx := Alphabet(Abc{'test'}) // sum type\nif x is Abc {\n    // x is automatically casted to Abc and can be used here\n    println(x)\n}\nif x !is Abc {\n    println('Not Abc')\n}\n")),(0,i.kt)("p",null,"or using ",(0,i.kt)("inlineCode",{parentName:"p"},"match"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"oksyntax",oksyntax:!0},"match x {\n    Abc {\n        // x is automatically casted to Abc and can be used here\n        println(x)\n    }\n    Xyz {\n        // x is automatically casted to Xyz and can be used here\n        println(x)\n    }\n}\n")),(0,i.kt)("p",null,"This works also with struct fields:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"struct MyStruct {\n    x int\n}\n\nstruct MyStruct2 {\n    y string\n}\n\ntype MySumType = MyStruct | MyStruct2\n\nstruct Abc {\n    bar MySumType\n}\n\nx := Abc{\n    bar: MyStruct{123} // MyStruct will be converted to MySumType type automatically\n}\nif x.bar is MyStruct {\n    // x.bar is automatically casted\n    println(x.bar)\n} else if x.bar is MyStruct2 {\n    new_var := x.bar as MyStruct2\n    // ... or you can use `as` to create a type cast an alias manually:\n    println(new_var)\n}\nmatch x.bar {\n    MyStruct {\n        // x.bar is automatically casted\n        println(x.bar)\n    }\n    else {}\n}\n")),(0,i.kt)("p",null,"Mutable variables can change, and doing a cast would be unsafe.\nHowever, sometimes it's useful to type cast despite mutability.\nIn such cases the developer must mark the expression with the ",(0,i.kt)("inlineCode",{parentName:"p"},"mut")," keyword\nto tell the compiler that they know what they're doing."),(0,i.kt)("p",null,"It works like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"oksyntax",oksyntax:!0},"mut x := MySumType(MyStruct{123})\nif mut x is MyStruct {\n    // x is casted to MyStruct even if it's mutable\n    // without the mut keyword that wouldn't work\n    println(x)\n}\n// same with match\nmatch mut x {\n    MyStruct {\n        // x is casted to MyStruct even if it's mutable\n        // without the mut keyword that wouldn't work\n        println(x)\n    }\n}\n")),(0,i.kt)("h3",{id:"in-operator"},"In operator"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"in")," allows to check whether an array or a map contains an element.\nTo do the opposite, use ",(0,i.kt)("inlineCode",{parentName:"p"},"!in"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"nums := [1, 2, 3]\nprintln(1 in nums) // true\nprintln(4 !in nums) // true\nm := {\n    'one': 1\n    'two': 2\n}\nprintln('one' in m) // true\nprintln('three' !in m) // true\n")),(0,i.kt)("p",null,"It's also useful for writing boolean expressions that are clearer and more compact:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"enum Token {\n    plus\n    minus\n    div\n    mult\n}\n\nstruct Parser {\n    token Token\n}\n\nparser := Parser{}\nif parser.token == .plus || parser.token == .minus || parser.token == .div || parser.token == .mult {\n    // ...\n}\nif parser.token in [.plus, .minus, .div, .mult] {\n    // ...\n}\n")),(0,i.kt)("p",null,"V optimizes such expressions,\nso both ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," statements above produce the same machine code and no arrays are created."),(0,i.kt)("h3",{id:"for-loop"},"For loop"),(0,i.kt)("p",null,"V has only one looping keyword: ",(0,i.kt)("inlineCode",{parentName:"p"},"for"),", with several forms."),(0,i.kt)("h4",{id:"forin"},(0,i.kt)("inlineCode",{parentName:"h4"},"for"),"/",(0,i.kt)("inlineCode",{parentName:"h4"},"in")),(0,i.kt)("p",null,"This is the most common form. You can use it with an array, map or\nnumeric range."),(0,i.kt)("h5",{id:"array-for"},"Array ",(0,i.kt)("inlineCode",{parentName:"h5"},"for")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"numbers := [1, 2, 3, 4, 5]\nfor num in numbers {\n    println(num)\n}\nnames := ['Sam', 'Peter']\nfor i, name in names {\n    println('$i) $name')\n    // Output: 0) Sam\n    //         1) Peter\n}\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"for value in arr")," form is used for going through elements of an array.\nIf an index is required, an alternative form ",(0,i.kt)("inlineCode",{parentName:"p"},"for index, value in arr")," can be used."),(0,i.kt)("p",null,"Note, that the value is read-only.\nIf you need to modify the array while looping, you need to declare the element as mutable:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"mut numbers := [0, 1, 2]\nfor mut num in numbers {\n    num++\n}\nprintln(numbers) // [1, 2, 3]\n")),(0,i.kt)("p",null,"When an identifier is just a single underscore, it is ignored."),(0,i.kt)("h5",{id:"custom-iterators"},"Custom iterators"),(0,i.kt)("p",null,"Types that implement a ",(0,i.kt)("inlineCode",{parentName:"p"},"next")," method returning an ",(0,i.kt)("inlineCode",{parentName:"p"},"Option")," can be iterated\nwith a ",(0,i.kt)("inlineCode",{parentName:"p"},"for")," loop."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"struct SquareIterator {\n    arr []int\nmut:\n    idx int\n}\n\nfn (mut iter SquareIterator) next() ?int {\n    if iter.idx >= iter.arr.len {\n        return error('')\n    }\n    defer {\n        iter.idx++\n    }\n    return iter.arr[iter.idx] * iter.arr[iter.idx]\n}\n\nnums := [1, 2, 3, 4, 5]\niter := SquareIterator{\n    arr: nums\n}\nfor squared in iter {\n    println(squared)\n}\n")),(0,i.kt)("p",null,"The code above prints:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"1\n4\n9\n16\n25\n")),(0,i.kt)("h5",{id:"map-for"},"Map ",(0,i.kt)("inlineCode",{parentName:"h5"},"for")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"m := {\n    'one': 1\n    'two': 2\n}\nfor key, value in m {\n    println('$key -> $value')\n    // Output: one -> 1\n    //         two -> 2\n}\n")),(0,i.kt)("p",null,"Either key or value can be ignored by using a single underscore as the identifier."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"m := {\n    'one': 1\n    'two': 2\n}\n// iterate over keys\nfor key, _ in m {\n    println(key)\n    // Output: one\n    //         two\n}\n// iterate over values\nfor _, value in m {\n    println(value)\n    // Output: 1\n    //         2\n}\n")),(0,i.kt)("h5",{id:"range-for"},"Range ",(0,i.kt)("inlineCode",{parentName:"h5"},"for")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"// Prints '01234'\nfor i in 0 .. 5 {\n    print(i)\n}\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"low..high")," means an ",(0,i.kt)("em",{parentName:"p"},"exclusive")," range, which represents all values\nfrom ",(0,i.kt)("inlineCode",{parentName:"p"},"low")," up to ",(0,i.kt)("em",{parentName:"p"},"but not including")," ",(0,i.kt)("inlineCode",{parentName:"p"},"high"),"."),(0,i.kt)("h4",{id:"condition-for"},"Condition ",(0,i.kt)("inlineCode",{parentName:"h4"},"for")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},'mut sum := 0\nmut i := 0\nfor i <= 100 {\n    sum += i\n    i++\n}\nprintln(sum) // "5050"\n')),(0,i.kt)("p",null,"This form of the loop is similar to ",(0,i.kt)("inlineCode",{parentName:"p"},"while")," loops in other languages.\nThe loop will stop iterating once the boolean condition evaluates to false.\nAgain, there are no parentheses surrounding the condition, and the braces are always required."),(0,i.kt)("h4",{id:"bare-for"},"Bare ",(0,i.kt)("inlineCode",{parentName:"h4"},"for")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},'mut num := 0\nfor {\n    num += 2\n    if num >= 10 {\n        break\n    }\n}\nprintln(num) // "10"\n')),(0,i.kt)("p",null,"The condition can be omitted, resulting in an infinite loop."),(0,i.kt)("h4",{id:"c-for"},"C ",(0,i.kt)("inlineCode",{parentName:"h4"},"for")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"for i := 0; i < 10; i += 2 {\n    // Don't print 6\n    if i == 6 {\n        continue\n    }\n    println(i)\n}\n")),(0,i.kt)("p",null,"Finally, there's the traditional C style ",(0,i.kt)("inlineCode",{parentName:"p"},"for")," loop. It's safer than the ",(0,i.kt)("inlineCode",{parentName:"p"},"while")," form\nbecause with the latter it's easy to forget to update the counter and get\nstuck in an infinite loop."),(0,i.kt)("p",null,"Here ",(0,i.kt)("inlineCode",{parentName:"p"},"i")," doesn't need to be declared with ",(0,i.kt)("inlineCode",{parentName:"p"},"mut")," since it's always going to be mutable by definition."),(0,i.kt)("h4",{id:"labelled-break--continue"},"Labelled break & continue"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"break")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"continue")," control the innermost ",(0,i.kt)("inlineCode",{parentName:"p"},"for")," loop by default.\nYou can also use ",(0,i.kt)("inlineCode",{parentName:"p"},"break")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"continue")," followed by a label name to refer to an outer ",(0,i.kt)("inlineCode",{parentName:"p"},"for"),"\nloop:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"outer: for i := 4; true; i++ {\n    println(i)\n    for {\n        if i < 7 {\n            continue outer\n        } else {\n            break outer\n        }\n    }\n}\n")),(0,i.kt)("p",null,"The label must immediately precede the outer loop.\nThe above code prints:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"4\n5\n6\n7\n")),(0,i.kt)("h3",{id:"match"},"Match"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"os := 'windows'\nprint('V is running on ')\nmatch os {\n    'darwin' { println('macOS.') }\n    'linux' { println('Linux.') }\n    else { println(os) }\n}\n")),(0,i.kt)("p",null,"A match statement is a shorter way to write a sequence of ",(0,i.kt)("inlineCode",{parentName:"p"},"if - else")," statements.\nWhen a matching branch is found, the following statement block will be run.\nThe else branch will be run when no other branches match."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"number := 2\ns := match number {\n    1 { 'one' }\n    2 { 'two' }\n    else { 'many' }\n}\n")),(0,i.kt)("p",null,"A match statement can also to be used as an ",(0,i.kt)("inlineCode",{parentName:"p"},"if - else if - else")," alternative:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"match true {\n    2 > 4 { println('if') }\n    3 == 4 { println('else if') }\n    2 == 2 { println('else if2') }\n    else { println('else') }\n}\n// 'else if2' should be printed\n")),(0,i.kt)("p",null,"or as an ",(0,i.kt)("inlineCode",{parentName:"p"},"unless")," alternative: ",(0,i.kt)("a",{parentName:"p",href:"https://www.tutorialspoint.com/ruby/ruby_if_else.htm"},"unless Ruby")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"match false {\n    2 > 4 { println('if') }\n    3 == 4 { println('else if') }\n    2 == 2 { println('else if2') }\n    else { println('else') }\n}\n// 'if' should be printed\n")),(0,i.kt)("p",null,"A match expression returns the value of the final expression from the matching branch."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"enum Color {\n    red\n    blue\n    green\n}\n\nfn is_red_or_blue(c Color) bool {\n    return match c {\n        .red, .blue { true } // comma can be used to test multiple values\n        .green { false }\n    }\n}\n")),(0,i.kt)("p",null,"A match statement can also be used to branch on the variants of an ",(0,i.kt)("inlineCode",{parentName:"p"},"enum"),"\nby using the shorthand ",(0,i.kt)("inlineCode",{parentName:"p"},".variant_here")," syntax. An ",(0,i.kt)("inlineCode",{parentName:"p"},"else")," branch is not allowed\nwhen all the branches are exhaustive."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"c := `v`\ntyp := match c {\n    `0`...`9` { 'digit' }\n    `A`...`Z` { 'uppercase' }\n    `a`...`z` { 'lowercase' }\n    else { 'other' }\n}\nprintln(typ)\n// 'lowercase'\n")),(0,i.kt)("p",null,"You can also use ranges as ",(0,i.kt)("inlineCode",{parentName:"p"},"match")," patterns. If the value falls within the range\nof a branch, that branch will be executed."),(0,i.kt)("p",null,"Note that the ranges use ",(0,i.kt)("inlineCode",{parentName:"p"},"...")," (three dots) rather than ",(0,i.kt)("inlineCode",{parentName:"p"},"..")," (two dots). This is\nbecause the range is ",(0,i.kt)("em",{parentName:"p"},"inclusive")," of the last element, rather than exclusive\n(as ",(0,i.kt)("inlineCode",{parentName:"p"},"..")," ranges are). Using ",(0,i.kt)("inlineCode",{parentName:"p"},"..")," in a match branch will throw an error."),(0,i.kt)("p",null,"Note: ",(0,i.kt)("inlineCode",{parentName:"p"},"match")," as an expression is not usable in ",(0,i.kt)("inlineCode",{parentName:"p"},"for")," loop and ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," statements."),(0,i.kt)("h3",{id:"defer"},"Defer"),(0,i.kt)("p",null,"A defer statement defers the execution of a block of statements\nuntil the surrounding function returns."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"import os\n\nfn read_log() {\n    mut ok := false\n    mut f := os.open('log.txt') or { panic(err) }\n    defer {\n        f.close()\n    }\n    // ...\n    if !ok {\n        // defer statement will be called here, the file will be closed\n        return\n    }\n    // ...\n    // defer statement will be called here, the file will be closed\n}\n")),(0,i.kt)("p",null,"If the function returns a value the ",(0,i.kt)("inlineCode",{parentName:"p"},"defer")," block is executed ",(0,i.kt)("em",{parentName:"p"},"after")," the return\nexpression is evaluated:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"import os\n\nenum State {\n    normal\n    write_log\n    return_error\n}\n\n// write log file and return number of bytes written\nfn write_log(s State) ?int {\n    mut f := os.create('log.txt')?\n    defer {\n        f.close()\n    }\n    if s == .write_log {\n        // `f.close()` will be called after `f.write()` has been\n        // executed, but before `write_log()` finally returns the\n        // number of bytes written to `main()`\n        return f.writeln('This is a log file')\n    } else if s == .return_error {\n        // the file will be closed after the `error()` function\n        // has returned - so the error message will still report\n        // it as open\n        return error('nothing written; file open: $f.is_opened')\n    }\n    // the file will be closed here, too\n    return 0\n}\n\nfn main() {\n    n := write_log(.return_error) or {\n        println('Error: $err')\n        0\n    }\n    println('$n bytes written')\n}\n")),(0,i.kt)("h2",{id:"structs"},"Structs"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"struct Point {\n    x int\n    y int\n}\n\nmut p := Point{\n    x: 10\n    y: 20\n}\nprintln(p.x) // Struct fields are accessed using a dot\n// Alternative literal syntax for structs with 3 fields or fewer\np = Point{10, 20}\nassert p.x == 10\n")),(0,i.kt)("h3",{id:"heap-structs"},"Heap structs"),(0,i.kt)("p",null,"Structs are allocated on the stack. To allocate a struct on the heap\nand get a reference to it, use the ",(0,i.kt)("inlineCode",{parentName:"p"},"&")," prefix:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"struct Point {\n    x int\n    y int\n}\n\np := &Point{10, 10}\n// References have the same syntax for accessing fields\nprintln(p.x)\n")),(0,i.kt)("p",null,"The type of ",(0,i.kt)("inlineCode",{parentName:"p"},"p")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"&Point"),". It's a ",(0,i.kt)("a",{parentName:"p",href:"#references"},"reference")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"Point"),".\nReferences are similar to Go pointers and C++ references."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"struct Foo {\nmut:\n    x int\n}\n\nfa := Foo{1}\nmut a := fa\na.x = 2\nassert fa.x == 1\nassert a.x == 2\n\n// fb := Foo{ 1 }\n// mut b := &fb  // error: `fb` is immutable, cannot have a mutable reference to it\n// b.x = 2\n\nmut fc := Foo{1}\nmut c := &fc\nc.x = 2\nassert fc.x == 2\nassert c.x == 2\nprintln(fc) // Foo{ x: 2 }\nprintln(c) // &Foo{ x: 2 } // Note `&` prefixed.\n")),(0,i.kt)("p",null,"see also ",(0,i.kt)("a",{parentName:"p",href:"#stack-and-heap"},"Stack and Heap")),(0,i.kt)("h3",{id:"default-field-values"},"Default field values"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"struct Foo {\n    n   int    // n is 0 by default\n    s   string // s is '' by default\n    a   []int  // a is `[]int{}` by default\n    pos int = -1 // custom default value\n}\n")),(0,i.kt)("p",null,"All struct fields are zeroed by default during the creation of the struct.\nArray and map fields are allocated."),(0,i.kt)("p",null,"It's also possible to define custom default values."),(0,i.kt)("h3",{id:"required-fields"},"Required fields"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"struct Foo {\n    n int [required]\n}\n")),(0,i.kt)("p",null,"You can mark a struct field with the ",(0,i.kt)("inlineCode",{parentName:"p"},"[required]")," attribute, to tell V that\nthat field must be initialized when creating an instance of that struct."),(0,i.kt)("p",null,"This example will not compile, since the field ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," isn't explicitly initialized:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"failcompile",failcompile:!0},"_ = Foo{}\n")),(0,i.kt)("h3",{id:"short-struct-literal-syntax"},"Short struct literal syntax"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"struct Point {\n    x int\n    y int\n}\n\nmut p := Point{\n    x: 10\n    y: 20\n}\np = Point{\n    x: 30\n    y: 4\n}\nassert p.y == 4\n//\n// array: first element defines type of array\npoints := [Point{10, 20}, Point{20, 30}, Point{40, 50}]\nprintln(points) // [Point{x: 10, y: 20}, Point{x: 20, y: 30}, Point{x: 40,y: 50}]\n")),(0,i.kt)("p",null,"Omitting the struct name also works for returning a struct literal or passing one\nas a function argument."),(0,i.kt)("h4",{id:"trailing-struct-literal-arguments"},"Trailing struct literal arguments"),(0,i.kt)("p",null,"V doesn't have default function arguments or named arguments, for that trailing struct\nliteral syntax can be used instead:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"[params]\nstruct ButtonConfig {\n    text        string\n    is_disabled bool\n    width       int = 70\n    height      int = 20\n}\n\nstruct Button {\n    text   string\n    width  int\n    height int\n}\n\nfn new_button(c ButtonConfig) &Button {\n    return &Button{\n        width: c.width\n        height: c.height\n        text: c.text\n    }\n}\n\nbutton := new_button(text: 'Click me', width: 100)\n// the height is unset, so it's the default value\nassert button.height == 20\n")),(0,i.kt)("p",null,"As you can see, both the struct name and braces can be omitted, instead of:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"oksyntax nofmt",oksyntax:!0,nofmt:!0},"new_button(ButtonConfig{text:'Click me', width:100})\n")),(0,i.kt)("p",null,"This only works for functions that take a struct for the last argument."),(0,i.kt)("p",null,"NB: the ",(0,i.kt)("inlineCode",{parentName:"p"},"[params]")," tag is used to tell V, that the trailing struct parameter\ncan be omitted ",(0,i.kt)("em",{parentName:"p"},"entirely"),", so that you can write ",(0,i.kt)("inlineCode",{parentName:"p"},"button := new_button()"),".\nWithout it, you have to specify ",(0,i.kt)("em",{parentName:"p"},"at least")," one of the field names, even if it\nhas its default value, otherwise the compiler will produce this error message,\nwhen you call the function with no parameters:\n",(0,i.kt)("inlineCode",{parentName:"p"},"error: expected 1 arguments, but got 0"),"."),(0,i.kt)("h3",{id:"access-modifiers"},"Access modifiers"),(0,i.kt)("p",null,"Struct fields are private and immutable by default (making structs immutable as well).\nTheir access modifiers can be changed with\n",(0,i.kt)("inlineCode",{parentName:"p"},"pub")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"mut"),". In total, there are 5 possible options:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"struct Foo {\n    a int // private immutable (default)\nmut:\n    b int // private mutable\n    c int // (you can list multiple fields with the same access modifier)\npub:\n    d int // public immutable (readonly)\npub mut:\n    e int // public, but mutable only in parent module\n__global:\n    // (not recommended to use, that's why the 'global' keyword starts with __)\n    f int // public and mutable both inside and outside parent module\n}\n")),(0,i.kt)("p",null,"Private fields are available only inside the same ",(0,i.kt)("a",{parentName:"p",href:"#modules"},"module"),", any attempt\nto directly access them from another module will cause an error during compilation.\nPublic immutable fields are readonly everywhere."),(0,i.kt)("h3",{id:"anonymous-structs"},"Anonymous structs"),(0,i.kt)("p",null,"V supports anonymous structs: structs that don't have to be declared separately\nwith a struct name."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"struct Book {\n    author struct  {\n        name string\n        age  int\n    }\n\n    title string\n}\n\nbook := Book{\n    author: struct {\n        name: 'Samantha Black'\n        age: 24\n    }\n}\nassert book.author.name == 'Samantha Black'\nassert book.author.age == 24\n")),(0,i.kt)("h3",{id:"methods"},"Methods"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},'struct User {\n    age int\n}\n\nfn (u User) can_register() bool {\n    return u.age > 16\n}\n\nuser := User{\n    age: 10\n}\nprintln(user.can_register()) // "false"\nuser2 := User{\n    age: 20\n}\nprintln(user2.can_register()) // "true"\n')),(0,i.kt)("p",null,"V doesn't have classes, but you can define methods on types.\nA method is a function with a special receiver argument.\nThe receiver appears in its own argument list between the ",(0,i.kt)("inlineCode",{parentName:"p"},"fn")," keyword and the method name.\nMethods must be in the same module as the receiver type."),(0,i.kt)("p",null,"In this example, the ",(0,i.kt)("inlineCode",{parentName:"p"},"can_register")," method has a receiver of type ",(0,i.kt)("inlineCode",{parentName:"p"},"User")," named ",(0,i.kt)("inlineCode",{parentName:"p"},"u"),".\nThe convention is not to use receiver names like ",(0,i.kt)("inlineCode",{parentName:"p"},"self")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"this"),",\nbut a short, preferably one letter long, name."),(0,i.kt)("h3",{id:"embedded-structs"},"Embedded structs"),(0,i.kt)("p",null,"V support embedded structs ."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"struct Size {\nmut:\n    width  int\n    height int\n}\n\nfn (s &Size) area() int {\n    return s.width * s.height\n}\n\nstruct Button {\n    Size\n    title string\n}\n")),(0,i.kt)("p",null,"With embedding, the struct ",(0,i.kt)("inlineCode",{parentName:"p"},"Button")," will automatically have get all the fields and methods from\nthe struct ",(0,i.kt)("inlineCode",{parentName:"p"},"Size"),", which allows you to do:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"oksyntax",oksyntax:!0},"mut button := Button{\n    title: 'Click me'\n    height: 2\n}\n\nbutton.width = 3\nassert button.area() == 6\nassert button.Size.area() == 6\nprint(button)\n")),(0,i.kt)("p",null,"output :"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Button{\n    Size: Size{\n        width: 3\n        height: 2\n    }\n    title: 'Click me'\n}\n")),(0,i.kt)("p",null,"Unlike inheritance, you cannot type cast between structs and embedded structs\n(the embedding struct can also has its own fields, and it can also embed multiple structs)."),(0,i.kt)("p",null,"If you need to access embedded structs directly, use an explicit reference like ",(0,i.kt)("inlineCode",{parentName:"p"},"button.Size"),"."),(0,i.kt)("p",null,"Conceptually, embedded structs are similar to ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Mixin"},"mixin"),"s\nin OOP, ",(0,i.kt)("em",{parentName:"p"},"NOT")," base classes."),(0,i.kt)("p",null,"You can also initialize an embedded struct:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"oksyntax",oksyntax:!0},"mut button := Button{\n    Size: Size{\n        width: 3\n        height: 2\n    }\n}\n")),(0,i.kt)("p",null,"or assign values:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"oksyntax",oksyntax:!0},"button.Size = Size{\n    width: 4\n    height: 5\n}\n")),(0,i.kt)("p",null,"If multiple embedded structs have methods or fields with the same name, or if methods or fields\nwith the same name are defined in the struct, you can call methods or assign to variables in\nthe embedded struct like ",(0,i.kt)("inlineCode",{parentName:"p"},"button.Size.area()"),".\nWhen you do not specify the embedded struct name, the method of the outermost struct will be\ntargeted."),(0,i.kt)("h2",{id:"unions"},"Unions"),(0,i.kt)("p",null,"Just like structs, unions support embedding."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"struct Rgba32_Component {\n    r byte\n    g byte\n    b byte\n    a byte\n}\n\nunion Rgba32 {\n    Rgba32_Component\n    value u32\n}\n\nclr1 := Rgba32{\n    value: 0x008811FF\n}\n\nclr2 := Rgba32{\n    Rgba32_Component: Rgba32_Component{\n        a: 128\n    }\n}\n\nsz := sizeof(Rgba32)\nunsafe {\n    println('Size: ${sz}B,clr1.b: $clr1.b,clr2.b: $clr2.b')\n}\n")),(0,i.kt)("p",null,"Output: ",(0,i.kt)("inlineCode",{parentName:"p"},"Size: 4B, clr1.b: 136, clr2.b: 0")),(0,i.kt)("p",null,"Union member access must be performed in an ",(0,i.kt)("inlineCode",{parentName:"p"},"unsafe")," block."),(0,i.kt)("p",null,"Note that the embedded struct arguments are not necessarily stored in the order listed."),(0,i.kt)("h2",{id:"functions-2"},"Functions 2"),(0,i.kt)("h3",{id:"immutable-function-args-by-default"},"Immutable function args by default"),(0,i.kt)("p",null,"In V function arguments are immutable by default, and mutable args have to be\nmarked on call."),(0,i.kt)("p",null,"Since there are also no globals, that means that the return values of the functions,\nare a function of their arguments only, and their evaluation has no side effects\n(unless the function uses I/O)."),(0,i.kt)("p",null,"Function arguments are immutable by default, even when ",(0,i.kt)("a",{parentName:"p",href:"#references"},"references")," are passed."),(0,i.kt)("p",null,"Note that V is not a purely functional language however."),(0,i.kt)("p",null,"There is a compiler flag to enable global variables (",(0,i.kt)("inlineCode",{parentName:"p"},"-enable-globals"),"), but this is\nintended for low-level applications like kernels and drivers."),(0,i.kt)("h3",{id:"mutable-arguments"},"Mutable arguments"),(0,i.kt)("p",null,"It is possible to modify function arguments by declaring them with the keyword ",(0,i.kt)("inlineCode",{parentName:"p"},"mut"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},'struct User {\n    name string\nmut:\n    is_registered bool\n}\n\nfn (mut u User) register() {\n    u.is_registered = true\n}\n\nmut user := User{}\nprintln(user.is_registered) // "false"\nuser.register()\nprintln(user.is_registered) // "true"\n')),(0,i.kt)("p",null,"In this example, the receiver (which is just the first argument) is explicitly marked as mutable,\nso ",(0,i.kt)("inlineCode",{parentName:"p"},"register()")," can change the user object. The same works with non-receiver arguments:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},'fn multiply_by_2(mut arr []int) {\n    for i in 0 .. arr.len {\n        arr[i] *= 2\n    }\n}\n\nmut nums := [1, 2, 3]\nmultiply_by_2(mut nums)\nprintln(nums)\n// "[2, 4, 6]"\n')),(0,i.kt)("p",null,"Note, that you have to add ",(0,i.kt)("inlineCode",{parentName:"p"},"mut")," before ",(0,i.kt)("inlineCode",{parentName:"p"},"nums")," when calling this function. This makes\nit clear that the function being called will modify the value."),(0,i.kt)("p",null,"It is preferable to return values instead of modifying arguments,\ne.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"user = register(user)")," (or ",(0,i.kt)("inlineCode",{parentName:"p"},"user.register()"),") instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"register(mut user)"),".\nModifying arguments should only be done in performance-critical parts of your application\nto reduce allocations and copying."),(0,i.kt)("p",null,"For this reason V doesn't allow the modification of arguments with primitive types (e.g. integers).\nOnly more complex types such as arrays and maps may be modified."),(0,i.kt)("h4",{id:"struct-update-syntax"},"Struct update syntax"),(0,i.kt)("p",null,"V makes it easy to return a modified version of an object:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"struct User {\n    name          string\n    age           int\n    is_registered bool\n}\n\nfn register(u User) User {\n    return User{\n        ...u\n        is_registered: true\n    }\n}\n\nmut user := User{\n    name: 'abc'\n    age: 23\n}\nuser = register(user)\nprintln(user)\n")),(0,i.kt)("h3",{id:"variable-number-of-arguments"},"Variable number of arguments"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"fn sum(a ...int) int {\n    mut total := 0\n    for x in a {\n        total += x\n    }\n    return total\n}\n\nprintln(sum()) // 0\nprintln(sum(1)) // 1\nprintln(sum(2, 3)) // 5\n// using array decomposition\na := [2, 3, 4]\nprintln(sum(...a)) // <-- using prefix ... here. output: 9\nb := [5, 6, 7]\nprintln(sum(...b)) // output: 18\n")),(0,i.kt)("h3",{id:"anonymous--higher-order-functions"},"Anonymous & higher order functions"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},'fn sqr(n int) int {\n    return n * n\n}\n\nfn cube(n int) int {\n    return n * n * n\n}\n\nfn run(value int, op fn (int) int) int {\n    return op(value)\n}\n\nfn main() {\n    // Functions can be passed to other functions\n    println(run(5, sqr)) // "25"\n    // Anonymous functions can be declared inside other functions:\n    double_fn := fn (n int) int {\n        return n + n\n    }\n    println(run(5, double_fn)) // "10"\n    // Functions can be passed around without assigning them to variables:\n    res := run(5, fn (n int) int {\n        return n + n\n    })\n    println(res) // "10"\n    // You can even have an array/map of functions:\n    fns := [sqr, cube]\n    println(fns[0](10)) // "100"\n    fns_map := {\n        \'sqr\':  sqr\n        \'cube\': cube\n    }\n    println(fns_map[\'cube\'](2)) // "8"\n}\n')),(0,i.kt)("h3",{id:"closures"},"Closures"),(0,i.kt)("p",null,"V supports closures too.\nThis means that anonymous functions can inherit variables from the scope they were created in.\nThey must do so explicitly by listing all variables that are inherited."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"oksyntax",oksyntax:!0},"my_int := 1\nmy_closure := fn [my_int] () {\n    println(my_int)\n}\nmy_closure() // prints 1\n")),(0,i.kt)("p",null,"Inherited variables are copied when the anonymous function is created.\nThis means that if the original variable is modified after the creation of the function,\nthe modification won't be reflected in the function."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"oksyntax",oksyntax:!0},"mut i := 1\nfunc := fn [i] () int {\n    return i\n}\nprintln(func() == 1) // true\ni = 123\nprintln(func() == 1) // still true\n")),(0,i.kt)("p",null,"However, the variable can be modified inside the anonymous function.\nThe change won't be reflected outside, but will be in the later function calls."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"oksyntax",oksyntax:!0},"fn new_counter() fn () int {\n    mut i := 0\n    return fn [mut i] () int {\n        i++\n        return i\n    }\n}\n\nc := new_counter()\nprintln(c()) // 1\nprintln(c()) // 2\nprintln(c()) // 3\n")),(0,i.kt)("p",null,"If you need the value to be modified outside the function, use a reference.\n",(0,i.kt)("strong",{parentName:"p"},"Warning"),": ",(0,i.kt)("em",{parentName:"p"},"you need to make sure the reference is always valid,\notherwise this can result in undefined behavior.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"oksyntax",oksyntax:!0},"mut i := 0\nmut ref := &i\nprint_counter := fn [ref] () {\n    println(*ref)\n}\n\nprint_counter() // 0\ni = 10\nprint_counter() // 10\n")),(0,i.kt)("h2",{id:"references"},"References"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"struct Foo {}\n\nfn (foo Foo) bar_method() {\n    // ...\n}\n\nfn bar_function(foo Foo) {\n    // ...\n}\n")),(0,i.kt)("p",null,"If a function argument is immutable (like ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," in the examples above)\nV can pass it either by value or by reference. The compiler will decide,\nand the developer doesn't need to think about it."),(0,i.kt)("p",null,"You no longer need to remember whether you should pass the struct by value\nor by reference."),(0,i.kt)("p",null,"You can ensure that the struct is always passed by reference by\nadding ",(0,i.kt)("inlineCode",{parentName:"p"},"&"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"struct Foo {\n    abc int\n}\n\nfn (foo &Foo) bar() {\n    println(foo.abc)\n}\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"foo")," is still immutable and can't be changed. For that,\n",(0,i.kt)("inlineCode",{parentName:"p"},"(mut foo Foo)")," must be used."),(0,i.kt)("p",null,"In general, V's references are similar to Go pointers and C++ references.\nFor example, a generic tree structure definition would look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"struct Node<T> {\n    val   T\n    left  &Node<T>\n    right &Node<T>\n}\n")),(0,i.kt)("p",null,"To dereference a reference, use the ",(0,i.kt)("inlineCode",{parentName:"p"},"*")," operator, just like in C."),(0,i.kt)("h3",{id:"parameter-evaluation-order"},"Parameter evaluation order"),(0,i.kt)("p",null,"The evaluation order of the parameters of function calls is ",(0,i.kt)("em",{parentName:"p"},"NOT")," guaranteed.\nTake for example the following program:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"fn f(a1 int, a2 int, a3 int) {\n    dump(a1 + a2 + a3)\n}\n\nfn main() {\n    f(dump(100), dump(200), dump(300))\n}\n")),(0,i.kt)("p",null,"V currently does not guarantee, that it will print 100, 200, 300 in that order.\nThe only guarantee is that 600 (from the body of ",(0,i.kt)("inlineCode",{parentName:"p"},"f"),"), will be printed after all of them.\nThat ",(0,i.kt)("em",{parentName:"p"},"may")," change in V 1.0 ."),(0,i.kt)("h2",{id:"constants"},"Constants"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"const (\n    pi    = 3.14\n    world = '\u4e16\u754c'\n)\n\nprintln(pi)\nprintln(world)\n")),(0,i.kt)("p",null,"Constants are declared with ",(0,i.kt)("inlineCode",{parentName:"p"},"const"),". They can only be defined\nat the module level (outside of functions).\nConstant values can never be changed. You can also declare a single\nconstant separately:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"const e = 2.71828\n")),(0,i.kt)("p",null,"V constants are more flexible than in most languages. You can assign more complex values:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"struct Color {\n    r int\n    g int\n    b int\n}\n\nfn rgb(r int, g int, b int) Color {\n    return Color{\n        r: r\n        g: g\n        b: b\n    }\n}\n\nconst (\n    numbers = [1, 2, 3]\n    red     = Color{\n        r: 255\n        g: 0\n        b: 0\n    }\n    // evaluate function call at compile-time*\n    blue = rgb(0, 0, 255)\n)\n\nprintln(numbers)\nprintln(red)\nprintln(blue)\n")),(0,i.kt)("p",null,"*"," WIP - for now function calls are evaluated at program start-up"),(0,i.kt)("p",null,"Global variables are not normally allowed, so this can be really useful."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Modules")),(0,i.kt)("p",null,"Constants can be made public with ",(0,i.kt)("inlineCode",{parentName:"p"},"pub const"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"oksyntax",oksyntax:!0},"module mymodule\n\npub const golden_ratio = 1.61803\n\nfn calc() {\n    println(mymodule.golden_ratio)\n}\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"pub")," keyword is only allowed before the ",(0,i.kt)("inlineCode",{parentName:"p"},"const")," keyword and cannot be used inside\na ",(0,i.kt)("inlineCode",{parentName:"p"},"const ( )")," block."),(0,i.kt)("p",null,"Outside from module main all constants need to be prefixed with the module name."),(0,i.kt)("h3",{id:"required-module-prefix"},"Required module prefix"),(0,i.kt)("p",null,"When naming constants, ",(0,i.kt)("inlineCode",{parentName:"p"},"snake_case")," must be used. In order to distinguish consts\nfrom local variables, the full path to consts must be specified. For example,\nto access the PI const, full ",(0,i.kt)("inlineCode",{parentName:"p"},"math.pi")," name must be used both outside the ",(0,i.kt)("inlineCode",{parentName:"p"},"math"),"\nmodule, and inside it. That restriction is relaxed only for the ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," module\n(the one containing your ",(0,i.kt)("inlineCode",{parentName:"p"},"fn main()"),"), where you can use the unqualified name of\nconstants defined there, i.e. ",(0,i.kt)("inlineCode",{parentName:"p"},"numbers"),", rather than ",(0,i.kt)("inlineCode",{parentName:"p"},"main.numbers"),"."),(0,i.kt)("p",null,"vfmt takes care of this rule, so you can type ",(0,i.kt)("inlineCode",{parentName:"p"},"println(pi)")," inside the ",(0,i.kt)("inlineCode",{parentName:"p"},"math")," module,\nand vfmt will automatically update it to ",(0,i.kt)("inlineCode",{parentName:"p"},"println(math.pi)"),"."),(0,i.kt)("h2",{id:"builtin-functions"},"Builtin functions"),(0,i.kt)("p",null,"Some functions are builtin like ",(0,i.kt)("inlineCode",{parentName:"p"},"println"),". Here is the complete list:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"ignore",ignore:!0},"fn print(s string) // prints anything on stdout\nfn println(s string) // prints anything and a newline on stdout\n\nfn eprint(s string) // same as print(), but uses stderr\nfn eprintln(s string) // same as println(), but uses stderr\n\nfn exit(code int) // terminates the program with a custom error code\nfn panic(s string) // prints a message and backtraces on stderr, and terminates the program with error code 1\nfn print_backtrace() // prints backtraces on stderr\n")),(0,i.kt)("p",null,"Note: Although the ",(0,i.kt)("inlineCode",{parentName:"p"},"print")," functions take a string, V accepts other printable types too.\nSee below for details."),(0,i.kt)("p",null,"There is also a special built-in function called ",(0,i.kt)("a",{parentName:"p",href:"#dumping-expressions-at-runtime"},(0,i.kt)("inlineCode",{parentName:"a"},"dump")),"."),(0,i.kt)("h3",{id:"println"},"println"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"println")," is a simple yet powerful builtin function, that can print anything:\nstrings, numbers, arrays, maps, structs."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},'struct User {\n    name string\n    age  int\n}\n\nprintln(1) // "1"\nprintln(\'hi\') // "hi"\nprintln([1, 2, 3]) // "[1, 2, 3]"\nprintln(User{ name: \'Bob\', age: 20 }) // "User{name:\'Bob\', age:20}"\n')),(0,i.kt)("p",null,"See also ",(0,i.kt)("a",{parentName:"p",href:"#array-methods"},"Array methods"),"."),(0,i.kt)("a",{id:"custom-print-of-types"}),(0,i.kt)("h3",{id:"printing-custom-types"},"Printing custom types"),(0,i.kt)("p",null,"If you want to define a custom print value for your type, simply define a\n",(0,i.kt)("inlineCode",{parentName:"p"},"str() string")," method:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"struct Color {\n    r int\n    g int\n    b int\n}\n\npub fn (c Color) str() string {\n    return '{$c.r, $c.g, $c.b}'\n}\n\nred := Color{\n    r: 255\n    g: 0\n    b: 0\n}\nprintln(red)\n")),(0,i.kt)("h3",{id:"dumping-expressions-at-runtime"},"Dumping expressions at runtime"),(0,i.kt)("p",null,"You can dump/trace the value of any V expression using ",(0,i.kt)("inlineCode",{parentName:"p"},"dump(expr)"),".\nFor example, save this code sample as ",(0,i.kt)("inlineCode",{parentName:"p"},"factorial.v"),", then run it with\n",(0,i.kt)("inlineCode",{parentName:"p"},"v run factorial.v"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"fn factorial(n u32) u32 {\n    if dump(n <= 1) {\n        return dump(1)\n    }\n    return dump(n * factorial(n - 1))\n}\n\nfn main() {\n    println(factorial(5))\n}\n")),(0,i.kt)("p",null,"You will get:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"[factorial.v:2] n <= 1: false\n[factorial.v:2] n <= 1: false\n[factorial.v:2] n <= 1: false\n[factorial.v:2] n <= 1: false\n[factorial.v:2] n <= 1: true\n[factorial.v:3] 1: 1\n[factorial.v:5] n * factorial(n - 1): 2\n[factorial.v:5] n * factorial(n - 1): 6\n[factorial.v:5] n * factorial(n - 1): 24\n[factorial.v:5] n * factorial(n - 1): 120\n120\n")),(0,i.kt)("p",null,"Note that ",(0,i.kt)("inlineCode",{parentName:"p"},"dump(expr)")," will trace both the source location,\nthe expression itself, and the expression value."),(0,i.kt)("h2",{id:"modules"},"Modules"),(0,i.kt)("p",null,"Every file in the root of a folder is part of the same module.\nSimple programs don't need to specify module name, in which case it defaults to 'main'."),(0,i.kt)("p",null,"V is a very modular language. Creating reusable modules is encouraged and is\nquite easy to do.\nTo create a new module, create a directory with your module's name containing\n.v files with code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"cd ~/code/modules\nmkdir mymodule\nvim mymodule/myfile.v\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"failcompile",failcompile:!0},"// myfile.v\nmodule mymodule\n\n// To export a function we have to use `pub`\npub fn say_hi() {\n    println('hello from mymodule!')\n}\n")),(0,i.kt)("p",null,"You can now use ",(0,i.kt)("inlineCode",{parentName:"p"},"mymodule")," in your code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"failcompile",failcompile:!0},"import mymodule\n\nfn main() {\n    mymodule.say_hi()\n}\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Module names should be short, under 10 characters."),(0,i.kt)("li",{parentName:"ul"},"Module names must use ",(0,i.kt)("inlineCode",{parentName:"li"},"snake_case"),"."),(0,i.kt)("li",{parentName:"ul"},"Circular imports are not allowed."),(0,i.kt)("li",{parentName:"ul"},"You can have as many .v files in a module as you want."),(0,i.kt)("li",{parentName:"ul"},"You can create modules anywhere."),(0,i.kt)("li",{parentName:"ul"},"All modules are compiled statically into a single executable.")),(0,i.kt)("h3",{id:"init-functions"},(0,i.kt)("inlineCode",{parentName:"h3"},"init")," functions"),(0,i.kt)("p",null,"If you want a module to automatically call some setup/initialization code when it is imported,\nyou can use a module ",(0,i.kt)("inlineCode",{parentName:"p"},"init")," function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"fn init() {\n    // your setup code here ...\n}\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"init")," function cannot be public - it will be called automatically. This feature is\nparticularly useful for initializing a C library."),(0,i.kt)("h2",{id:"type-declarations"},"Type Declarations"),(0,i.kt)("h3",{id:"interfaces"},"Interfaces"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"// interface-example.1\nstruct Dog {\n    breed string\n}\n\nfn (d Dog) speak() string {\n    return 'woof'\n}\n\nstruct Cat {\n    breed string\n}\n\nfn (c Cat) speak() string {\n    return 'meow'\n}\n\n// unlike Go and like TypeScript, V's interfaces can define fields, not just methods.\ninterface Speaker {\n    breed string\n    speak() string\n}\n\nfn main() {\n    dog := Dog{'Leonberger'}\n    cat := Cat{'Siamese'}\n\n    mut arr := []Speaker{}\n    arr << dog\n    arr << cat\n    for item in arr {\n        println('a $item.breed says: $item.speak()')\n    }\n}\n")),(0,i.kt)("h4",{id:"implement-an-interface"},"Implement an interface"),(0,i.kt)("p",null,'A type implements an interface by implementing its methods and fields.\nThere is no explicit declaration of intent, no "implements" keyword.'),(0,i.kt)("p",null,"An interface can have a ",(0,i.kt)("inlineCode",{parentName:"p"},"mut:")," section. Implementing types will need\nto have a ",(0,i.kt)("inlineCode",{parentName:"p"},"mut")," receiver, for methods declared in the ",(0,i.kt)("inlineCode",{parentName:"p"},"mut:")," section\nof an interface."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"// interface-example.2\nmodule main\n\npub interface Foo {\n    write(string) string\n}\n\n// => the method signature of a type, implementing interface Foo should be:\n// `pub fn (s Type) write(a string) string`\n\npub interface Bar {\nmut:\n    write(string) string\n}\n\n// => the method signature of a type, implementing interface Bar should be:\n// `pub fn (mut s Type) write(a string) string`\n\nstruct MyStruct {}\n\n// MyStruct implements the interface Foo, but *not* interface Bar\npub fn (s MyStruct) write(a string) string {\n    return a\n}\n\nfn main() {\n    s1 := MyStruct{}\n    fn1(s1)\n    // fn2(s1) -> compile error, since MyStruct does not implement Bar\n}\n\nfn fn1(s Foo) {\n    println(s.write('Foo'))\n}\n\n// fn fn2(s Bar) { // does not match\n//      println(s.write('Foo'))\n// }\n")),(0,i.kt)("h4",{id:"casting-an-interface"},"Casting an interface"),(0,i.kt)("p",null,"We can test the underlying type of an interface using dynamic cast operators:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"oksyntax",oksyntax:!0},"// interface-exmaple.3 (continued from interface-exampe.1)\ninterface Something {}\n\nfn announce(s Something) {\n    if s is Dog {\n        println('a $s.breed dog') // `s` is automatically cast to `Dog` (smart cast)\n    } else if s is Cat {\n        println('a cat speaks $s.speak()')\n    } else {\n        println('something else')\n    }\n}\n\nfn main() {\n    dog := Dog{'Leonberger'}\n    cat := Cat{'Siamese'}\n    announce(dog)\n    announce(cat)\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"// interface-example.4\ninterface IFoo {\n    foo()\n}\n\ninterface IBar {\n    bar()\n}\n\n// implements only IFoo\nstruct SFoo {}\n\nfn (sf SFoo) foo() {}\n\n// implements both IFoo and IBar\nstruct SFooBar {}\n\nfn (sfb SFooBar) foo() {}\n\nfn (sfb SFooBar) bar() {\n    dump('This implements IBar')\n}\n\nfn main() {\n    mut arr := []IFoo{}\n    arr << SFoo{}\n    arr << SFooBar{}\n\n    for a in arr {\n        dump(a)\n        // In order to execute instances that implements IBar.\n        if a is IBar {\n            // a.bar() // Error.\n            b := a as IBar\n            dump(b)\n            b.bar()\n        }\n    }\n}\n")),(0,i.kt)("p",null,"For more information, see ",(0,i.kt)("a",{parentName:"p",href:"#dynamic-casts"},"Dynamic casts"),"."),(0,i.kt)("h4",{id:"interface-method-definitions"},"Interface method definitions"),(0,i.kt)("p",null,"Also unlike Go, an interface can have it's own methods, similar to how\nstructs can have their methods. These 'interface methods' do not have\nto be implemented, by structs which implement that interface.\nThey are just a convenient way to write ",(0,i.kt)("inlineCode",{parentName:"p"},"i.some_function()")," instead of\n",(0,i.kt)("inlineCode",{parentName:"p"},"some_function(i)"),", similar to how struct methods can be looked at, as\na convenience for writing ",(0,i.kt)("inlineCode",{parentName:"p"},"s.xyz()")," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"xyz(s)"),"."),(0,i.kt)("p",null,'N.B. This feature is NOT a "default implementation" like in C#.'),(0,i.kt)("p",null,"For example, if a struct ",(0,i.kt)("inlineCode",{parentName:"p"},"cat")," is wrapped in an interface ",(0,i.kt)("inlineCode",{parentName:"p"},"a"),", that has\nimplemented a method with the same name ",(0,i.kt)("inlineCode",{parentName:"p"},"speak"),", as a method implemented by\nthe struct, and you do ",(0,i.kt)("inlineCode",{parentName:"p"},"a.speak()"),", ",(0,i.kt)("em",{parentName:"p"},"only")," the interface method is called:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"interface Adoptable {}\n\nfn (a Adoptable) speak() string {\n    return 'adopt me!'\n}\n\nstruct Cat {}\n\nfn (c Cat) speak() string {\n    return 'meow!'\n}\n\nstruct Dog {}\n\nfn main() {\n    cat := Cat{}\n    assert dump(cat.speak()) == 'meow!'\n    //\n    a := Adoptable(cat)\n    assert dump(a.speak()) == 'adopt me!' // call Adoptable's `speak`\n    if a is Cat {\n        // Inside this `if` however, V knows that `a` is not just any\n        // kind of Adoptable, but actually a Cat, so it will use the\n        // Cat `speak`, NOT the Adoptable `speak`:\n        dump(a.speak()) // meow!\n    }\n    //\n    b := Adoptable(Dog{})\n    assert dump(b.speak()) == 'adopt me!' // call Adoptable's `speak`\n    // if b is Dog {\n    //  dump(b.speak()) // error: unknown method or field: Dog.speak\n    // }\n}\n")),(0,i.kt)("h4",{id:"embedded-interface"},"Embedded interface"),(0,i.kt)("p",null,"Interfaces support embedding, just like structs:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"pub interface Reader {\nmut:\n    read(mut buf []byte) ?int\n}\n\npub interface Writer {\nmut:\n    write(buf []byte) ?int\n}\n\n// ReaderWriter embeds both Reader and Writer.\n// The effect is the same as copy/pasting all of the\n// Reader and all of the Writer methods/fields into\n// ReaderWriter.\npub interface ReaderWriter {\n    Reader\n    Writer\n}\n")),(0,i.kt)("h3",{id:"function-types"},"Function Types"),(0,i.kt)("p",null,"You can use type aliases for naming specific function signatures - for\nexample:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"type Filter = fn (string) string\n")),(0,i.kt)("p",null,"This works like any other type - for example, a function can accept an\nargument of a function type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"type Filter = fn (string) string\n\nfn filter(s string, f Filter) string {\n    return f(s)\n}\n")),(0,i.kt)("p",null,"V has duck-typing, so functions don't need to declare compatibility with\na function type - they just have to be compatible:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"fn uppercase(s string) string {\n    return s.to_upper()\n}\n\n// now `uppercase` can be used everywhere where Filter is expected\n")),(0,i.kt)("p",null,"Compatible functions can also be explicitly cast to a function type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"oksyntax",oksyntax:!0},"my_filter := Filter(uppercase)\n")),(0,i.kt)("p",null,"The cast here is purely informational - again, duck-typing means that the\nresulting type is the same without an explicit cast:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"oksyntax",oksyntax:!0},"my_filter := uppercase\n")),(0,i.kt)("p",null,"You can pass the assigned function as an argument:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"oksyntax",oksyntax:!0},"println(filter('Hello world', my_filter)) // prints `HELLO WORLD`\n")),(0,i.kt)("p",null,"And you could of course have passed it directly as well, without using a\nlocal variable:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"oksyntax",oksyntax:!0},"println(filter('Hello world', uppercase))\n")),(0,i.kt)("p",null,"And this works with anonymous functions as well:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"oksyntax",oksyntax:!0},"println(filter('Hello world', fn (s string) string {\n    return s.to_upper()\n}))\n")),(0,i.kt)("p",null,"You can see the complete\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/vlang/v/tree/master/examples/function_types.v"},"example here"),"."),(0,i.kt)("h3",{id:"enums"},"Enums"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"enum Color {\n    red\n    green\n    blue\n}\n\nmut color := Color.red\n// V knows that `color` is a `Color`. No need to use `color = Color.green` here.\ncolor = .green\nprintln(color) // \"green\"\nmatch color {\n    .red { println('the color was red') }\n    .green { println('the color was green') }\n    .blue { println('the color was blue') }\n}\n")),(0,i.kt)("p",null,"Enum match must be exhaustive or have an ",(0,i.kt)("inlineCode",{parentName:"p"},"else")," branch.\nThis ensures that if a new enum field is added, it's handled everywhere in the code."),(0,i.kt)("p",null,"Enum fields cannot re-use reserved keywords. However, reserved keywords may be escaped\nwith an @."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"enum Color {\n    @none\n    red\n    green\n    blue\n}\n\ncolor := Color.@none\nprintln(color)\n")),(0,i.kt)("p",null,"Integers may be assigned to enum fields."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"enum Grocery {\n    apple\n    orange = 5\n    pear\n}\n\ng1 := int(Grocery.apple)\ng2 := int(Grocery.orange)\ng3 := int(Grocery.pear)\nprintln('Grocery IDs: $g1, $g2, $g3')\n")),(0,i.kt)("p",null,"Output: ",(0,i.kt)("inlineCode",{parentName:"p"},"Grocery IDs: 0, 5, 6"),"."),(0,i.kt)("p",null,"Operations are not allowed on enum variables; they must be explicitly cast to ",(0,i.kt)("inlineCode",{parentName:"p"},"int"),"."),(0,i.kt)("p",null,"Enums can have methods, just like structs."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"enum Cycle {\n    one\n    two\n    three\n}\n\nfn (c Cycle) next() Cycle {\n    match c {\n        .one {\n            return .two\n        }\n        .two {\n            return .three\n        }\n        .three {\n            return .one\n        }\n    }\n}\n\nmut c := Cycle.one\nfor _ in 0 .. 10 {\n    println(c)\n    c = c.next()\n}\n")),(0,i.kt)("p",null,"Output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"one\ntwo\nthree\none\ntwo\nthree\none\ntwo\nthree\none\n")),(0,i.kt)("h3",{id:"sum-types"},"Sum types"),(0,i.kt)("p",null,"A sum type instance can hold a value of several different types. Use the ",(0,i.kt)("inlineCode",{parentName:"p"},"type"),"\nkeyword to declare a sum type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"struct Moon {}\n\nstruct Mars {}\n\nstruct Venus {}\n\ntype World = Mars | Moon | Venus\n\nsum := World(Moon{})\nassert sum.type_name() == 'Moon'\nprintln(sum)\n")),(0,i.kt)("p",null,"The built-in method ",(0,i.kt)("inlineCode",{parentName:"p"},"type_name")," returns the name of the currently held\ntype."),(0,i.kt)("p",null,"With sum types you could build recursive structures and write concise but powerful code on them."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"// V's binary tree\nstruct Empty {}\n\nstruct Node {\n    value f64\n    left  Tree\n    right Tree\n}\n\ntype Tree = Empty | Node\n\n// sum up all node values\nfn sum(tree Tree) f64 {\n    return match tree {\n        Empty { 0 }\n        Node { tree.value + sum(tree.left) + sum(tree.right) }\n    }\n}\n\nfn main() {\n    left := Node{0.2, Empty{}, Empty{}}\n    right := Node{0.3, Empty{}, Node{0.4, Empty{}, Empty{}}}\n    tree := Node{0.5, left, right}\n    println(sum(tree)) // 0.2 + 0.3 + 0.4 + 0.5 = 1.4\n}\n")),(0,i.kt)("h4",{id:"dynamic-casts"},"Dynamic casts"),(0,i.kt)("p",null,"To check whether a sum type instance holds a certain type, use ",(0,i.kt)("inlineCode",{parentName:"p"},"sum is Type"),".\nTo cast a sum type to one of its variants you can use ",(0,i.kt)("inlineCode",{parentName:"p"},"sum as Type"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"struct Moon {}\n\nstruct Mars {}\n\nstruct Venus {}\n\ntype World = Mars | Moon | Venus\n\nfn (m Mars) dust_storm() bool {\n    return true\n}\n\nfn main() {\n    mut w := World(Moon{})\n    assert w is Moon\n    w = Mars{}\n    // use `as` to access the Mars instance\n    mars := w as Mars\n    if mars.dust_storm() {\n        println('bad weather!')\n    }\n}\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"as")," will panic if ",(0,i.kt)("inlineCode",{parentName:"p"},"w")," doesn't hold a ",(0,i.kt)("inlineCode",{parentName:"p"},"Mars")," instance.\nA safer way is to use a smart cast."),(0,i.kt)("h4",{id:"smart-casting"},"Smart casting"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"oksyntax",oksyntax:!0},"if w is Mars {\n    assert typeof(w).name == 'Mars'\n    if w.dust_storm() {\n        println('bad weather!')\n    }\n}\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"w")," has type ",(0,i.kt)("inlineCode",{parentName:"p"},"Mars")," inside the body of the ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," statement. This is\nknown as ",(0,i.kt)("em",{parentName:"p"},"flow-sensitive typing"),".\nIf ",(0,i.kt)("inlineCode",{parentName:"p"},"w")," is a mutable identifier, it would be unsafe if the compiler smart casts it without a warning.\nThat's why you have to declare a ",(0,i.kt)("inlineCode",{parentName:"p"},"mut")," before the ",(0,i.kt)("inlineCode",{parentName:"p"},"is")," expression:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"ignore",ignore:!0},"if mut w is Mars {\n    assert typeof(w).name == 'Mars'\n    if w.dust_storm() {\n        println('bad weather!')\n    }\n}\n")),(0,i.kt)("p",null,"Otherwise ",(0,i.kt)("inlineCode",{parentName:"p"},"w")," would keep its original type."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"This works for both, simple variables and complex expressions like ",(0,i.kt)("inlineCode",{parentName:"p"},"user.name"))),(0,i.kt)("h4",{id:"matching-sum-types"},"Matching sum types"),(0,i.kt)("p",null,"You can also use ",(0,i.kt)("inlineCode",{parentName:"p"},"match")," to determine the variant:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"struct Moon {}\n\nstruct Mars {}\n\nstruct Venus {}\n\ntype World = Mars | Moon | Venus\n\nfn open_parachutes(n int) {\n    println(n)\n}\n\nfn land(w World) {\n    match w {\n        Moon {} // no atmosphere\n        Mars {\n            // light atmosphere\n            open_parachutes(3)\n        }\n        Venus {\n            // heavy atmosphere\n            open_parachutes(1)\n        }\n    }\n}\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"match")," must have a pattern for each variant or have an ",(0,i.kt)("inlineCode",{parentName:"p"},"else")," branch."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"ignore",ignore:!0},"struct Moon {}\nstruct Mars {}\nstruct Venus {}\n\ntype World = Moon | Mars | Venus\n\nfn (m Moon) moon_walk() {}\nfn (m Mars) shiver() {}\nfn (v Venus) sweat() {}\n\nfn pass_time(w World) {\n    match w {\n        // using the shadowed match variable, in this case `w` (smart cast)\n        Moon { w.moon_walk() }\n        Mars { w.shiver() }\n        else {}\n    }\n}\n")),(0,i.kt)("h3",{id:"type-aliases"},"Type aliases"),(0,i.kt)("p",null,"To define a new type ",(0,i.kt)("inlineCode",{parentName:"p"},"NewType")," as an alias for ",(0,i.kt)("inlineCode",{parentName:"p"},"ExistingType"),",\ndo ",(0,i.kt)("inlineCode",{parentName:"p"},"type NewType = ExistingType"),".",(0,i.kt)("br",null),"\nThis is a special case of a ",(0,i.kt)("a",{parentName:"p",href:"#sum-types"},"sum type")," declaration."),(0,i.kt)("h3",{id:"optionresult-types-and-error-handling"},"Option/Result types and error handling"),(0,i.kt)("p",null,"Option types are declared with ",(0,i.kt)("inlineCode",{parentName:"p"},"?Type"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"struct User {\n    id   int\n    name string\n}\n\nstruct Repo {\n    users []User\n}\n\nfn (r Repo) find_user_by_id(id int) ?User {\n    for user in r.users {\n        if user.id == id {\n            // V automatically wraps this into an option type\n            return user\n        }\n    }\n    return error('User $id not found')\n}\n\nfn main() {\n    repo := Repo{\n        users: [User{1, 'Andrew'}, User{2, 'Bob'}, User{10, 'Charles'}]\n    }\n    user := repo.find_user_by_id(10) or { // Option types must be handled by `or` blocks\n        return\n    }\n    println(user.id) // \"10\"\n    println(user.name) // \"Charles\"\n}\n")),(0,i.kt)("p",null,"V combines ",(0,i.kt)("inlineCode",{parentName:"p"},"Option")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Result")," into one type, so you don't need to decide which one to use."),(0,i.kt)("p",null,'The amount of work required to "upgrade" a function to an optional function is minimal;\nyou have to add a ',(0,i.kt)("inlineCode",{parentName:"p"},"?")," to the return type and return an error when something goes wrong."),(0,i.kt)("p",null,"If you don't need to return an error message, you can simply ",(0,i.kt)("inlineCode",{parentName:"p"},"return none"),"\n(this is a more efficient equivalent of ",(0,i.kt)("inlineCode",{parentName:"p"},'return error("")'),")."),(0,i.kt)("p",null,"This is the primary mechanism for error handling in V. They are still values, like in Go,\nbut the advantage is that errors can't be unhandled, and handling them is a lot less verbose.\nUnlike other languages, V does not handle exceptions with ",(0,i.kt)("inlineCode",{parentName:"p"},"throw/try/catch")," blocks."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"err")," is defined inside an ",(0,i.kt)("inlineCode",{parentName:"p"},"or")," block and is set to the string message passed\nto the ",(0,i.kt)("inlineCode",{parentName:"p"},"error()")," function. ",(0,i.kt)("inlineCode",{parentName:"p"},"err")," is empty if ",(0,i.kt)("inlineCode",{parentName:"p"},"none")," was returned."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"oksyntax",oksyntax:!0},'user := repo.find_user_by_id(7) or {\n    println(err) // "User 7 not found"\n    return\n}\n')),(0,i.kt)("h3",{id:"handling-optionals"},"Handling optionals"),(0,i.kt)("p",null,"There are four ways of handling an optional. The first method is to\npropagate the error:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"import net.http\n\nfn f(url string) ?string {\n    resp := http.get(url)?\n    return resp.body\n}\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"http.get")," returns ",(0,i.kt)("inlineCode",{parentName:"p"},"?http.Response"),". Because ",(0,i.kt)("inlineCode",{parentName:"p"},"?")," follows the call, the\nerror will be propagated to the caller of ",(0,i.kt)("inlineCode",{parentName:"p"},"f"),". When using ",(0,i.kt)("inlineCode",{parentName:"p"},"?")," after a\nfunction call producing an optional, the enclosing function must return\nan optional as well. If error propagation is used in the ",(0,i.kt)("inlineCode",{parentName:"p"},"main()"),"\nfunction it will ",(0,i.kt)("inlineCode",{parentName:"p"},"panic")," instead, since the error cannot be propagated\nany further."),(0,i.kt)("p",null,"The body of ",(0,i.kt)("inlineCode",{parentName:"p"},"f")," is essentially a condensed version of:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"ignore",ignore:!0},"    resp := http.get(url) or { return err }\n    return resp.body\n")),(0,i.kt)("hr",null),(0,i.kt)("p",null,"The second method is to break from execution early:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"oksyntax",oksyntax:!0},"user := repo.find_user_by_id(7) or { return }\n")),(0,i.kt)("p",null,"Here, you can either call ",(0,i.kt)("inlineCode",{parentName:"p"},"panic()")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"exit()"),", which will stop the execution of the\nentire program, or use a control flow statement (",(0,i.kt)("inlineCode",{parentName:"p"},"return"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"break"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"continue"),", etc)\nto break from the current block.\nNote that ",(0,i.kt)("inlineCode",{parentName:"p"},"break")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"continue")," can only be used inside a ",(0,i.kt)("inlineCode",{parentName:"p"},"for")," loop."),(0,i.kt)("p",null,'V does not have a way to forcibly "unwrap" an optional (as other languages do,\nfor instance Rust\'s ',(0,i.kt)("inlineCode",{parentName:"p"},"unwrap()")," or Swift's ",(0,i.kt)("inlineCode",{parentName:"p"},"!"),"). To do this, use ",(0,i.kt)("inlineCode",{parentName:"p"},"or { panic(err) }")," instead."),(0,i.kt)("hr",null),(0,i.kt)("p",null,"The third method is to provide a default value at the end of the ",(0,i.kt)("inlineCode",{parentName:"p"},"or")," block.\nIn case of an error, that value would be assigned instead,\nso it must have the same type as the content of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Option")," being handled."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"fn do_something(s string) ?string {\n    if s == 'foo' {\n        return 'foo'\n    }\n    return error('invalid string') // Could be `return none` as well\n}\n\na := do_something('foo') or { 'default' } // a will be 'foo'\nb := do_something('bar') or { 'default' } // b will be 'default'\nprintln(a)\nprintln(b)\n")),(0,i.kt)("hr",null),(0,i.kt)("p",null,"The fourth method is to use ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," unwrapping:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"import net.http\n\nif resp := http.get('https://google.com') {\n    println(resp.body) // resp is a http.Response, not an optional\n} else {\n    println(err)\n}\n")),(0,i.kt)("p",null,"Above, ",(0,i.kt)("inlineCode",{parentName:"p"},"http.get")," returns a ",(0,i.kt)("inlineCode",{parentName:"p"},"?http.Response"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"resp")," is only in scope for the first\n",(0,i.kt)("inlineCode",{parentName:"p"},"if")," branch. ",(0,i.kt)("inlineCode",{parentName:"p"},"err")," is only in scope for the ",(0,i.kt)("inlineCode",{parentName:"p"},"else")," branch."),(0,i.kt)("h2",{id:"custom-error-types"},"Custom error types"),(0,i.kt)("p",null,"V gives you the ability to define custom error types through the ",(0,i.kt)("inlineCode",{parentName:"p"},"IError")," interface.\nThe interface requires two methods: ",(0,i.kt)("inlineCode",{parentName:"p"},"msg() string")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"code() int"),". Every type that\nimplements these methods can be used as an error."),(0,i.kt)("p",null,"When defining a custom error type it is recommended to embed the builtin ",(0,i.kt)("inlineCode",{parentName:"p"},"Error")," default\nimplementation. This provides an empty default implementation for both required methods,\nso you only have to implement what you really need, and may provide additional utility\nfunctions in the future."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"struct PathError {\n    Error\n    path string\n}\n\nfn (err PathError) msg() string {\n    return 'Failed to open path: $err.path'\n}\n\nfn try_open(path string) ? {\n    return IError(PathError{\n        path: path\n    })\n}\n\nfn main() {\n    try_open('/tmp') or { panic(err) }\n}\n")),(0,i.kt)("h2",{id:"generics"},"Generics"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"wip",wip:!0},"\nstruct Repo<T> {\n    db DB\n}\n\nstruct User {\n    id   int\n    name string\n}\n\nstruct Post {\n    id   int\n    user_id int\n    title string\n    body string\n}\n\nfn new_repo<T>(db DB) Repo<T> {\n    return Repo<T>{db: db}\n}\n\n// This is a generic function. V will generate it for every type it's used with.\nfn (r Repo<T>) find_by_id(id int) ?T {\n    table_name := T.name // in this example getting the name of the type gives us the table name\n    return r.db.query_one<T>('select * from $table_name where id = ?', id)\n}\n\ndb := new_db()\nusers_repo := new_repo<User>(db) // returns Repo<User>\nposts_repo := new_repo<Post>(db) // returns Repo<Post>\nuser := users_repo.find_by_id(1)? // find_by_id<User>\npost := posts_repo.find_by_id(1)? // find_by_id<Post>\n")),(0,i.kt)("p",null,"Currently generic function definitions must declare their type parameters, but in\nfuture V will infer generic type parameters from single-letter type names in\nruntime parameter types. This is why ",(0,i.kt)("inlineCode",{parentName:"p"},"find_by_id")," can omit ",(0,i.kt)("inlineCode",{parentName:"p"},"<T>"),", because the\nreceiver argument ",(0,i.kt)("inlineCode",{parentName:"p"},"r")," uses a generic type ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),"."),(0,i.kt)("p",null,"Another example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"fn compare<T>(a T, b T) int {\n    if a < b {\n        return -1\n    }\n    if a > b {\n        return 1\n    }\n    return 0\n}\n\n// compare<int>\nprintln(compare(1, 0)) // Outputs: 1\nprintln(compare(1, 1)) //          0\nprintln(compare(1, 2)) //         -1\n// compare<string>\nprintln(compare('1', '0')) // Outputs: 1\nprintln(compare('1', '1')) //          0\nprintln(compare('1', '2')) //         -1\n// compare<f64>\nprintln(compare(1.1, 1.0)) // Outputs: 1\nprintln(compare(1.1, 1.1)) //          0\nprintln(compare(1.1, 1.2)) //         -1\n")),(0,i.kt)("h2",{id:"concurrency"},"Concurrency"),(0,i.kt)("h3",{id:"spawning-concurrent-tasks"},"Spawning Concurrent Tasks"),(0,i.kt)("p",null,"V's model of concurrency is going to be very similar to Go's.\nFor now, ",(0,i.kt)("inlineCode",{parentName:"p"},"go foo()")," runs ",(0,i.kt)("inlineCode",{parentName:"p"},"foo()")," concurrently in a different thread:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"import math\n\nfn p(a f64, b f64) { // ordinary function without return value\n    c := math.sqrt(a * a + b * b)\n    println(c)\n}\n\nfn main() {\n    go p(3, 4)\n    // p will be run in parallel thread\n    // It can also be written as follows\n    // go fn (a f64, b f64) {\n    //  c := math.sqrt(a * a + b * b)\n    //  println(c)\n    // }(3, 4)\n}\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"In V 0.4 ",(0,i.kt)("inlineCode",{parentName:"p"},"go foo()")," will be automatically renamed via vfmt to ",(0,i.kt)("inlineCode",{parentName:"p"},"spawn foo()"),",\nand there will be a way to launch a coroutine (a lightweight thread managed by the runtime).")),(0,i.kt)("p",null,"Sometimes it is necessary to wait until a parallel thread has finished. This can\nbe done by assigning a ",(0,i.kt)("em",{parentName:"p"},"handle")," to the started thread and calling the ",(0,i.kt)("inlineCode",{parentName:"p"},"wait()")," method\nto this handle later:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"import math\n\nfn p(a f64, b f64) { // ordinary function without return value\n    c := math.sqrt(a * a + b * b)\n    println(c) // prints `5`\n}\n\nfn main() {\n    h := go p(3, 4)\n    // p() runs in parallel thread\n    h.wait()\n    // p() has definitely finished\n}\n")),(0,i.kt)("p",null,"This approach can also be used to get a return value from a function that is run in a\nparallel thread. There is no need to modify the function itself to be able to call it\nconcurrently."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"import math { sqrt }\n\nfn get_hypot(a f64, b f64) f64 { //       ordinary function returning a value\n    c := sqrt(a * a + b * b)\n    return c\n}\n\nfn main() {\n    g := go get_hypot(54.06, 2.08) // spawn thread and get handle to it\n    h1 := get_hypot(2.32, 16.74) //   do some other calculation here\n    h2 := g.wait() //                 get result from spawned thread\n    println('Results: $h1, $h2') //   prints `Results: 16.9, 54.1`\n}\n")),(0,i.kt)("p",null,"If there is a large number of tasks, it might be easier to manage them\nusing an array of threads."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"import time\n\nfn task(id int, duration int) {\n    println('task $id begin')\n    time.sleep(duration * time.millisecond)\n    println('task $id end')\n}\n\nfn main() {\n    mut threads := []thread{}\n    threads << go task(1, 500)\n    threads << go task(2, 900)\n    threads << go task(3, 100)\n    threads.wait()\n    println('done')\n}\n\n// Output:\n// task 1 begin\n// task 2 begin\n// task 3 begin\n// task 3 end\n// task 1 end\n// task 2 end\n// done\n")),(0,i.kt)("p",null,"Additionally for threads that return the same type, calling ",(0,i.kt)("inlineCode",{parentName:"p"},"wait()"),"\non the thread array will return all computed values."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"fn expensive_computing(i int) int {\n    return i * i\n}\n\nfn main() {\n    mut threads := []thread int{}\n    for i in 1 .. 10 {\n        threads << go expensive_computing(i)\n    }\n    // Join all tasks\n    r := threads.wait()\n    println('All jobs finished: $r')\n}\n\n// Output: All jobs finished: [1, 4, 9, 16, 25, 36, 49, 64, 81]\n")),(0,i.kt)("h3",{id:"channels"},"Channels"),(0,i.kt)("p",null,"Channels are the preferred way to communicate between threads. V's channels work basically like\nthose in Go. You can push objects into a channel on one end and pop objects from the other end.\nChannels can be buffered or unbuffered and it is possible to ",(0,i.kt)("inlineCode",{parentName:"p"},"select")," from multiple channels."),(0,i.kt)("h4",{id:"syntax-and-usage"},"Syntax and Usage"),(0,i.kt)("p",null,"Channels have the type ",(0,i.kt)("inlineCode",{parentName:"p"},"chan objtype"),". An optional buffer length can specified as the ",(0,i.kt)("inlineCode",{parentName:"p"},"cap")," field\nin the declaration:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},'ch := chan int{} // unbuffered - "synchronous"\nch2 := chan f64{cap: 100} // buffer length 100\n')),(0,i.kt)("p",null,"Channels do not have to be declared as ",(0,i.kt)("inlineCode",{parentName:"p"},"mut"),". The buffer length is not part of the type but\na field of the individual channel object. Channels can be passed to threads like normal\nvariables:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"fn f(ch chan int) {\n    // ...\n}\n\nfn main() {\n    ch := chan int{}\n    go f(ch)\n    // ...\n}\n")),(0,i.kt)("p",null,"Objects can be pushed to channels using the arrow operator. The same operator can be used to\npop objects from the other end:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"// make buffered channels so pushing does not block (if there is room in the buffer)\nch := chan int{cap: 1}\nch2 := chan f64{cap: 1}\nn := 5\n// push\nch <- n\nch2 <- 7.3\nmut y := f64(0.0)\nm := <-ch // pop creating new variable\ny = <-ch2 // pop into existing variable\n")),(0,i.kt)("p",null,"A channel can be closed to indicate that no further objects can be pushed. Any attempt\nto do so will then result in a runtime panic (with the exception of ",(0,i.kt)("inlineCode",{parentName:"p"},"select")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"try_push()")," - see below). Attempts to pop will return immediately if the\nassociated channel has been closed and the buffer is empty. This situation can be\nhandled using an or branch (see ",(0,i.kt)("a",{parentName:"p",href:"#handling-optionals"},"Handling Optionals"),")."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"wip",wip:!0},"ch := chan int{}\nch2 := chan f64{}\n// ...\nch.close()\n// ...\nm := <-ch or {\n    println('channel has been closed')\n}\n\n// propagate error\ny := <-ch2 ?\n")),(0,i.kt)("h4",{id:"channel-select"},"Channel Select"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"select")," command allows monitoring several channels at the same time\nwithout noticeable CPU load.  It consists of a list of possible transfers and associated branches\nof statements - similar to the ",(0,i.kt)("a",{parentName:"p",href:"#match"},"match")," command:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"import time\n\nfn main() {\n    ch := chan f64{}\n    ch2 := chan f64{}\n    ch3 := chan f64{}\n    mut b := 0.0\n    c := 1.0\n    // ... setup go threads that will send on ch/ch2\n    go fn (the_channel chan f64) {\n        time.sleep(5 * time.millisecond)\n        the_channel <- 1.0\n    }(ch)\n    go fn (the_channel chan f64) {\n        time.sleep(1 * time.millisecond)\n        the_channel <- 1.0\n    }(ch2)\n    go fn (the_channel chan f64) {\n        _ := <-the_channel\n    }(ch3)\n\n    select {\n        a := <-ch {\n            // do something with `a`\n            eprintln('> a: $a')\n        }\n        b = <-ch2 {\n            // do something with predeclared variable `b`\n            eprintln('> b: $b')\n        }\n        ch3 <- c {\n            // do something if `c` was sent\n            time.sleep(5 * time.millisecond)\n            eprintln('> c: $c was send on channel ch3')\n        }\n        500 * time.millisecond {\n            // do something if no channel has become ready within 0.5s\n            eprintln('> more than 0.5s passed without a channel being ready')\n        }\n    }\n    eprintln('> done')\n}\n")),(0,i.kt)("p",null,"The timeout branch is optional. If it is absent ",(0,i.kt)("inlineCode",{parentName:"p"},"select")," waits for an unlimited amount of time.\nIt is also possible to proceed immediately if no channel is ready in the moment ",(0,i.kt)("inlineCode",{parentName:"p"},"select")," is called\nby adding an ",(0,i.kt)("inlineCode",{parentName:"p"},"else { ... }")," branch. ",(0,i.kt)("inlineCode",{parentName:"p"},"else")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"<timeout>")," are mutually exclusive."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"select")," command can be used as an ",(0,i.kt)("em",{parentName:"p"},"expression")," of type ",(0,i.kt)("inlineCode",{parentName:"p"},"bool"),"\nthat becomes ",(0,i.kt)("inlineCode",{parentName:"p"},"false")," if all channels are closed:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"wip",wip:!0},"if select {\n    ch <- a {\n        // ...\n    }\n} {\n    // channel was open\n} else {\n    // channel is closed\n}\n")),(0,i.kt)("h4",{id:"special-channel-features"},"Special Channel Features"),(0,i.kt)("p",null,"For special purposes there are some builtin fields and methods:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"struct Abc {\n    x int\n}\n\na := 2.13\nch := chan f64{}\nres := ch.try_push(a) // try to perform `ch <- a`\nprintln(res)\nl := ch.len // number of elements in queue\nc := ch.cap // maximum queue length\nis_closed := ch.closed // bool flag - has `ch` been closed\nprintln(l)\nprintln(c)\nmut b := Abc{}\nch2 := chan Abc{}\nres2 := ch2.try_pop(mut b) // try to perform `b = <-ch2`\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"try_push/pop()")," methods will return immediately with one of the results\n",(0,i.kt)("inlineCode",{parentName:"p"},".success"),", ",(0,i.kt)("inlineCode",{parentName:"p"},".not_ready")," or ",(0,i.kt)("inlineCode",{parentName:"p"},".closed")," - dependent on whether the object has been transferred or\nthe reason why not.\nUsage of these methods and fields in production is not recommended -\nalgorithms based on them are often subject to race conditions. Especially ",(0,i.kt)("inlineCode",{parentName:"p"},".len")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},".closed")," should not be used to make decisions.\nUse ",(0,i.kt)("inlineCode",{parentName:"p"},"or")," branches, error propagation or ",(0,i.kt)("inlineCode",{parentName:"p"},"select")," instead (see ",(0,i.kt)("a",{parentName:"p",href:"#syntax-and-usage"},"Syntax and Usage"),"\nand ",(0,i.kt)("a",{parentName:"p",href:"#channel-select"},"Channel Select")," above)."),(0,i.kt)("h3",{id:"shared-objects"},"Shared Objects"),(0,i.kt)("p",null,"Data can be exchanged between a thread and the calling thread via a shared variable.\nSuch variables should be created as ",(0,i.kt)("inlineCode",{parentName:"p"},"shared")," and passed to the thread as such, too.\nThe underlying ",(0,i.kt)("inlineCode",{parentName:"p"},"struct")," contains a hidden ",(0,i.kt)("em",{parentName:"p"},"mutex")," that allows locking concurrent access\nusing ",(0,i.kt)("inlineCode",{parentName:"p"},"rlock")," for read-only and ",(0,i.kt)("inlineCode",{parentName:"p"},"lock")," for read/write access."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"struct St {\nmut:\n    x int // data to be shared\n}\n\nfn (shared b St) g() {\n    lock b {\n        // read/modify/write b.x\n    }\n}\n\nfn main() {\n    shared a := St{\n        x: 10\n    }\n    go a.g()\n    // ...\n    rlock a {\n        // read a.x\n    }\n}\n")),(0,i.kt)("p",null,"Shared variables must be structs, arrays or maps."),(0,i.kt)("h2",{id:"json"},"JSON"),(0,i.kt)("p",null,"Because of the ubiquitous nature of JSON, support for it is built directly into V."),(0,i.kt)("p",null,"V generates code for JSON encoding and decoding.\nNo runtime reflection is used. This results in much better performance."),(0,i.kt)("h3",{id:"decoding-json"},"Decoding JSON"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},'import json\n\nstruct Foo {\n    x int\n}\n\nstruct User {\n    // Adding a [required] attribute will make decoding fail, if that\n    // field is not present in the input.\n    // If a field is not [required], but is missing, it will be assumed\n    // to have its default value, like 0 for numbers, or \'\' for strings,\n    // and decoding will not fail.\n    name string [required]\n    age  int\n    // Use the `skip` attribute to skip certain fields\n    foo Foo [skip]\n    // If the field name is different in JSON, it can be specified\n    last_name string [json: lastName]\n}\n\ndata := \'{ "name": "Frodo", "lastName": "Baggins", "age": 25 }\'\nuser := json.decode(User, data) or {\n    eprintln(\'Failed to decode json, error: $err\')\n    return\n}\nprintln(user.name)\nprintln(user.last_name)\nprintln(user.age)\n// You can also decode JSON arrays:\nsfoos := \'[{"x":123},{"x":456}]\'\nfoos := json.decode([]Foo, sfoos)?\nprintln(foos[0].x)\nprintln(foos[1].x)\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"json.decode")," function takes two arguments:\nthe first is the type into which the JSON value should be decoded and\nthe second is a string containing the JSON data."),(0,i.kt)("h3",{id:"encoding-json"},"Encoding JSON"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},'import json\n\nstruct User {\n    name  string\n    score i64\n}\n\nmut data := map[string]int{}\nuser := &User{\n    name: \'Pierre\'\n    score: 1024\n}\n\ndata[\'x\'] = 42\ndata[\'y\'] = 360\n\nprintln(json.encode(data)) // {"x":42,"y":360}\nprintln(json.encode(user)) // {"name":"Pierre","score":1024}\n')),(0,i.kt)("h2",{id:"testing"},"Testing"),(0,i.kt)("h3",{id:"asserts"},"Asserts"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"fn foo(mut v []int) {\n    v[0] = 1\n}\n\nmut v := [20]\nfoo(mut v)\nassert v[0] < 4\n")),(0,i.kt)("p",null,"An ",(0,i.kt)("inlineCode",{parentName:"p"},"assert")," statement checks that its expression evaluates to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),". If an assert fails,\nthe program will abort. Asserts should only be used to detect programming errors. When an\nassert fails it is reported to ",(0,i.kt)("em",{parentName:"p"},"stderr"),", and the values on each side of a comparison operator\n(such as ",(0,i.kt)("inlineCode",{parentName:"p"},"<"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"=="),") will be printed when possible. This is useful to easily find an\nunexpected value. Assert statements can be used in any function."),(0,i.kt)("h3",{id:"asserts-with-an-extra-message"},"Asserts with an extra message"),(0,i.kt)("p",null,"This form of the ",(0,i.kt)("inlineCode",{parentName:"p"},"assert")," statement, will print the extra message when it fails. Note, that\nyou can use any string expression there - string literals, functions returning a string,\nstrings that interpolate variables, etc."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"fn test_assertion_with_extra_message_failure() {\n    for i in 0 .. 100 {\n        assert i * 2 - 45 < 75 + 10, 'assertion failed for i: $i'\n    }\n}\n")),(0,i.kt)("h3",{id:"test-files"},"Test files"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"// hello.v\nmodule main\n\nfn hello() string {\n    return 'Hello world'\n}\n\nfn main() {\n    println(hello())\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"failcompile",failcompile:!0},"// hello_test.v\nmodule main\n\nfn test_hello() {\n    assert hello() == 'Hello world'\n}\n")),(0,i.kt)("p",null,"To run the test above, use ",(0,i.kt)("inlineCode",{parentName:"p"},"v hello_test.v"),". This will check that the function ",(0,i.kt)("inlineCode",{parentName:"p"},"hello")," is\nproducing the correct output. V executes all test functions in the file."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"All test functions have to be inside a test file whose name ends in ",(0,i.kt)("inlineCode",{parentName:"li"},"_test.v"),"."),(0,i.kt)("li",{parentName:"ul"},"Test function names must begin with ",(0,i.kt)("inlineCode",{parentName:"li"},"test_")," to mark them for execution."),(0,i.kt)("li",{parentName:"ul"},"Normal functions can also be defined in test files, and should be called manually. Other\nsymbols can also be defined in test files e.g. types."),(0,i.kt)("li",{parentName:"ul"},"There are two kinds of tests: external and internal."),(0,i.kt)("li",{parentName:"ul"},"Internal tests must ",(0,i.kt)("em",{parentName:"li"},"declare")," their module, just like all other .v\nfiles from the same module. Internal tests can even call private functions in\nthe same module."),(0,i.kt)("li",{parentName:"ul"},"External tests must ",(0,i.kt)("em",{parentName:"li"},"import")," the modules which they test. They do not\nhave access to the private functions/types of the modules. They can test only\nthe external/public API that a module provides.")),(0,i.kt)("p",null,"In the example above, ",(0,i.kt)("inlineCode",{parentName:"p"},"test_hello")," is an internal test, that can call\nthe private function ",(0,i.kt)("inlineCode",{parentName:"p"},"hello()")," because ",(0,i.kt)("inlineCode",{parentName:"p"},"hello_test.v")," has ",(0,i.kt)("inlineCode",{parentName:"p"},"module main"),",\njust like ",(0,i.kt)("inlineCode",{parentName:"p"},"hello.v"),", i.e. both are part of the same module. Note also that\nsince ",(0,i.kt)("inlineCode",{parentName:"p"},"module main")," is a regular module like the others, internal tests can\nbe used to test private functions in your main program .v files too."),(0,i.kt)("p",null,"You can also define these special test functions in a test file:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"testsuite_begin")," which will be run ",(0,i.kt)("em",{parentName:"li"},"before")," all other test functions."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"testsuite_end")," which will be run ",(0,i.kt)("em",{parentName:"li"},"after")," all other test functions.")),(0,i.kt)("p",null,"If a test function has an error return type, any propagated errors will fail the test:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"import strconv\n\nfn test_atoi() ? {\n    assert strconv.atoi('1')? == 1\n    assert strconv.atoi('one')? == 1 // test will fail\n}\n")),(0,i.kt)("h4",{id:"running-tests"},"Running tests"),(0,i.kt)("p",null,"To run test functions in an individual test file, use ",(0,i.kt)("inlineCode",{parentName:"p"},"v foo_test.v"),"."),(0,i.kt)("p",null,"To test an entire module, use ",(0,i.kt)("inlineCode",{parentName:"p"},"v test mymodule"),". You can also use ",(0,i.kt)("inlineCode",{parentName:"p"},"v test .")," to test\neverything inside your current folder (and subfolders). You can pass the ",(0,i.kt)("inlineCode",{parentName:"p"},"-stats"),"\noption to see more details about the individual tests run."),(0,i.kt)("p",null,"You can put additional test data, including .v source files in a folder, named\n",(0,i.kt)("inlineCode",{parentName:"p"},"testdata"),", right next to your _test.v files. V's test framework will ",(0,i.kt)("em",{parentName:"p"},"ignore"),"\nsuch folders, while scanning for tests to run. This is useful, if you want to\nput .v files with invalid V source code, or other tests, including known\nfailing ones, that should be run in a specific way/options by a parent _test.v\nfile."),(0,i.kt)("p",null,"NB: the path to the V compiler, is available through @VEXE, so a _test.v\nfile, can easily run ",(0,i.kt)("em",{parentName:"p"},"other")," test files like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"oksyntax",oksyntax:!0},"import os\n\nfn test_subtest() {\n    res := os.execute('${os.quoted_path(@VEXE)} other_test.v')\n    assert res.exit_code == 1\n    assert res.output.contains('other_test.v does not exist')\n}\n")),(0,i.kt)("h2",{id:"memory-management"},"Memory management"),(0,i.kt)("p",null,"V avoids doing unnecessary allocations in the first place by using value types,\nstring buffers, promoting a simple abstraction-free code style."),(0,i.kt)("p",null,"Most objects (~90-100%) are freed by V's autofree engine: the compiler inserts\nnecessary free calls automatically during compilation. Remaining small percentage\nof objects is freed via reference counting."),(0,i.kt)("p",null,"The developer doesn't need to change anything in their code. \"It just works\", like in\nPython, Go, or Java, except there's no heavy GC tracing everything or expensive RC for\neach object."),(0,i.kt)("h3",{id:"control"},"Control"),(0,i.kt)("p",null,"You can take advantage of V's autofree engine and define a ",(0,i.kt)("inlineCode",{parentName:"p"},"free()")," method on custom\ndata types:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"struct MyType {}\n\n[unsafe]\nfn (data &MyType) free() {\n    // ...\n}\n")),(0,i.kt)("p",null,"Just as the compiler frees C data types with C's ",(0,i.kt)("inlineCode",{parentName:"p"},"free()"),", it will statically insert\n",(0,i.kt)("inlineCode",{parentName:"p"},"free()")," calls for your data type at the end of each variable's lifetime."),(0,i.kt)("p",null,"Autofree can be enabled with an ",(0,i.kt)("inlineCode",{parentName:"p"},"-autofree")," flag."),(0,i.kt)("p",null,"For developers willing to have more low level control, autofree can be disabled with\n",(0,i.kt)("inlineCode",{parentName:"p"},"-manualfree"),", or by adding a ",(0,i.kt)("inlineCode",{parentName:"p"},"[manualfree]")," on each function that wants manage its\nmemory manually. (See ",(0,i.kt)("a",{parentName:"p",href:"#attributes"},"attributes"),")."),(0,i.kt)("p",null,"Note 2: Autofree is still WIP. Until it stabilises and becomes the default, please\navoid using it. Right now allocations are handled by a minimal and well performing GC\nuntil V's autofree engine is production ready."),(0,i.kt)("h3",{id:"examples"},"Examples"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"import strings\n\nfn draw_text(s string, x int, y int) {\n    // ...\n}\n\nfn draw_scene() {\n    // ...\n    name1 := 'abc'\n    name2 := 'def ghi'\n    draw_text('hello $name1', 10, 10)\n    draw_text('hello $name2', 100, 10)\n    draw_text(strings.repeat(`X`, 10000), 10, 50)\n    // ...\n}\n")),(0,i.kt)("p",null,"The strings don't escape ",(0,i.kt)("inlineCode",{parentName:"p"},"draw_text"),", so they are cleaned up when\nthe function exits."),(0,i.kt)("p",null,"In fact, with the ",(0,i.kt)("inlineCode",{parentName:"p"},"-prealloc")," flag, the first two calls won't result in any allocations at all.\nThese two strings are small, so V will use a preallocated buffer for them."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"struct User {\n    name string\n}\n\nfn test() []int {\n    number := 7 // stack variable\n    user := User{} // struct allocated on stack\n    numbers := [1, 2, 3] // array allocated on heap, will be freed as the function exits\n    println(number)\n    println(user)\n    println(numbers)\n    numbers2 := [4, 5, 6] // array that's being returned, won't be freed here\n    return numbers2\n}\n")),(0,i.kt)("h3",{id:"stack-and-heap"},"Stack and Heap"),(0,i.kt)("h4",{id:"stack-and-heap-basics"},"Stack and Heap Basics"),(0,i.kt)("p",null,"Like with most other programming languages there are two locations where data can\nbe stored:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("em",{parentName:"li"},"stack")," allows fast allocations with almost zero administrative overhead. The\nstack grows and shrinks with the function call depth ","\u2013"," so every called\nfunction has its stack segment that remains valid until the function returns.\nNo freeing is necessary, however, this also means that a reference to a stack\nobject becomes invalid on function return. Furthermore stack space is\nlimited (typically to a few Megabytes per thread)."),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("em",{parentName:"li"},"heap")," is a large memory area (typically some Gigabytes) that is administrated\nby the operating system. Heap objects are allocated and freed by special function\ncalls that delegate the administrative tasks to the OS. This means that they can\nremain valid across several function calls, however, the administration is\nexpensive.")),(0,i.kt)("h4",{id:"vs-default-approach"},"V's default approach"),(0,i.kt)("p",null,"Due to performance considerations V tries to put objects on the stack if possible\nbut allocates them on the heap when obviously necessary. Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"struct MyStruct {\n    n int\n}\n\nstruct RefStruct {\n    r &MyStruct\n}\n\nfn main() {\n    q, w := f()\n    println('q: $q.r.n, w: $w.n')\n}\n\nfn f() (RefStruct, &MyStruct) {\n    a := MyStruct{\n        n: 1\n    }\n    b := MyStruct{\n        n: 2\n    }\n    c := MyStruct{\n        n: 3\n    }\n    e := RefStruct{\n        r: &b\n    }\n    x := a.n + c.n\n    println('x: $x')\n    return e, &c\n}\n")),(0,i.kt)("p",null,"Here ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," is stored on the stack since it's address never leaves the function ",(0,i.kt)("inlineCode",{parentName:"p"},"f()"),".\nHowever a reference to ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," is part of ",(0,i.kt)("inlineCode",{parentName:"p"},"e")," which is returned. Also a reference to\n",(0,i.kt)("inlineCode",{parentName:"p"},"c")," is returned. For this reason ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"c")," will be heap allocated."),(0,i.kt)("p",null,"Things become less obvious when a reference to an object is passed as function argument:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"struct MyStruct {\nmut:\n    n int\n}\n\nfn main() {\n    mut q := MyStruct{\n        n: 7\n    }\n    w := MyStruct{\n        n: 13\n    }\n    x := q.f(&w) // references of `q` and `w` are passed\n    println('q: $q\\nx: $x')\n}\n\nfn (mut a MyStruct) f(b &MyStruct) int {\n    a.n += b.n\n    x := a.n * b.n\n    return x\n}\n")),(0,i.kt)("p",null,"Here the call ",(0,i.kt)("inlineCode",{parentName:"p"},"q.f(&w)")," passes references to ",(0,i.kt)("inlineCode",{parentName:"p"},"q")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"w")," because ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," is\n",(0,i.kt)("inlineCode",{parentName:"p"},"mut")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," is of type ",(0,i.kt)("inlineCode",{parentName:"p"},"&MyStruct")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"f()"),"'s declaration, so technically\nthese references are leaving ",(0,i.kt)("inlineCode",{parentName:"p"},"main()"),". However the ",(0,i.kt)("em",{parentName:"p"},"lifetime")," of these\nreferences lies inside the scope of ",(0,i.kt)("inlineCode",{parentName:"p"},"main()")," so ",(0,i.kt)("inlineCode",{parentName:"p"},"q")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"w")," are allocated\non the stack."),(0,i.kt)("h4",{id:"manual-control-for-stack-and-heap"},"Manual Control for Stack and Heap"),(0,i.kt)("p",null,"In the last example the V compiler could put ",(0,i.kt)("inlineCode",{parentName:"p"},"q")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"w")," on the stack\nbecause it assumed that in the call ",(0,i.kt)("inlineCode",{parentName:"p"},"q.f(&w)")," these references were only\nused for reading and modifying the referred values ","\u2013"," and not to pass the\nreferences themselves somewhere else. This can be seen in a way that the\nreferences to ",(0,i.kt)("inlineCode",{parentName:"p"},"q")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"w")," are only ",(0,i.kt)("em",{parentName:"p"},"borrowed")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"f()"),"."),(0,i.kt)("p",null,"Things become different if ",(0,i.kt)("inlineCode",{parentName:"p"},"f()")," is doing something with a reference itself:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"struct RefStruct {\nmut:\n    r &MyStruct\n}\n\n// see discussion below\n[heap]\nstruct MyStruct {\n    n int\n}\n\nfn main() {\n    m := MyStruct{}\n    mut r := RefStruct{\n        r: &m\n    }\n    r.g()\n    println('r: $r')\n}\n\nfn (mut r RefStruct) g() {\n    s := MyStruct{\n        n: 7\n    }\n    r.f(&s) // reference to `s` inside `r` is passed back to `main() `\n}\n\nfn (mut r RefStruct) f(s &MyStruct) {\n    r.r = s // would trigger error without `[heap]`\n}\n")),(0,i.kt)("p",null,"Here ",(0,i.kt)("inlineCode",{parentName:"p"},"f()")," looks quite innocent but is doing nasty things ","\u2013"," it inserts a\nreference to ",(0,i.kt)("inlineCode",{parentName:"p"},"s")," into ",(0,i.kt)("inlineCode",{parentName:"p"},"r"),". The problem with this is that ",(0,i.kt)("inlineCode",{parentName:"p"},"s")," lives only as long\nas ",(0,i.kt)("inlineCode",{parentName:"p"},"g()")," is running but ",(0,i.kt)("inlineCode",{parentName:"p"},"r")," is used in ",(0,i.kt)("inlineCode",{parentName:"p"},"main()")," after that. For this reason\nthe compiler would complain about the assignment in ",(0,i.kt)("inlineCode",{parentName:"p"},"f()")," because ",(0,i.kt)("inlineCode",{parentName:"p"},"s")," ",(0,i.kt)("em",{parentName:"p"},'"might\nrefer to an object stored on stack"'),". The assumption made in ",(0,i.kt)("inlineCode",{parentName:"p"},"g()")," that the call\n",(0,i.kt)("inlineCode",{parentName:"p"},"r.f(&s)")," would only borrow the reference to ",(0,i.kt)("inlineCode",{parentName:"p"},"s")," is wrong."),(0,i.kt)("p",null,"A solution to this dilemma is the ",(0,i.kt)("inlineCode",{parentName:"p"},"[heap]")," attribute at the declaration of\n",(0,i.kt)("inlineCode",{parentName:"p"},"struct MyStruct"),". It instructs the compiler to ",(0,i.kt)("em",{parentName:"p"},"always")," allocate ",(0,i.kt)("inlineCode",{parentName:"p"},"MyStruct"),"-objects\non the heap. This way the reference to ",(0,i.kt)("inlineCode",{parentName:"p"},"s")," remains valid even after ",(0,i.kt)("inlineCode",{parentName:"p"},"g()")," returns.\nThe compiler takes into consideration that ",(0,i.kt)("inlineCode",{parentName:"p"},"MyStruct")," objects are always heap\nallocated when checking ",(0,i.kt)("inlineCode",{parentName:"p"},"f()")," and allows assigning the reference to ",(0,i.kt)("inlineCode",{parentName:"p"},"s")," to the\n",(0,i.kt)("inlineCode",{parentName:"p"},"r.r")," field."),(0,i.kt)("p",null,"There is a pattern often seen in other programming languages:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"failcompile",failcompile:!0},"fn (mut a MyStruct) f() &MyStruct {\n    // do something with a\n    return &a // would return address of borrowed object\n}\n")),(0,i.kt)("p",null,"Here ",(0,i.kt)("inlineCode",{parentName:"p"},"f()")," is passed a reference ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," as receiver that is passed back to the caller and returned\nas result at the same time. The intention behind such a declaration is method chaining like\n",(0,i.kt)("inlineCode",{parentName:"p"},"y = x.f().g()"),". However, the problem with this approach is that a second reference\nto ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," is created ","\u2013"," so it is not only borrowed and ",(0,i.kt)("inlineCode",{parentName:"p"},"MyStruct")," has to be\ndeclared as ",(0,i.kt)("inlineCode",{parentName:"p"},"[heap]"),"."),(0,i.kt)("p",null,"In V the better approach is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"struct MyStruct {\nmut:\n    n int\n}\n\nfn (mut a MyStruct) f() {\n    // do something with `a`\n}\n\nfn (mut a MyStruct) g() {\n    // do something else with `a`\n}\n\nfn main() {\n    x := MyStruct{} // stack allocated\n    mut y := x\n    y.f()\n    y.g()\n    // instead of `mut y := x.f().g()\n}\n")),(0,i.kt)("p",null,"This way the ",(0,i.kt)("inlineCode",{parentName:"p"},"[heap]")," attribute can be avoided ","\u2013"," resulting in better performance."),(0,i.kt)("p",null,"However, stack space is very limited as mentioned above. For this reason the ",(0,i.kt)("inlineCode",{parentName:"p"},"[heap]"),"\nattribute might be suitable for very large structures even if not required by use cases\nlike those mentioned above."),(0,i.kt)("p",null,"There is an alternative way to manually control allocation on a case to case basis. This\napproach is not recommended but shown here for the sake of completeness:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"struct MyStruct {\n    n int\n}\n\nstruct RefStruct {\nmut:\n    r &MyStruct\n}\n\n// simple function - just to overwrite stack segment previously used by `g()`\nfn use_stack() {\n    x := 7.5\n    y := 3.25\n    z := x + y\n    println('$x $y $z')\n}\n\nfn main() {\n    m := MyStruct{}\n    mut r := RefStruct{\n        r: &m\n    }\n    r.g()\n    use_stack() // to erase invalid stack contents\n    println('r: $r')\n}\n\nfn (mut r RefStruct) g() {\n    s := &MyStruct{ // `s` explicitly refers to a heap object\n        n: 7\n    }\n    // change `&MyStruct` -> `MyStruct` above and `r.f(s)` -> `r.f(&s)` below\n    // to see data in stack segment being overwritten\n    r.f(s)\n}\n\nfn (mut r RefStruct) f(s &MyStruct) {\n    r.r = unsafe { s } // override compiler check\n}\n")),(0,i.kt)("p",null,"Here the compiler check is suppressed by the ",(0,i.kt)("inlineCode",{parentName:"p"},"unsafe")," block. To make ",(0,i.kt)("inlineCode",{parentName:"p"},"s")," be heap\nallocated even without ",(0,i.kt)("inlineCode",{parentName:"p"},"[heap]")," attribute the ",(0,i.kt)("inlineCode",{parentName:"p"},"struct")," literal is prefixed with\nan ampersand: ",(0,i.kt)("inlineCode",{parentName:"p"},"&MyStruct{...}"),"."),(0,i.kt)("p",null,"This last step would not be required by the compiler but without it the reference\ninside ",(0,i.kt)("inlineCode",{parentName:"p"},"r")," becomes invalid (the memory area pointed to will be overwritten by\n",(0,i.kt)("inlineCode",{parentName:"p"},"use_stack()"),") and the program might crash (or at least produce an unpredictable\nfinal output). That's why this approach is ",(0,i.kt)("em",{parentName:"p"},"unsafe")," and should be avoided!"),(0,i.kt)("h2",{id:"orm"},"ORM"),(0,i.kt)("p",null,"(This is still in an alpha state)"),(0,i.kt)("p",null,"V has a built-in ORM (object-relational mapping) which supports SQLite, MySQL and Postgres,\nbut soon it will support MS SQL and Oracle."),(0,i.kt)("p",null,"V's ORM provides a number of benefits:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"One syntax for all SQL dialects. (Migrating between databases becomes much easier.)"),(0,i.kt)("li",{parentName:"ul"},"Queries are constructed using V's syntax. (There's no need to learn another syntax.)"),(0,i.kt)("li",{parentName:"ul"},"Safety. (All queries are automatically sanitised to prevent SQL injection.)"),(0,i.kt)("li",{parentName:"ul"},"Compile time checks. (This prevents typos which can only be caught during runtime.)"),(0,i.kt)("li",{parentName:"ul"},"Readability and simplicity. (You don't need to manually parse the results of a query and\nthen manually construct objects from the parsed results.)")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"import sqlite\n\n// sets a custom table name. Default is struct name (case-sensitive)\n[table: 'customers']\nstruct Customer {\n    id        int    [primary; sql: serial] // a field named `id` of integer type must be the first field\n    name      string [nonull]\n    nr_orders int\n    country   string [nonull]\n}\n\ndb := sqlite.connect('customers.db')?\n\n// you can create tables:\n// CREATE TABLE IF NOT EXISTS `Customer` (\n//      `id` INTEGER PRIMARY KEY,\n//      `name` TEXT NOT NULL,\n//      `nr_orders` INTEGER,\n//      `country` TEXT NOT NULL\n// )\nsql db {\n    create table Customer\n}\n\n// select count(*) from customers\nnr_customers := sql db {\n    select count from Customer\n}\nprintln('number of all customers: $nr_customers')\n// V syntax can be used to build queries\nuk_customers := sql db {\n    select from Customer where country == 'uk' && nr_orders > 0\n}\nprintln(uk_customers.len)\nfor customer in uk_customers {\n    println('$customer.id - $customer.name')\n}\n// by adding `limit 1` we tell V that there will be only one object\ncustomer := sql db {\n    select from Customer where id == 1 limit 1\n}\nprintln('$customer.id - $customer.name')\n// insert a new customer\nnew_customer := Customer{\n    name: 'Bob'\n    nr_orders: 10\n}\nsql db {\n    insert new_customer into Customer\n}\n")),(0,i.kt)("p",null,"For more examples and the docs, see ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/vlang/v/tree/master/vlib/orm"},"vlib/orm"),"."),(0,i.kt)("h2",{id:"writing-documentation"},"Writing Documentation"),(0,i.kt)("p",null,"The way it works is very similar to Go. It's very simple: there's no need to\nwrite documentation separately for your code,\nvdoc will generate it from docstrings in the source code."),(0,i.kt)("p",null,"Documentation for each function/type/const must be placed right before the declaration:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"// clearall clears all bits in the array\nfn clearall() {\n}\n")),(0,i.kt)("p",null,"The comment must start with the name of the definition."),(0,i.kt)("p",null,"Sometimes one line isn't enough to explain what a function does, in that case comments should\nspan to the documented function using single line comments:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"// copy_all recursively copies all elements of the array by their value,\n// if `dupes` is false all duplicate values are eliminated in the process.\nfn copy_all(dupes bool) {\n    // ...\n}\n")),(0,i.kt)("p",null,"By convention it is preferred that comments are written in ",(0,i.kt)("em",{parentName:"p"},"present tense"),"."),(0,i.kt)("p",null,"An overview of the module must be placed in the first comment right after the module's name."),(0,i.kt)("p",null,"To generate documentation use vdoc, for example ",(0,i.kt)("inlineCode",{parentName:"p"},"v doc net.http"),"."),(0,i.kt)("h3",{id:"newlines-in-documentation-comments"},"Newlines in Documentation Comments"),(0,i.kt)("p",null,"Comments spanning multiple lines are merged together using spaces, unless"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"the line is empty"),(0,i.kt)("li",{parentName:"ul"},"the line ends with a ",(0,i.kt)("inlineCode",{parentName:"li"},".")," (end of sentence)"),(0,i.kt)("li",{parentName:"ul"},"the line is purely of at least 3 of ",(0,i.kt)("inlineCode",{parentName:"li"},"-"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"="),", ",(0,i.kt)("inlineCode",{parentName:"li"},"_"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"*"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"~")," (horizontal rule)"),(0,i.kt)("li",{parentName:"ul"},"the line starts with at least one ",(0,i.kt)("inlineCode",{parentName:"li"},"#")," followed by a space (header)"),(0,i.kt)("li",{parentName:"ul"},"the line starts and ends with a ",(0,i.kt)("inlineCode",{parentName:"li"},"|")," (table)"),(0,i.kt)("li",{parentName:"ul"},"the line starts with ",(0,i.kt)("inlineCode",{parentName:"li"},"- ")," (list)")),(0,i.kt)("h2",{id:"tools"},"Tools"),(0,i.kt)("h3",{id:"v-fmt"},"v fmt"),(0,i.kt)("p",null,"You don't need to worry about formatting your code or setting style guidelines.\n",(0,i.kt)("inlineCode",{parentName:"p"},"v fmt")," takes care of that:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"v fmt file.v\n")),(0,i.kt)("p",null,"It's recommended to set up your editor, so that ",(0,i.kt)("inlineCode",{parentName:"p"},"v fmt -w")," runs on every save.\nA vfmt run is usually pretty cheap (takes <30ms)."),(0,i.kt)("p",null,"Always run ",(0,i.kt)("inlineCode",{parentName:"p"},"v fmt -w file.v")," before pushing your code."),(0,i.kt)("h3",{id:"v-shader"},"v shader"),(0,i.kt)("p",null,"You can use GPU shaders with V graphical apps. You write your shaders in an\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/vlang/v/blob/1d8ece7/examples/sokol/02_cubes_glsl/cube_glsl.glsl"},"annotated GLSL dialect"),"\nand use ",(0,i.kt)("inlineCode",{parentName:"p"},"v shader")," to compile them for all supported target platforms."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"v shader /path/to/project/dir/or/file.v\n")),(0,i.kt)("p",null,"Currently you need to ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/vlang/v/blob/c14c324/examples/sokol/02_cubes_glsl/cube_glsl.v#L43-L46"},"include a header and declare a glue function")," before\nusing the shader in your code."),(0,i.kt)("h3",{id:"profiling"},"Profiling"),(0,i.kt)("p",null,"V has good support for profiling your programs: ",(0,i.kt)("inlineCode",{parentName:"p"},"v -profile profile.txt run file.v"),"\nThat will produce a profile.txt file, which you can then analyze."),(0,i.kt)("p",null,"The generated profile.txt file will have lines with 4 columns:\na) how many times a function was called\nb) how much time in total a function took (in ms)\nc) how much time on average, a call to a function took (in ns)\nd) the name of the v function"),(0,i.kt)("p",null,"You can sort on column 3 (average time per function) using:\n",(0,i.kt)("inlineCode",{parentName:"p"},"sort -n -k3 profile.txt|tail")),(0,i.kt)("p",null,"You can also use stopwatches to measure just portions of your code explicitly:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"import time\n\nfn main() {\n    sw := time.new_stopwatch()\n    println('Hello world')\n    println('Greeting the world took: ${sw.elapsed().nanoseconds()}ns')\n}\n")),(0,i.kt)("h2",{id:"package-management"},"Package management"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-powershell"},"v [module option] [param]\n")),(0,i.kt)("h6",{id:"module-options"},"module options:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"   install           Install a module from VPM.\n   remove            Remove a module that was installed from VPM.\n   search            Search for a module from VPM.\n   update            Update an installed module from VPM.\n   upgrade           Upgrade all the outdated modules.\n   list              List all installed modules.\n   outdated          Show installed modules that need updates.\n")),(0,i.kt)("p",null,"You can install modules already created by someone else with ",(0,i.kt)("a",{parentName:"p",href:"https://vpm.vlang.io/"},"VPM"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-powershell"},"v install [module]\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-powershell"},"v install ui\n")),(0,i.kt)("p",null,"Modules can be installed directly from git or mercurial repositories."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-powershell"},"v install [--once] [--git|--hg] [url]\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-powershell"},"v install --git https://github.com/vlang/markdown\n")),(0,i.kt)("p",null,"Sometimes you may want to install the dependencies ",(0,i.kt)("strong",{parentName:"p"},"ONLY")," if those are not installed:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"v install --once [module]\n")),(0,i.kt)("p",null,"Removing a module with v:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-powershell"},"v remove [module]\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-powershell"},"v remove ui\n")),(0,i.kt)("p",null,"Updating an installed module from ",(0,i.kt)("a",{parentName:"p",href:"https://vpm.vlang.io/"},"VPM"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-powershell"},"v update [module]\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-powershell"},"v update ui\n")),(0,i.kt)("p",null,"Or you can update all your modules:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-powershell"},"v update\n")),(0,i.kt)("p",null,"To see all the modules you have installed, you can use:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-powershell"},"v list\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-powershell"},"> v list\nInstalled modules:\n  markdown\n  ui\n")),(0,i.kt)("p",null,"To see all the modules that need updates:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-powershell"},"v outdated\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-powershell"},"> v outdated\nModules are up to date.\n")),(0,i.kt)("h3",{id:"publish-package"},"Publish package"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Put a ",(0,i.kt)("inlineCode",{parentName:"p"},"v.mod")," file inside the toplevel folder of your module (if you\ncreated your module with the command ",(0,i.kt)("inlineCode",{parentName:"p"},"v new mymodule")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"v init")," you already have a v.mod file)."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sh"},"v new mymodule\nInput your project description: My nice module.\nInput your project version: (0.0.0) 0.0.1\nInput your project license: (MIT)\nInitialising ...\nComplete!\n")),(0,i.kt)("p",{parentName:"li"},"Example ",(0,i.kt)("inlineCode",{parentName:"p"},"v.mod"),":"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"ignore",ignore:!0},"Module {\n    name: 'mymodule'\n    description: 'My nice module.'\n    version: '0.0.1'\n    license: 'MIT'\n    dependencies: []\n}\n")),(0,i.kt)("p",{parentName:"li"},"Minimal file structure:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"v.mod\nmymodule.v\n")),(0,i.kt)("p",{parentName:"li"},"The name of your module should be used with the ",(0,i.kt)("inlineCode",{parentName:"p"},"module")," directive\nat the top of all files in your module. For ",(0,i.kt)("inlineCode",{parentName:"p"},"mymodule.v"),":"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-v"},"module mymodule\n\npub fn hello_world() {\n    println('Hello World!')\n}\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Create a git repository in the folder with the ",(0,i.kt)("inlineCode",{parentName:"p"},"v.mod")," file\n(this is not required if you used ",(0,i.kt)("inlineCode",{parentName:"p"},"v new")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"v init"),"):"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sh"},'git init\ngit add .\ngit commit -m "INIT"\n'))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Create a public repository on github.com.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Connect your local repository to the remote repository and push the changes.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Add your module to the public V module registry VPM:\n",(0,i.kt)("a",{parentName:"p",href:"https://vpm.vlang.io/new"},"https://vpm.vlang.io/new")),(0,i.kt)("p",{parentName:"li"},"You will have to login with your Github account to register the module.\n",(0,i.kt)("strong",{parentName:"p"},"Warning:")," ",(0,i.kt)("em",{parentName:"p"},"Currently it is not possible to edit your entry after submitting.\nCheck your module name and github url twice as this cannot be changed by you later."))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"The final module name is a combination of your github account and\nthe module name you provided e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"mygithubname.mymodule"),"."))),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Optional:")," tag your V module with ",(0,i.kt)("inlineCode",{parentName:"p"},"vlang")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"vlang-module")," on github.com\nto allow for a better search experience."),(0,i.kt)("h1",{id:"advanced-topics"},"Advanced Topics"),(0,i.kt)("h2",{id:"memory-unsafe-code"},"Memory-unsafe code"),(0,i.kt)("p",null,"Sometimes for efficiency you may want to write low-level code that can potentially\ncorrupt memory or be vulnerable to security exploits. V supports writing such code,\nbut not by default."),(0,i.kt)("p",null,"V requires that any potentially memory-unsafe operations are marked intentionally.\nMarking them also indicates to anyone reading the code that there could be\nmemory-safety violations if there was a mistake."),(0,i.kt)("p",null,"Examples of potentially memory-unsafe operations are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Pointer arithmetic"),(0,i.kt)("li",{parentName:"ul"},"Pointer indexing"),(0,i.kt)("li",{parentName:"ul"},"Conversion to pointer from an incompatible type"),(0,i.kt)("li",{parentName:"ul"},"Calling certain C functions, e.g. ",(0,i.kt)("inlineCode",{parentName:"li"},"free"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"strlen")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"strncmp"),".")),(0,i.kt)("p",null,"To mark potentially memory-unsafe operations, enclose them in an ",(0,i.kt)("inlineCode",{parentName:"p"},"unsafe")," block:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"wip",wip:!0},"// allocate 2 uninitialized bytes & return a reference to them\nmut p := unsafe { malloc(2) }\np[0] = `h` // Error: pointer indexing is only allowed in `unsafe` blocks\nunsafe {\n    p[0] = `h` // OK\n    p[1] = `i`\n}\np++ // Error: pointer arithmetic is only allowed in `unsafe` blocks\nunsafe {\n    p++ // OK\n}\nassert *p == `i`\n")),(0,i.kt)("p",null,"Best practice is to avoid putting memory-safe expressions inside an ",(0,i.kt)("inlineCode",{parentName:"p"},"unsafe")," block,\nso that the reason for using ",(0,i.kt)("inlineCode",{parentName:"p"},"unsafe")," is as clear as possible. Generally any code\nyou think is memory-safe should not be inside an ",(0,i.kt)("inlineCode",{parentName:"p"},"unsafe")," block, so the compiler\ncan verify it."),(0,i.kt)("p",null,"If you suspect your program does violate memory-safety, you have a head start on\nfinding the cause: look at the ",(0,i.kt)("inlineCode",{parentName:"p"},"unsafe")," blocks (and how they interact with\nsurrounding code)."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Note: This is work in progress.")),(0,i.kt)("h2",{id:"structs-with-reference-fields"},"Structs with reference fields"),(0,i.kt)("p",null,"Structs with references require explicitly setting the initial value to a\nreference value unless the struct already defines its own initial value."),(0,i.kt)("p",null,"Zero-value references, or nil pointers, will ",(0,i.kt)("strong",{parentName:"p"},"NOT")," be supported in the future,\nfor now data structures such as Linked Lists or Binary Trees that rely on reference\nfields that can use the value ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),", understanding that it is unsafe, and that it can\ncause a panic."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"struct Node {\n    a &Node\n    b &Node = 0 // Auto-initialized to nil, use with caution!\n}\n\n// Reference fields must be initialized unless an initial value is declared.\n// Zero (0) is OK but use with caution, it's a nil pointer.\nfoo := Node{\n    a: 0\n}\nbar := Node{\n    a: &foo\n}\nbaz := Node{\n    a: 0\n    b: 0\n}\nqux := Node{\n    a: &foo\n    b: &bar\n}\nprintln(baz)\nprintln(qux)\n")),(0,i.kt)("h2",{id:"sizeof-and-__offsetof"},"sizeof and __offsetof"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"sizeof(Type)")," gives the size of a type in bytes."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"__offsetof(Struct, field_name)")," gives the offset in bytes of a struct field.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"struct Foo {\n    a int\n    b int\n}\n\nassert sizeof(Foo) == 8\nassert __offsetof(Foo, a) == 0\nassert __offsetof(Foo, b) == 4\n")),(0,i.kt)("h2",{id:"calling-c-from-v"},"Calling C from V"),(0,i.kt)("h3",{id:"example"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"#flag -lsqlite3\n#include \"sqlite3.h\"\n// See also the example from https://www.sqlite.org/quickstart.html\nstruct C.sqlite3 {\n}\n\nstruct C.sqlite3_stmt {\n}\n\ntype FnSqlite3Callback = fn (voidptr, int, &&char, &&char) int\n\nfn C.sqlite3_open(&char, &&C.sqlite3) int\n\nfn C.sqlite3_close(&C.sqlite3) int\n\nfn C.sqlite3_column_int(stmt &C.sqlite3_stmt, n int) int\n\n// ... you can also just define the type of parameter and leave out the C. prefix\nfn C.sqlite3_prepare_v2(&C.sqlite3, &char, int, &&C.sqlite3_stmt, &&char) int\n\nfn C.sqlite3_step(&C.sqlite3_stmt)\n\nfn C.sqlite3_finalize(&C.sqlite3_stmt)\n\nfn C.sqlite3_exec(db &C.sqlite3, sql &char, cb FnSqlite3Callback, cb_arg voidptr, emsg &&char) int\n\nfn C.sqlite3_free(voidptr)\n\nfn my_callback(arg voidptr, howmany int, cvalues &&char, cnames &&char) int {\n    unsafe {\n        for i in 0 .. howmany {\n            print('| ${cstring_to_vstring(cnames[i])}: ${cstring_to_vstring(cvalues[i]):20} ')\n        }\n    }\n    println('|')\n    return 0\n}\n\nfn main() {\n    db := &C.sqlite3(0) // this means `sqlite3* db = 0`\n    // passing a string literal to a C function call results in a C string, not a V string\n    C.sqlite3_open(c'users.db', &db)\n    // C.sqlite3_open(db_path.str, &db)\n    query := 'select count(*) from users'\n    stmt := &C.sqlite3_stmt(0)\n    // NB: you can also use the `.str` field of a V string,\n    // to get its C style zero terminated representation\n    C.sqlite3_prepare_v2(db, &char(query.str), -1, &stmt, 0)\n    C.sqlite3_step(stmt)\n    nr_users := C.sqlite3_column_int(stmt, 0)\n    C.sqlite3_finalize(stmt)\n    println('There are $nr_users users in the database.')\n    //\n    error_msg := &char(0)\n    query_all_users := 'select * from users'\n    rc := C.sqlite3_exec(db, &char(query_all_users.str), my_callback, voidptr(7), &error_msg)\n    if rc != C.SQLITE_OK {\n        eprintln(unsafe { cstring_to_vstring(error_msg) })\n        C.sqlite3_free(error_msg)\n    }\n    C.sqlite3_close(db)\n}\n")),(0,i.kt)("h2",{id:"calling-v-from-c"},"Calling V from C"),(0,i.kt)("p",null,"Since V can compile to C, calling V code from C is very easy."),(0,i.kt)("p",null,"By default all V functions have the following naming scheme in C: ",(0,i.kt)("inlineCode",{parentName:"p"},"[module name]__[fn_name]"),"."),(0,i.kt)("p",null,"For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"fn foo() {}")," in module ",(0,i.kt)("inlineCode",{parentName:"p"},"bar")," will result in ",(0,i.kt)("inlineCode",{parentName:"p"},"bar__foo()"),"."),(0,i.kt)("p",null,"To use a custom export name, use the ",(0,i.kt)("inlineCode",{parentName:"p"},"[export]")," attribute:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"[export: 'my_custom_c_name']\nfn foo() {\n}\n")),(0,i.kt)("h2",{id:"atomics"},"Atomics"),(0,i.kt)("p",null,"V has no special support for atomics, yet, nevertheless it's possible to treat variables as atomics\nby calling C functions from V. The standard C11 atomic functions like ",(0,i.kt)("inlineCode",{parentName:"p"},"atomic_store()")," are usually\ndefined with the help of macros and C compiler magic to provide a kind of ",(0,i.kt)("em",{parentName:"p"},"overloaded C functions"),".\nSince V does not support overloading functions by intention there are wrapper functions defined in\nC headers named ",(0,i.kt)("inlineCode",{parentName:"p"},"atomic.h")," that are part of the V compiler infrastructure."),(0,i.kt)("p",null,"There are dedicated wrappers for all unsigned integer types and for pointers.\n(",(0,i.kt)("inlineCode",{parentName:"p"},"byte")," is not fully supported on Windows) ","\u2013"," the function names include the type name\nas suffix. e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"C.atomic_load_ptr()")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"C.atomic_fetch_add_u64()"),"."),(0,i.kt)("p",null,"To use these functions the C header for the used OS has to be included and the functions\nthat are intended to be used have to be declared. Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"globals",globals:!0},'$if windows {\n    #include "@VEXEROOT/thirdparty/stdatomic/win/atomic.h"\n} $else {\n    #include "@VEXEROOT/thirdparty/stdatomic/nix/atomic.h"\n}\n\n// declare functions we want to use - V does not parse the C header\nfn C.atomic_store_u32(&u32, u32)\nfn C.atomic_load_u32(&u32) u32\nfn C.atomic_compare_exchange_weak_u32(&u32, &u32, u32) bool\nfn C.atomic_compare_exchange_strong_u32(&u32, &u32, u32) bool\n\nconst num_iterations = 10000000\n\n// see section "Global Variables" below\n__global (\n    atom u32 // ordinary variable but used as atomic\n)\n\nfn change() int {\n    mut races_won_by_change := 0\n    for {\n        mut cmp := u32(17) // addressable value to compare with and to store the found value\n        // atomic version of `if atom == 17 { atom = 23 races_won_by_change++ } else { cmp = atom }`\n        if C.atomic_compare_exchange_strong_u32(&atom, &cmp, 23) {\n            races_won_by_change++\n        } else {\n            if cmp == 31 {\n                break\n            }\n            cmp = 17 // re-assign because overwritten with value of atom\n        }\n    }\n    return races_won_by_change\n}\n\nfn main() {\n    C.atomic_store_u32(&atom, 17)\n    t := go change()\n    mut races_won_by_main := 0\n    mut cmp17 := u32(17)\n    mut cmp23 := u32(23)\n    for i in 0 .. num_iterations {\n        // atomic version of `if atom == 17 { atom = 23 races_won_by_main++ }`\n        if C.atomic_compare_exchange_strong_u32(&atom, &cmp17, 23) {\n            races_won_by_main++\n        } else {\n            cmp17 = 17\n        }\n        desir := if i == num_iterations - 1 { u32(31) } else { u32(17) }\n        // atomic version of `for atom != 23 {} atom = desir`\n        for !C.atomic_compare_exchange_weak_u32(&atom, &cmp23, desir) {\n            cmp23 = 23\n        }\n    }\n    races_won_by_change := t.wait()\n    atom_new := C.atomic_load_u32(&atom)\n    println(\'atom: $atom_new, #exchanges: ${races_won_by_main + races_won_by_change}\')\n    // prints `atom: 31, #exchanges: 10000000`)\n    println(\'races won by\\n- `main()`: $races_won_by_main\\n- `change()`: $races_won_by_change\')\n}\n')),(0,i.kt)("p",null,"In this example both ",(0,i.kt)("inlineCode",{parentName:"p"},"main()")," and the spawned thread ",(0,i.kt)("inlineCode",{parentName:"p"},"change()")," try to replace a value of ",(0,i.kt)("inlineCode",{parentName:"p"},"17"),"\nin the global ",(0,i.kt)("inlineCode",{parentName:"p"},"atom")," with a value of ",(0,i.kt)("inlineCode",{parentName:"p"},"23"),". The replacement in the opposite direction is\ndone exactly 10000000 times. The last replacement will be with ",(0,i.kt)("inlineCode",{parentName:"p"},"31")," which makes the spawned\nthread finish."),(0,i.kt)("p",null,"It is not predictable how many replacements occur in which thread, but the sum will always\nbe 10000000. (With the non-atomic commands from the comments the value will be higher or the program\nwill hang ","\u2013"," dependent on the compiler optimization used.)"),(0,i.kt)("h2",{id:"global-variables"},"Global Variables"),(0,i.kt)("p",null,"By default V does not allow global variables. However, in low level applications they have their\nplace so their usage can be enabled with the compiler flag ",(0,i.kt)("inlineCode",{parentName:"p"},"-enable-globals"),".\nDeclarations of global variables must be surrounded with a ",(0,i.kt)("inlineCode",{parentName:"p"},"__global ( ... )"),"\nspecification ","\u2013"," as in the example ",(0,i.kt)("a",{parentName:"p",href:"#atomics"},"above"),"."),(0,i.kt)("p",null,"An initializer for global variables must be explicitly converted to the\ndesired target type. If no initializer is given a default initialization is done.\nSome objects like semaphores and mutexes require an explicit initialization ",(0,i.kt)("em",{parentName:"p"},"in place"),", i.e.\nnot with a value returned from a function call but with a method call by reference.\nA separate ",(0,i.kt)("inlineCode",{parentName:"p"},"init()")," function can be used for this purpose ","\u2013"," it will be called before ",(0,i.kt)("inlineCode",{parentName:"p"},"main()"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"globals",globals:!0},"import sync\n\n__global (\n    sem   sync.Semaphore // needs initialization in `init()`\n    mtx   sync.RwMutex // needs initialization in `init()`\n    f1    = f64(34.0625) // explicily initialized\n    shmap shared map[string]f64 // initialized as empty `shared` map\n    f2    f64 // initialized to `0.0`\n)\n\nfn init() {\n    sem.init(0)\n    mtx.init()\n}\n")),(0,i.kt)("p",null,"Be aware that in multi threaded applications the access to global variables is subject\nto race conditions. There are several approaches to deal with these:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"use ",(0,i.kt)("inlineCode",{parentName:"li"},"shared")," types for the variable declarations and use ",(0,i.kt)("inlineCode",{parentName:"li"},"lock")," blocks for access.\nThis is most appropriate for larger objects like structs, arrays or maps."),(0,i.kt)("li",{parentName:"ul"},'handle primitive data types as "atomics" using special C-functions (see ',(0,i.kt)("a",{parentName:"li",href:"#atomics"},"above"),")."),(0,i.kt)("li",{parentName:"ul"},"use explicit synchronization primitives like mutexes to control access. The compiler\ncannot really help in this case, so you have to know what you are doing."),(0,i.kt)("li",{parentName:"ul"},"don't care ","\u2013"," this approach is possible but makes only sense if the exact values\nof global variables do not really matter. An example can be found in the ",(0,i.kt)("inlineCode",{parentName:"li"},"rand")," module\nwhere global variables are used to generate (non cryptographic) pseudo random numbers.\nIn this case data races lead to random numbers in different threads becoming somewhat\ncorrelated, which is acceptable considering the performance penalty that using\nsynchonization primitives would represent.")),(0,i.kt)("h3",{id:"passing-c-compilation-flags"},"Passing C compilation flags"),(0,i.kt)("p",null,"Add ",(0,i.kt)("inlineCode",{parentName:"p"},"#flag")," directives to the top of your V files to provide C compilation flags like:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"-I")," for adding C include files search paths"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"-l")," for adding C library names that you want to get linked"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"-L")," for adding C library files search paths"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"-D")," for setting compile time variables")),(0,i.kt)("p",null,"You can (optionally) use different flags for different targets.\nCurrently the ",(0,i.kt)("inlineCode",{parentName:"p"},"linux"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"darwin")," , ",(0,i.kt)("inlineCode",{parentName:"p"},"freebsd"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"windows")," flags are supported."),(0,i.kt)("p",null,"NB: Each flag must go on its own line (for now)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"oksyntax",oksyntax:!0},"#flag linux -lsdl2\n#flag linux -Ivig\n#flag linux -DCIMGUI_DEFINE_ENUMS_AND_STRUCTS=1\n#flag linux -DIMGUI_DISABLE_OBSOLETE_FUNCTIONS=1\n#flag linux -DIMGUI_IMPL_API=\n")),(0,i.kt)("p",null,"In the console build command, you can use:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"-cflags")," to pass custom flags to the backend C compiler."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"-cc")," to change the default C backend compiler."),(0,i.kt)("li",{parentName:"ul"},"For example: ",(0,i.kt)("inlineCode",{parentName:"li"},"-cc gcc-9 -cflags -fsanitize=thread"),".")),(0,i.kt)("p",null,"You can define a ",(0,i.kt)("inlineCode",{parentName:"p"},"VFLAGS")," environment variable in your terminal to store your ",(0,i.kt)("inlineCode",{parentName:"p"},"-cc"),"\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"-cflags")," settings, rather than including them in the build command each time."),(0,i.kt)("h3",{id:"pkgconfig"},"#pkgconfig"),(0,i.kt)("p",null,"Add ",(0,i.kt)("inlineCode",{parentName:"p"},"#pkgconfig")," directive is used to tell the compiler which modules should be used for compiling\nand linking using the pkg-config files provided by the respective dependencies."),(0,i.kt)("p",null,"As long as backticks can't be used in ",(0,i.kt)("inlineCode",{parentName:"p"},"#flag")," and spawning processes is not desirable for security\nand portability reasons, V uses its own pkgconfig library that is compatible with the standard\nfreedesktop one."),(0,i.kt)("p",null,"If no flags are passed it will add ",(0,i.kt)("inlineCode",{parentName:"p"},"--cflags")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"--libs"),", both lines below do the same:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"oksyntax",oksyntax:!0},"#pkgconfig r_core\n#pkgconfig --cflags --libs r_core\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},".pc")," files are looked up into a hardcoded list of default pkg-config paths, the user can add\nextra paths by using the ",(0,i.kt)("inlineCode",{parentName:"p"},"PKG_CONFIG_PATH")," environment variable. Multiple modules can be passed."),(0,i.kt)("p",null,"To check the existence of a pkg-config use ",(0,i.kt)("inlineCode",{parentName:"p"},"$pkgconfig('pkg')"),' as a compile time "if" condition to\ncheck if a pkg-config exists. If it exists the branch will be created. Use ',(0,i.kt)("inlineCode",{parentName:"p"},"$else")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"$else $if"),"\nto handle other cases."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"ignore",ignore:!0},"$if $pkgconfig('mysqlclient') {\n    #pkgconfig mysqlclient\n} $else $if $pkgconfig('mariadb') {\n    #pkgconfig mariadb\n}\n")),(0,i.kt)("h3",{id:"including-c-code"},"Including C code"),(0,i.kt)("p",null,"You can also include C code directly in your V module.\nFor example, let's say that your C code is located in a folder named 'c' inside your module folder.\nThen:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Put a v.mod file inside the toplevel folder of your module (if you\ncreated your module with ",(0,i.kt)("inlineCode",{parentName:"li"},"v new")," you already have v.mod file). For\nexample:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"ignore",ignore:!0},"Module {\n    name: 'mymodule',\n    description: 'My nice module wraps a simple C library.',\n    version: '0.0.1'\n    dependencies: []\n}\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Add these lines to the top of your module:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"oksyntax",oksyntax:!0},'#flag -I @VMODROOT/c\n#flag @VMODROOT/c/implementation.o\n#include "header.h"\n')),(0,i.kt)("p",null,"NB: @VMODROOT will be replaced by V with the ",(0,i.kt)("em",{parentName:"p"},"nearest parent folder, where there is a v.mod file"),".\nAny .v file beside or below the folder where the v.mod file is,\ncan use ",(0,i.kt)("inlineCode",{parentName:"p"},"#flag @VMODROOT/abc")," to refer to this folder.\nThe @VMODROOT folder is also ",(0,i.kt)("em",{parentName:"p"},"prepended")," to the module lookup path,\nso you can ",(0,i.kt)("em",{parentName:"p"},"import")," other modules under your @VMODROOT, by just naming them."),(0,i.kt)("p",null,"The instructions above will make V look for an compiled .o file in\nyour module ",(0,i.kt)("inlineCode",{parentName:"p"},"folder/c/implementation.o"),".\nIf V finds it, the .o file will get linked to the main executable, that used the module.\nIf it does not find it, V assumes that there is a ",(0,i.kt)("inlineCode",{parentName:"p"},"@VMODROOT/c/implementation.c")," file,\nand tries to compile it to a .o file, then will use that."),(0,i.kt)("p",null,"This allows you to have C code, that is contained in a V module, so that its distribution is easier.\nYou can see a complete minimal example for using C code in a V wrapper module here:\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/vlang/v/tree/master/vlib/v/tests/project_with_c_code"},"project_with_c_code"),".\nAnother example, demonstrating passing structs from C to V and back again:\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/vlang/v/tree/master/vlib/v/tests/project_with_c_code_2"},"interoperate between C to V to C"),"."),(0,i.kt)("h3",{id:"c-types"},"C types"),(0,i.kt)("p",null,"Ordinary zero terminated C strings can be converted to V strings with\n",(0,i.kt)("inlineCode",{parentName:"p"},"unsafe { &char(cstring).vstring() }")," or if you know their length already with\n",(0,i.kt)("inlineCode",{parentName:"p"},"unsafe { &char(cstring).vstring_with_len(len) }"),"."),(0,i.kt)("p",null,"NB: The .vstring() and .vstring_with_len() methods do NOT create a copy of the ",(0,i.kt)("inlineCode",{parentName:"p"},"cstring"),",\nso you should NOT free it after calling the method ",(0,i.kt)("inlineCode",{parentName:"p"},".vstring()"),".\nIf you need to make a copy of the C string (some libc APIs like ",(0,i.kt)("inlineCode",{parentName:"p"},"getenv")," pretty much require that,\nsince they return pointers to internal libc memory), you can use ",(0,i.kt)("inlineCode",{parentName:"p"},"cstring_to_vstring(cstring)"),"."),(0,i.kt)("p",null,"On Windows, C APIs often return so called ",(0,i.kt)("inlineCode",{parentName:"p"},"wide")," strings (utf16 encoding).\nThese can be converted to V strings with ",(0,i.kt)("inlineCode",{parentName:"p"},"string_from_wide(&u16(cwidestring))")," ."),(0,i.kt)("p",null,"V has these types for easier interoperability with C:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"voidptr")," for C's ",(0,i.kt)("inlineCode",{parentName:"li"},"void*"),","),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"&byte")," for C's ",(0,i.kt)("inlineCode",{parentName:"li"},"byte*")," and"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"&char")," for C's ",(0,i.kt)("inlineCode",{parentName:"li"},"char*"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"&&char")," for C's ",(0,i.kt)("inlineCode",{parentName:"li"},"char**"))),(0,i.kt)("p",null,"To cast a ",(0,i.kt)("inlineCode",{parentName:"p"},"voidptr")," to a V reference, use ",(0,i.kt)("inlineCode",{parentName:"p"},"user := &User(user_void_ptr)"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"voidptr")," can also be dereferenced into a V struct through casting: ",(0,i.kt)("inlineCode",{parentName:"p"},"user := User(user_void_ptr)"),"."),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/vlang/v/blob/master/vlib/v/tests/project_with_c_code/mod1/wrapper.v"},"an example of a module that calls C code from V")),(0,i.kt)("h3",{id:"c-declarations"},"C Declarations"),(0,i.kt)("p",null,"C identifiers are accessed with the ",(0,i.kt)("inlineCode",{parentName:"p"},"C")," prefix similarly to how module-specific\nidentifiers are accessed. Functions must be redeclared in V before they can be used.\nAny C types may be used behind the ",(0,i.kt)("inlineCode",{parentName:"p"},"C")," prefix, but types must be redeclared in V in\norder to access type members."),(0,i.kt)("p",null,"To redeclare complex types, such as in the following C code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"struct SomeCStruct {\n    uint8_t implTraits;\n    uint16_t memPoolData;\n    union {\n        struct {\n            void* data;\n            size_t size;\n        };\n\n        DataView view;\n    };\n};\n")),(0,i.kt)("p",null,"members of sub-data-structures may be directly declared in the containing struct as below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"struct C.SomeCStruct {\n    implTraits  byte\n    memPoolData u16\n    // These members are part of sub data structures that can't currently be represented in V.\n    // Declaring them directly like this is sufficient for access.\n    // union {\n    // struct {\n    data voidptr\n    size usize\n    // }\n    view C.DataView\n    // }\n}\n")),(0,i.kt)("p",null,"The existence of the data members is made known to V, and they may be used without\nre-creating the original structure exactly."),(0,i.kt)("p",null,"Alternatively, you may ",(0,i.kt)("a",{parentName:"p",href:"#embedded-structs"},"embed")," the sub-data-structures to maintain\na parallel code structure."),(0,i.kt)("h2",{id:"debugging"},"Debugging"),(0,i.kt)("h3",{id:"c-backend-binaries-default"},"C Backend binaries (Default)"),(0,i.kt)("p",null,"To debug issues in the generated binary (flag: ",(0,i.kt)("inlineCode",{parentName:"p"},"-b c"),"), you can pass these flags:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"-g")," - produces a less optimized executable with more debug information in it.\nV will enforce line numbers from the .v files in the stacktraces, that the\nexecutable will produce on panic. It is usually better to pass -g, unless\nyou are writing low level code, in which case use the next option ",(0,i.kt)("inlineCode",{parentName:"li"},"-cg"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"-cg")," - produces a less optimized executable with more debug information in it.\nThe executable will use C source line numbers in this case. It is frequently\nused in combination with ",(0,i.kt)("inlineCode",{parentName:"li"},"-keepc"),", so that you can inspect the generated\nC program in case of panic, or so that your debugger (",(0,i.kt)("inlineCode",{parentName:"li"},"gdb"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"lldb")," etc.)\ncan show you the generated C source code."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"-showcc")," - prints the C command that is used to build the program."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"-show-c-output")," - prints the output, that your C compiler produced\nwhile compiling your program."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"-keepc")," - do not delete the generated C source code file after a successful\ncompilation. Also keep using the same file path, so it is more stable,\nand easier to keep opened in an editor/IDE.")),(0,i.kt)("p",null,"For best debugging experience if you are writing a low level wrapper for an existing\nC library, you can pass several of these flags at the same time:\n",(0,i.kt)("inlineCode",{parentName:"p"},"v -keepc -cg -showcc yourprogram.v"),", then just run your debugger (gdb/lldb) or IDE\non the produced executable ",(0,i.kt)("inlineCode",{parentName:"p"},"yourprogram"),"."),(0,i.kt)("p",null,"If you just want to inspect the generated C code,\nwithout further compilation, you can also use the ",(0,i.kt)("inlineCode",{parentName:"p"},"-o")," flag (e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"-o file.c"),").\nThis will make V produce the ",(0,i.kt)("inlineCode",{parentName:"p"},"file.c")," then stop."),(0,i.kt)("p",null,"If you want to see the generated C source code for ",(0,i.kt)("em",{parentName:"p"},"just")," a single C function,\nfor example ",(0,i.kt)("inlineCode",{parentName:"p"},"main"),", you can use: ",(0,i.kt)("inlineCode",{parentName:"p"},"-printfn main -o file.c"),"."),(0,i.kt)("p",null,"To debug the V executable itself you need to compile from src with ",(0,i.kt)("inlineCode",{parentName:"p"},"./v -g -o v cmd/v"),"."),(0,i.kt)("p",null,"You can debug tests with for example ",(0,i.kt)("inlineCode",{parentName:"p"},"v -g -keepc prog_test.v"),". The ",(0,i.kt)("inlineCode",{parentName:"p"},"-keepc")," flag is needed,\nso that the executable is not deleted, after it was created and ran."),(0,i.kt)("p",null,"To see a detailed list of all flags that V supports,\nuse ",(0,i.kt)("inlineCode",{parentName:"p"},"v help"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"v help build")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"v help build-c"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Commandline Debugging")),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"compile your binary with debugging info ",(0,i.kt)("inlineCode",{parentName:"li"},"v -g hello.v")),(0,i.kt)("li",{parentName:"ol"},"debug with ",(0,i.kt)("a",{parentName:"li",href:"https://lldb.llvm.org"},"lldb")," or ",(0,i.kt)("a",{parentName:"li",href:"https://www.gnu.org/software/gdb/"},"GDB")," e.g. ",(0,i.kt)("inlineCode",{parentName:"li"},"lldb hello"))),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/vlang/v/wiki/Troubleshooting-(debugging)-executables-created-with-V-in-GDB"},"Troubleshooting (debugging) executables created with V in GDB")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Visual debugging Setup:"),"\nQQQ"),(0,i.kt)("p",null,"QQQ"),(0,i.kt)("h3",{id:"native-backend-binaries"},"Native Backend binaries"),(0,i.kt)("p",null,"Currently there is no debugging support for binaries, created by the\nnative backend (flag: ",(0,i.kt)("inlineCode",{parentName:"p"},"-b native"),")."),(0,i.kt)("h3",{id:"javascript-backend"},"Javascript Backend"),(0,i.kt)("p",null,"To debug the generated Javascript output you can activate source maps:\n",(0,i.kt)("inlineCode",{parentName:"p"},"v -b js -sourcemap hello.v -o hello.js")),(0,i.kt)("p",null,"For all supported options check the latest help:\n",(0,i.kt)("inlineCode",{parentName:"p"},"v help build-js")),(0,i.kt)("h2",{id:"conditional-compilation"},"Conditional compilation"),(0,i.kt)("h3",{id:"compile-time-code"},"Compile time code"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"$")," is used as a prefix for compile-time operations."),(0,i.kt)("h4",{id:"if-condition"},(0,i.kt)("inlineCode",{parentName:"h4"},"$if")," condition"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"fn main() {\n    // Support for multiple conditions in one branch\n    $if ios || android {\n        println('Running on a mobile device!')\n    }\n    $if linux && x64 {\n        println('64-bit Linux.')\n    }\n    // Usage as expression\n    os := $if windows { 'Windows' } $else { 'UNIX' }\n    println('Using $os')\n    // $else-$if branches\n    $if tinyc {\n        println('tinyc')\n    } $else $if clang {\n        println('clang')\n    } $else $if gcc {\n        println('gcc')\n    } $else {\n        println('different compiler')\n    }\n    $if test {\n        println('testing')\n    }\n    // v -cg ...\n    $if debug {\n        println('debugging')\n    }\n    // v -prod ...\n    $if prod {\n        println('production build')\n    }\n    // v -d option ...\n    $if option ? {\n        println('custom option')\n    }\n}\n")),(0,i.kt)("p",null,"If you want an ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," to be evaluated at compile time it must be prefixed with a ",(0,i.kt)("inlineCode",{parentName:"p"},"$")," sign.\nRight now it can be used to detect an OS, compiler, platform or compilation options.\n",(0,i.kt)("inlineCode",{parentName:"p"},"$if debug")," is a special option like ",(0,i.kt)("inlineCode",{parentName:"p"},"$if windows")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"$if x32"),", it's enabled if the program\nis compiled with ",(0,i.kt)("inlineCode",{parentName:"p"},"v -g")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"v -cg"),".\nIf you're using a custom ifdef, then you do need ",(0,i.kt)("inlineCode",{parentName:"p"},"$if option ? {}")," and compile with",(0,i.kt)("inlineCode",{parentName:"p"},"v -d option"),".\nFull list of builtin options:\n| OS                            | Compilers         | Platforms             | Other                     |\n| ---                           | ---               | ---                   | ---                       |\n| ",(0,i.kt)("inlineCode",{parentName:"p"},"windows"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"linux"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"macos"),"   | ",(0,i.kt)("inlineCode",{parentName:"p"},"gcc"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"tinyc"),"    | ",(0,i.kt)("inlineCode",{parentName:"p"},"amd64"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"arm64"),"      | ",(0,i.kt)("inlineCode",{parentName:"p"},"debug"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"prod"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"test"),"   |\n| ",(0,i.kt)("inlineCode",{parentName:"p"},"mac"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"darwin"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"ios"),",       | ",(0,i.kt)("inlineCode",{parentName:"p"},"clang"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"mingw"),"  | ",(0,i.kt)("inlineCode",{parentName:"p"},"x64"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"x32"),"          | ",(0,i.kt)("inlineCode",{parentName:"p"},"js"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"glibc"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"prealloc")," |\n| ",(0,i.kt)("inlineCode",{parentName:"p"},"android"),",",(0,i.kt)("inlineCode",{parentName:"p"},"mach"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"dragonfly")," | ",(0,i.kt)("inlineCode",{parentName:"p"},"msvc"),"            | ",(0,i.kt)("inlineCode",{parentName:"p"},"little_endian"),"       | ",(0,i.kt)("inlineCode",{parentName:"p"},"no_bounds_checking"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"freestanding"),"    |\n| ",(0,i.kt)("inlineCode",{parentName:"p"},"gnu"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"hpux"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"haiku"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"qnx")," | ",(0,i.kt)("inlineCode",{parentName:"p"},"cplusplus"),"       | ",(0,i.kt)("inlineCode",{parentName:"p"},"big_endian"),"          | ",(0,i.kt)("inlineCode",{parentName:"p"},"no_segfault_handler"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"no_backtrace"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"no_main")," |\n| ",(0,i.kt)("inlineCode",{parentName:"p"},"solaris")," | | | |"),(0,i.kt)("h4",{id:"embed_file"},(0,i.kt)("inlineCode",{parentName:"h4"},"$embed_file")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"ignore",ignore:!0},"import os\nfn main() {\n    embedded_file := $embed_file('v.png')\n    os.write_file('exported.png', embedded_file.to_string())?\n}\n")),(0,i.kt)("p",null,"V can embed arbitrary files into the executable with the ",(0,i.kt)("inlineCode",{parentName:"p"},"$embed_file(<path>)"),"\ncompile time call. Paths can be absolute or relative to the source file."),(0,i.kt)("p",null,"When you do not use ",(0,i.kt)("inlineCode",{parentName:"p"},"-prod"),", the file will not be embedded. Instead, it will\nbe loaded ",(0,i.kt)("em",{parentName:"p"},"the first time")," your program calls ",(0,i.kt)("inlineCode",{parentName:"p"},"embedded_file.data()")," at runtime, making\nit easier to change in external editor programs, without needing to recompile\nyour executable."),(0,i.kt)("p",null,"When you compile with ",(0,i.kt)("inlineCode",{parentName:"p"},"-prod"),", the file ",(0,i.kt)("em",{parentName:"p"},"will be embedded inside")," your\nexecutable, increasing your binary size, but making it more self contained\nand thus easier to distribute. In this case, ",(0,i.kt)("inlineCode",{parentName:"p"},"embedded_file.data()")," will cause ",(0,i.kt)("em",{parentName:"p"},"no IO"),",\nand it will always return the same data."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"$embed_file")," supports compression of the embedded file when compiling with ",(0,i.kt)("inlineCode",{parentName:"p"},"-prod"),".\nCurrently only one compression type is supported: ",(0,i.kt)("inlineCode",{parentName:"p"},"zlib")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"ignore",ignore:!0},"import os\nfn main() {\n    embedded_file := $embed_file('v.png', .zlib) // compressed using zlib\n    os.write_file('exported.png', embedded_file.to_string())?\n}\n")),(0,i.kt)("h4",{id:"tmpl-for-embedding-and-parsing-v-template-files"},(0,i.kt)("inlineCode",{parentName:"h4"},"$tmpl")," for embedding and parsing V template files"),(0,i.kt)("p",null,"V has a simple template language for text and html templates, and they can easily\nbe embedded via ",(0,i.kt)("inlineCode",{parentName:"p"},"$tmpl('path/to/template.txt')"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"ignore",ignore:!0},"fn build() string {\n    name := 'Peter'\n    age := 25\n    numbers := [1, 2, 3]\n    return $tmpl('1.txt')\n}\n\nfn main() {\n    println(build())\n}\n")),(0,i.kt)("p",null,"1.txt:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"name: @name\n\nage: @age\n\nnumbers: @numbers\n\n@for number in numbers\n  @number\n@end\n")),(0,i.kt)("p",null,"output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"name: Peter\n\nage: 25\n\nnumbers: [1, 2, 3]\n\n1\n2\n3\n")),(0,i.kt)("h4",{id:"env"},(0,i.kt)("inlineCode",{parentName:"h4"},"$env")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"module main\n\nfn main() {\n    compile_time_env := $env('ENV_VAR')\n    println(compile_time_env)\n}\n")),(0,i.kt)("p",null,"V can bring in values at compile time from environment variables.\n",(0,i.kt)("inlineCode",{parentName:"p"},"$env('ENV_VAR')")," can also be used in top-level ",(0,i.kt)("inlineCode",{parentName:"p"},"#flag")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"#include")," statements:\n",(0,i.kt)("inlineCode",{parentName:"p"},"#flag linux -I $env('JAVA_HOME')/include"),"."),(0,i.kt)("h4",{id:"compile_error-and-compile_warn"},(0,i.kt)("inlineCode",{parentName:"h4"},"$compile_error")," and ",(0,i.kt)("inlineCode",{parentName:"h4"},"$compile_warn")),(0,i.kt)("p",null,"These two comptime functions are very useful for displaying custom errors/warnings during\ncompile time."),(0,i.kt)("p",null,"Both receive as their only argument a string literal that contains the message to display:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"failcompile nofmt",failcompile:!0,nofmt:!0},"// x.v\nmodule main\n\n$if linux {\n    $compile_error('Linux is not supported')\n}\n\nfn main() {\n}\n\n$ v run x.v\nx.v:4:5: error: Linux is not supported\n    2 |\n    3 | $if linux {\n    4 |     $compile_error('Linux is not supported')\n      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    5 | }\n    6 |\n")),(0,i.kt)("h3",{id:"environment-specific-files"},"Environment specific files"),(0,i.kt)("p",null,"If a file has an environment-specific suffix, it will only be compiled for that environment."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},".js.v")," => will be used only by the JS backend. These files can contain JS. code."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},".c.v")," => will be used only by the C backend. These files can contain C. code."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},".native.v")," => will be used only by V's native backend."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"_nix.c.v")," => will be used only on Unix systems (non Windows)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"_${os}.c.v")," => will be used only on the specific ",(0,i.kt)("inlineCode",{parentName:"li"},"os")," system.\nFor example, ",(0,i.kt)("inlineCode",{parentName:"li"},"_windows.c.v")," will be used only when compiling on Windows, or with ",(0,i.kt)("inlineCode",{parentName:"li"},"-os windows"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"_default.c.v")," => will be used only if there is NOT a more specific platform file.\nFor example, if you have both ",(0,i.kt)("inlineCode",{parentName:"li"},"file_linux.c.v")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"file_default.c.v"),",\nand you are compiling for linux, then only ",(0,i.kt)("inlineCode",{parentName:"li"},"file_linux.c.v")," will be used,\nand ",(0,i.kt)("inlineCode",{parentName:"li"},"file_default.c.v")," will be ignored.")),(0,i.kt)("p",null,"Here is a more complete example:\nmain.v:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"ignore",ignore:!0},"module main\nfn main() { println(message) }\n")),(0,i.kt)("p",null,"main_default.c.v:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"ignore",ignore:!0},"module main\nconst ( message = 'Hello world' )\n")),(0,i.kt)("p",null,"main_linux.c.v:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"ignore",ignore:!0},"module main\nconst ( message = 'Hello linux' )\n")),(0,i.kt)("p",null,"main_windows.c.v:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"ignore",ignore:!0},"module main\nconst ( message = 'Hello windows' )\n")),(0,i.kt)("p",null,"With the example above:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"when you compile for windows, you will get 'Hello windows'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"when you compile for linux, you will get 'Hello linux'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"when you compile for any other platform, you will get the\nnon specific 'Hello world' message.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"_d_customflag.v")," => will be used ",(0,i.kt)("em",{parentName:"p"},"only")," if you pass ",(0,i.kt)("inlineCode",{parentName:"p"},"-d customflag")," to V.\nThat corresponds to ",(0,i.kt)("inlineCode",{parentName:"p"},"$if customflag ? {}"),", but for a whole file, not just a\nsingle block. ",(0,i.kt)("inlineCode",{parentName:"p"},"customflag")," should be a snake",(0,i.kt)("em",{parentName:"p"},"case identifier, it can not\ncontain arbitrary characters (only lower case latin letters + numbers + `"),(0,i.kt)("inlineCode",{parentName:"p"},").\nNB: a combinatorial "),"_d_customflag_linux.c.v",(0,i.kt)("inlineCode",{parentName:"p"},"postfix will not work.\nIf you do need a custom flag file, that has platform dependent code, use the\npostfix"),"_d_customflag.v",(0,i.kt)("inlineCode",{parentName:"p"},", and then use plaftorm dependent compile time\nconditional blocks inside it, i.e. "),"$if linux {}` etc.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"_notd_customflag.v")," => similar to _d_customflag.v, but will be used\n",(0,i.kt)("em",{parentName:"p"},"only")," if you do NOT pass ",(0,i.kt)("inlineCode",{parentName:"p"},"-d customflag")," to V."))),(0,i.kt)("h2",{id:"compile-time-pseudo-variables"},"Compile time pseudo variables"),(0,i.kt)("p",null,"V also gives your code access to a set of pseudo string variables,\nthat are substituted at compile time:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"@FN")," => replaced with the name of the current V function"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"@METHOD")," => replaced with ReceiverType.MethodName"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"@MOD")," => replaced with the name of the current V module"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"@STRUCT")," => replaced with the name of the current V struct"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"@FILE")," => replaced with the path of the V source file"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"@LINE")," => replaced with the V line number where it appears (as a string)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"@COLUMN")," => replaced with the column where it appears (as a string)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"@VEXE")," => replaced with the path to the V compiler"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"@VEXEROOT"),"  => will be substituted with the ",(0,i.kt)("em",{parentName:"li"},"folder"),",\nwhere the V executable is (as a string)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"@VHASH"),"  => replaced with the shortened commit hash of the V compiler (as a string)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"@VMOD_FILE")," => replaced with the contents of the nearest v.mod file (as a string)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"@VMODROOT")," => will be substituted with the ",(0,i.kt)("em",{parentName:"li"},"folder"),",\nwhere the nearest v.mod file is (as a string).")),(0,i.kt)("p",null,"That allows you to do the following example, useful while debugging/logging/tracing your code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"eprintln('file: ' + @FILE + ' | line: ' + @LINE + ' | fn: ' + @MOD + '.' + @FN)\n")),(0,i.kt)("p",null,"Another example, is if you want to embed the version/name from v.mod ",(0,i.kt)("em",{parentName:"p"},"inside")," your executable:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"ignore",ignore:!0},"import v.vmod\nvm := vmod.decode( @VMOD_FILE ) or { panic(err) }\neprintln('$vm.name $vm.version\\n $vm.description')\n")),(0,i.kt)("h2",{id:"performance-tuning"},"Performance tuning"),(0,i.kt)("p",null,"The generated C code is usually fast enough, when you compile your code\nwith ",(0,i.kt)("inlineCode",{parentName:"p"},"-prod"),". There are some situations though, where you may want to give\nadditional hints to the compiler, so that it can further optimize some\nblocks of code."),(0,i.kt)("p",null,"NB: These are ",(0,i.kt)("em",{parentName:"p"},"rarely")," needed, and should not be used, unless you\n",(0,i.kt)("em",{parentName:"p"},"profile your code"),', and then see that there are significant benefits for them.\nTo cite gcc\'s documentation: "programmers are notoriously bad at predicting\nhow their programs actually perform".'),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"[inline]")," - you can tag functions with ",(0,i.kt)("inlineCode",{parentName:"p"},"[inline]"),", so the C compiler will\ntry to inline them, which in some cases, may be beneficial for performance,\nbut may impact the size of your executable."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"[direct_array_access]")," - in functions tagged with ",(0,i.kt)("inlineCode",{parentName:"p"},"[direct_array_access]"),"\nthe compiler will translate array operations directly into C array operations -\nomitting bounds checking. This may save a lot of time in a function that iterates\nover an array but at the cost of making the function unsafe - unless\nthe boundaries will be checked by the user."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"if _likely_(bool expression) {")," this hints the C compiler, that the passed\nboolean expression is very likely to be true, so it can generate assembly\ncode, with less chance of branch misprediction. In the JS backend,\nthat does nothing."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"if _unlikely_(bool expression) {")," similar to ",(0,i.kt)("inlineCode",{parentName:"p"},"_likely_(x)"),", but it hints that\nthe boolean expression is highly improbable. In the JS backend, that does nothing."),(0,i.kt)("h2",{id:"compile-time-reflection"},"Compile-time reflection"),(0,i.kt)("p",null,"Having built-in JSON support is nice, but V also allows you to create efficient\nserializers for any data format. V has compile-time ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"for")," constructs:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"struct User {\n    name string\n    age  int\n}\n\nfn main() {\n    $for field in User.fields {\n        $if field.typ is string {\n            println('$field.name is of type string')\n        }\n    }\n}\n\n// Output:\n// name is of type string\n")),(0,i.kt)("p",null,"QQQ"),(0,i.kt)("p",null,"QQQ"),(0,i.kt)("p",null,"for a more complete example."),(0,i.kt)("h2",{id:"limited-operator-overloading"},"Limited operator overloading"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},'struct Vec {\n    x int\n    y int\n}\n\nfn (a Vec) str() string {\n    return \'{$a.x, $a.y}\'\n}\n\nfn (a Vec) + (b Vec) Vec {\n    return Vec{a.x + b.x, a.y + b.y}\n}\n\nfn (a Vec) - (b Vec) Vec {\n    return Vec{a.x - b.x, a.y - b.y}\n}\n\nfn main() {\n    a := Vec{2, 3}\n    b := Vec{4, 5}\n    mut c := Vec{1, 2}\n    println(a + b) // "{6, 8}"\n    println(a - b) // "{-2, -2}"\n    c += a\n    println(c) // "{3, 5}"\n}\n')),(0,i.kt)("p",null,"Operator overloading goes against V's philosophy of simplicity and predictability.\nBut since scientific and graphical applications are among V's domains,\noperator overloading is an important feature to have in order to improve readability:"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"a.add(b).add(c.mul(d))")," is a lot less readable than ",(0,i.kt)("inlineCode",{parentName:"p"},"a + b + c * d"),"."),(0,i.kt)("p",null,"To improve safety and maintainability, operator overloading is limited:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"It's only possible to overload ",(0,i.kt)("inlineCode",{parentName:"li"},"+, -, *, /, %, <, >, ==, !=, <=, >=")," operators."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"==")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"!=")," are self generated by the compiler but can be overridden."),(0,i.kt)("li",{parentName:"ul"},"Calling other functions inside operator functions is not allowed."),(0,i.kt)("li",{parentName:"ul"},"Operator functions can't modify their arguments."),(0,i.kt)("li",{parentName:"ul"},"When using ",(0,i.kt)("inlineCode",{parentName:"li"},"<")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"==")," operators, the return type must be ",(0,i.kt)("inlineCode",{parentName:"li"},"bool"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"!="),", ",(0,i.kt)("inlineCode",{parentName:"li"},">"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"<=")," and ",(0,i.kt)("inlineCode",{parentName:"li"},">=")," are auto generated when ",(0,i.kt)("inlineCode",{parentName:"li"},"==")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"<")," are defined."),(0,i.kt)("li",{parentName:"ul"},"Both arguments must have the same type (just like with all operators in V)."),(0,i.kt)("li",{parentName:"ul"},"Assignment operators (",(0,i.kt)("inlineCode",{parentName:"li"},"*="),", ",(0,i.kt)("inlineCode",{parentName:"li"},"+="),", ",(0,i.kt)("inlineCode",{parentName:"li"},"/="),", etc)\nare auto generated when the corresponding operators are defined and operands are of the same type.")),(0,i.kt)("h2",{id:"inline-assembly"},"Inline assembly"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"ignore",ignore:!0},"a := 100\nb := 20\nmut c := 0\nasm amd64 {\n    mov eax, a\n    add eax, b\n    mov c, eax\n    ; =r (c) as c // output\n    ; r (a) as a // input\n      r (b) as b\n}\nprintln('a: $a') // 100\nprintln('b: $b') // 20\nprintln('c: $c') // 120\n")),(0,i.kt)("p",null,"For more examples, see ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/vlang/v/tree/master/vlib/v/tests/assembly/asm_test.amd64.v"},"github.com/vlang/v/tree/master/vlib/v/tests/assembly/asm_test.amd64.v")),(0,i.kt)("h2",{id:"translating-c-to-v"},"Translating C to V"),(0,i.kt)("p",null,"V can translate your C code to human readable V code and generate V wrappers on top of C libraries."),(0,i.kt)("p",null,"Let's create a simple program ",(0,i.kt)("inlineCode",{parentName:"p"},"test.c")," first:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'#include "stdio.h"\n\nint main() {\n    for (int i = 0; i < 10; i++) {\n        printf("hello world\\n");\n    }\n        return 0;\n}\n')),(0,i.kt)("p",null,"Run ",(0,i.kt)("inlineCode",{parentName:"p"},"v translate test.c"),", and V will generate ",(0,i.kt)("inlineCode",{parentName:"p"},"test.v"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"fn main() {\n    for i := 0; i < 10; i++ {\n        println('hello world')\n    }\n}\n")),(0,i.kt)("p",null,"To generate a wrapper on top of a C library use this command:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"v wrapper c_code/libsodium/src/libsodium\n")),(0,i.kt)("p",null,"This will generate a directory ",(0,i.kt)("inlineCode",{parentName:"p"},"libsodium")," with a V module."),(0,i.kt)("p",null,"Example of a C2V generated libsodium wrapper:"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/vlang/libsodium"},"https://github.com/vlang/libsodium")),(0,i.kt)("br",null),(0,i.kt)("p",null,"When should you translate C code and when should you simply call C code from V?"),(0,i.kt)("p",null,"If you have well-written, well-tested C code,\nthen of course you can always simply call this C code from V."),(0,i.kt)("p",null,"Translating it to V gives you several advantages:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If you plan to develop that code base, you now have everything in one language,\nwhich is much safer and easier to develop in than C."),(0,i.kt)("li",{parentName:"ul"},"Cross-compilation becomes a lot easier. You don't have to worry about it at all."),(0,i.kt)("li",{parentName:"ul"},"No more build flags and include files either.")),(0,i.kt)("h2",{id:"hot-code-reloading"},"Hot code reloading"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"live",live:!0},"module main\n\nimport time\n\n[live]\nfn print_message() {\n    println('Hello! Modify this message while the program is running.')\n}\n\nfn main() {\n    for {\n        print_message()\n        time.sleep(500 * time.millisecond)\n    }\n}\n")),(0,i.kt)("p",null,"Build this example with ",(0,i.kt)("inlineCode",{parentName:"p"},"v -live message.v"),"."),(0,i.kt)("p",null,"You can also run this example with ",(0,i.kt)("inlineCode",{parentName:"p"},"v -live run message.v"),".\nMake sure that in command you use a path to a V's file,\n",(0,i.kt)("strong",{parentName:"p"},"not")," a path to a folder (like ",(0,i.kt)("inlineCode",{parentName:"p"},"v -live run ."),") -\nin that case you need to modify content of a folder (add new file, for example),\nbecause changes in ",(0,i.kt)("em",{parentName:"p"},"message.v")," will have no effect."),(0,i.kt)("p",null,"Functions that you want to be reloaded must have ",(0,i.kt)("inlineCode",{parentName:"p"},"[live]")," attribute\nbefore their definition."),(0,i.kt)("p",null,"Right now it's not possible to modify types while the program is running."),(0,i.kt)("p",null,"More examples, including a graphical application:\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/vlang/v/tree/master/examples/hot_reload"},"github.com/vlang/v/tree/master/examples/hot_reload"),"."),(0,i.kt)("h2",{id:"cross-compilation"},"Cross compilation"),(0,i.kt)("p",null,"To cross compile your project simply run"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"v -os windows .\n")),(0,i.kt)("p",null,"or"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"v -os linux .\n")),(0,i.kt)("p",null,"NB: Cross-compiling a windows binary on a linux machine requires the GNU C compiler for\nMinGW-w64 (targeting Win64) to first be installed."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"sudo apt-get install gcc-mingw-w64-x86-64\n")),(0,i.kt)("p",null,"(Cross compiling for macOS is temporarily not possible.)"),(0,i.kt)("p",null,"If you don't have any C dependencies, that's all you need to do. This works even\nwhen compiling GUI apps using the ",(0,i.kt)("inlineCode",{parentName:"p"},"ui")," module or graphical apps using ",(0,i.kt)("inlineCode",{parentName:"p"},"gg"),"."),(0,i.kt)("p",null,"You will need to install Clang, LLD linker, and download a zip file with\nlibraries and include files for Windows and Linux. V will provide you with a link."),(0,i.kt)("h2",{id:"cross-platform-shell-scripts-in-v"},"Cross-platform shell scripts in V"),(0,i.kt)("p",null,"V can be used as an alternative to Bash to write deployment scripts, build scripts, etc."),(0,i.kt)("p",null,'The advantage of using V for this is the simplicity and predictability of the language, and\ncross-platform support. "V scripts" run on Unix-like systems as well as on Windows.'),(0,i.kt)("p",null,"Use the ",(0,i.kt)("inlineCode",{parentName:"p"},".vsh")," file extension. It will make all functions in the ",(0,i.kt)("inlineCode",{parentName:"p"},"os"),"\nmodule global (so that you can use ",(0,i.kt)("inlineCode",{parentName:"p"},"mkdir()")," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"os.mkdir()"),", for example)."),(0,i.kt)("p",null,"An example ",(0,i.kt)("inlineCode",{parentName:"p"},"deploy.vsh"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"wip",wip:!0},"#!/usr/bin/env -S v run\n// The shebang above associates the file to V on Unix-like systems,\n// so it can be run just by specifying the path to the file\n// once it's made executable using `chmod +x`.\n\n// print command then execute it\nfn sh(cmd string){\n  println(\"\u276f $cmd\")\n  print(execute_or_exit(cmd).output)\n}\n\n// Remove if build/ exits, ignore any errors if it doesn't\nrmdir_all('build') or { }\n\n// Create build/, never fails as build/ does not exist\nmkdir('build')?\n\n// Move *.v files to build/\nresult := execute('mv *.v build/')\nif result.exit_code != 0 {\n    println(result.output)\n}\n\nsh('ls')\n\n// Similar to:\n// files := ls('.')?\n// mut count := 0\n// if files.len > 0 {\n//     for file in files {\n//         if file.ends_with('.v') {\n//              mv(file, 'build/') or {\n//                  println('err: $err')\n//                  return\n//              }\n//         }\n//         count++\n//     }\n// }\n// if count == 0 {\n//     println('No files')\n// }\n")),(0,i.kt)("p",null,"Now you can either compile this like a normal V program and get an executable you can deploy and run\nanywhere:\n",(0,i.kt)("inlineCode",{parentName:"p"},"v deploy.vsh && ./deploy")),(0,i.kt)("p",null,"Or just run it more like a traditional Bash script:\n",(0,i.kt)("inlineCode",{parentName:"p"},"v run deploy.vsh")),(0,i.kt)("p",null,"On Unix-like platforms, the file can be run directly after making it executable using ",(0,i.kt)("inlineCode",{parentName:"p"},"chmod +x"),":\n",(0,i.kt)("inlineCode",{parentName:"p"},"./deploy.vsh")),(0,i.kt)("h2",{id:"attributes"},"Attributes"),(0,i.kt)("p",null,"V has several attributes that modify the behavior of functions and structs."),(0,i.kt)("p",null,"An attribute is a compiler instruction specified inside ",(0,i.kt)("inlineCode",{parentName:"p"},"[]")," right before a\nfunction/struct/enum declaration and applies only to the following declaration."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"// [flag] enables Enum types to be used as bitfields\n\n[flag]\nenum BitField {\n    read\n    write\n    other\n}\n\nfn main() {\n    assert 1 == int(BitField.read)\n    assert 2 == int(BitField.write)\n    mut bf := BitField.read\n    assert bf.has(.read | .other) // test if *at least one* of the flags is set\n    assert !bf.all(.read | .other) // test if *all* of the flags is set\n    bf.set(.write | .other)\n    assert bf.has(.read | .write | .other)\n    assert bf.all(.read | .write | .other)\n    bf.toggle(.other)\n    assert bf == BitField.read | .write\n    assert bf.all(.read | .write)\n    assert !bf.has(.other)\n}\n")),(0,i.kt)("p",null,"Struct field deprecations:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"oksyntax",oksyntax:!0},"module abc\n\n// Note that only *direct* accesses to Xyz.d in *other modules*, will produce deprecation notices/warnings:\npub struct Xyz {\npub mut:\n    a int\n    d int [deprecated: 'use Xyz.a instead'; deprecated_after: '2999-03-01'] // produce a notice, the deprecation date is in the far future\n}\n")),(0,i.kt)("p",null,"Function/method deprecations:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v"},"// Calling this function will result in a deprecation warning\n[deprecated]\nfn old_function() {\n}\n\n// It can also display a custom deprecation message\n[deprecated: 'use new_function() instead']\nfn legacy_function() {}\n\n// You can also specify a date, after which the function will be\n// considered deprecated. Before that date, calls to the function\n// will be compiler notices - you will see them, but the compilation\n// is not affected. After that date, calls will become warnings,\n// so ordinary compiling will still work, but compiling with -prod\n// will not (all warnings are treated like errors with -prod).\n// 6 months after the deprecation date, calls will be hard\n// compiler errors.\n[deprecated: 'use new_function2() instead']\n[deprecated_after: '2021-05-27']\nfn legacy_function2() {}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"nofmt",nofmt:!0},'// This function\'s calls will be inlined.\n[inline]\nfn inlined_function() {\n}\n\n// This function\'s calls will NOT be inlined.\n[noinline]\nfn function() {\n}\n\n// This function will NOT return to its callers.\n// Such functions can be used at the end of or blocks,\n// just like exit/1 or panic/1. Such functions can not\n// have return types, and should end either in for{}, or\n// by calling other `[noreturn]` functions.\n[noreturn]\nfn forever() {\n    for {}\n}\n\n// The following struct must be allocated on the heap. Therefore, it can only be used as a\n// reference (`&Window`) or inside another reference (`&OuterStruct{ Window{...} }`).\n// See section "Stack and Heap"\n[heap]\nstruct Window {\n}\n\n// V will not generate this function and all its calls if the provided flag is false.\n// To use a flag, use `v -d flag`\n[if debug]\nfn foo() {\n}\n\nfn bar() {\n    foo() // will not be called if `-d debug` is not passed\n}\n\n// The memory pointed to by the pointer arguments of this function will not be\n// freed by the garbage collector (if in use) before the function returns\n[keep_args_alive]\nfn C.my_external_function(voidptr, int, voidptr) int\n\n// Calls to following function must be in unsafe{} blocks.\n// Note that the code in the body of `risky_business()` will still be\n// checked, unless you also wrap it in `unsafe {}` blocks.\n// This is useful, when you want to have an `[unsafe]` function that\n// has checks before/after a certain unsafe operation, that will still\n// benefit from V\'s safety features.\n[unsafe]\nfn risky_business() {\n    // code that will be checked, perhaps checking pre conditions\n    unsafe {\n        // code that *will not be* checked, like pointer arithmetic,\n        // accessing union fields, calling other `[unsafe]` fns, etc...\n        // Usually, it is a good idea to try minimizing code wrapped\n        // in unsafe{} as much as possible.\n        // See also [Memory-unsafe code](#memory-unsafe-code)\n    }\n    // code that will be checked, perhaps checking post conditions and/or\n    // keeping invariants\n}\n\n// V\'s autofree engine will not take care of memory management in this function.\n// You will have the responsibility to free memory manually yourself in it.\n[manualfree]\nfn custom_allocations() {\n}\n\n// For C interop only, tells V that the following struct is defined with `typedef struct` in C\n[typedef]\nstruct C.Foo {\n}\n\n// Used to add a custom calling convention to a function, available calling convention: stdcall, fastcall and cdecl.\n// This list aslo apply for type aliases (see below).\n[callconv: "stdcall"]\nfn C.DefWindowProc(hwnd int, msg int, lparam int, wparam int)\n\n// Used to add a custom calling convention to a function type aliases.\n[callconv: "fastcall"]\ntype FastFn = fn (int) bool\n\n// Windows only:\n// If a default graphics library is imported (ex. gg, ui), then the graphical window takes\n// priority and no console window is created, effectively disabling println() statements.\n// Use to explicitly create console window. Valid before main() only.\n[console]\nfn main() {\n}\n')),(0,i.kt)("h2",{id:"goto"},"Goto"),(0,i.kt)("p",null,"V allows unconditionally jumping to a label with ",(0,i.kt)("inlineCode",{parentName:"p"},"goto"),". The label name must be contained\nwithin the same function as the ",(0,i.kt)("inlineCode",{parentName:"p"},"goto")," statement. A program may ",(0,i.kt)("inlineCode",{parentName:"p"},"goto")," a label outside\nor deeper than the current scope. ",(0,i.kt)("inlineCode",{parentName:"p"},"goto")," allows jumping past variable initialization or\njumping back to code that accesses memory that has already been freed, so it requires\n",(0,i.kt)("inlineCode",{parentName:"p"},"unsafe"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"ignore",ignore:!0},"if x {\n    // ...\n    if y {\n        unsafe {\n            goto my_label\n        }\n    }\n    // ...\n}\nmy_label:\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"goto")," should be avoided, particularly when ",(0,i.kt)("inlineCode",{parentName:"p"},"for")," can be used instead.\n",(0,i.kt)("a",{parentName:"p",href:"#labelled-break--continue"},"Labelled break/continue")," can be used to break out of\na nested loop, and those do not risk violating memory-safety."),(0,i.kt)("h1",{id:"appendices"},"Appendices"),(0,i.kt)("h2",{id:"appendix-i-keywords"},"Appendix I: Keywords"),(0,i.kt)("p",null,"V has 42 reserved keywords (3 are literals):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"ignore",ignore:!0},"as\nasm\nassert\natomic\nbreak\nconst\ncontinue\ndefer\nelse\nenum\nfalse\nfn\nfor\ngo\ngoto\nif\nimport\nin\ninterface\nis\nisreftype\nlock\nmatch\nmodule\nmut\nnone\nor\npub\nreturn\nrlock\nselect\nshared\nsizeof\nstatic\nstruct\ntrue\ntype\ntypeof\nunion\nunsafe\nvolatile\n__offsetof\n")),(0,i.kt)("p",null,"See also ",(0,i.kt)("a",{parentName:"p",href:"#v-types"},"V Types"),"."),(0,i.kt)("h2",{id:"appendix-ii-operators"},"Appendix II: Operators"),(0,i.kt)("p",null,"This lists operators for ",(0,i.kt)("a",{parentName:"p",href:"#primitive-types"},"primitive types")," only."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-v",metastring:"ignore",ignore:!0},"+    sum                    integers, floats, strings\n-    difference             integers, floats\n*    product                integers, floats\n/    quotient               integers, floats\n%    remainder              integers\n\n~    bitwise NOT            integers\n&    bitwise AND            integers\n|    bitwise OR             integers\n^    bitwise XOR            integers\n\n!    logical NOT            bools\n&&   logical AND            bools\n||   logical OR             bools\n!=   logical XOR            bools\n\n<<   left shift             integer << unsigned integer\n>>   right shift            integer >> unsigned integer\n>>>  unsigned right shift   integer >> unsigned integer\n\n\nPrecedence    Operator\n    5            *  /  %  <<  >> >>> &\n    4            +  -  |  ^\n    3            ==  !=  <  <=  >  >=\n    2            &&\n    1            ||\n\n\nAssignment Operators\n+=   -=   *=   /=   %=\n&=   |=   ^=\n>>=  <<=  >>>=\n")))}m.isMDXComponent=!0}}]);