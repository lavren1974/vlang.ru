"use strict";(self.webpackChunkvlang_ru=self.webpackChunkvlang_ru||[]).push([[6421],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>d});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),p=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},c=function(e){var n=p(e.components);return a.createElement(l.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=p(t),d=r,h=m["".concat(l,".").concat(d)]||m[d]||u[d]||i;return t?a.createElement(h,o(o({ref:n},c),{},{components:t})):a.createElement(h,o({ref:n},c))}));function d(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=m;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var p=2;p<i;p++)o[p]=t[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},1723:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var a=t(7462),r=(t(7294),t(3905));const i={sidebar_position:24},o="Memory management",s={unversionedId:"documentation/Memory-management",id:"documentation/Memory-management",title:"Memory management",description:"V avoids doing unnecessary allocations in the first place by using value types,",source:"@site/docs/documentation/Memory-management.md",sourceDirName:"documentation",slug:"/documentation/Memory-management",permalink:"/docs/documentation/Memory-management",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/documentation/Memory-management.md",tags:[],version:"current",sidebarPosition:24,frontMatter:{sidebar_position:24},sidebar:"tutorialSidebar",previous:{title:"Testing",permalink:"/docs/documentation/Testing"},next:{title:"ORM",permalink:"/docs/documentation/orm"}},l={},p=[{value:"Control",id:"control",level:2},{value:"Examples",id:"examples",level:2},{value:"Stack and Heap",id:"stack-and-heap",level:2},{value:"Stack and Heap Basics",id:"stack-and-heap-basics",level:3},{value:"V&#39;s default approach",id:"vs-default-approach",level:3},{value:"Manual Control for Stack and Heap",id:"manual-control-for-stack-and-heap",level:3}],c={toc:p};function u(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"memory-management"},"Memory management"),(0,r.kt)("p",null,"V avoids doing unnecessary allocations in the first place by using value types,\nstring buffers, promoting a simple abstraction-free code style."),(0,r.kt)("p",null,"Most objects (~90-100%) are freed by V's autofree engine: the compiler inserts\nnecessary free calls automatically during compilation. Remaining small percentage\nof objects is freed via reference counting."),(0,r.kt)("p",null,"The developer doesn't need to change anything in their code. \"It just works\", like in\nPython, Go, or Java, except there's no heavy GC tracing everything or expensive RC for\neach object."),(0,r.kt)("h2",{id:"control"},"Control"),(0,r.kt)("p",null,"You can take advantage of V's autofree engine and define a ",(0,r.kt)("inlineCode",{parentName:"p"},"free()")," method on custom\ndata types:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-v"},"struct MyType {}\n\n[unsafe]\nfn (data &MyType) free() {\n    // ...\n}\n")),(0,r.kt)("p",null,"Just as the compiler frees C data types with C's ",(0,r.kt)("inlineCode",{parentName:"p"},"free()"),", it will statically insert\n",(0,r.kt)("inlineCode",{parentName:"p"},"free()")," calls for your data type at the end of each variable's lifetime."),(0,r.kt)("p",null,"Autofree can be enabled with an ",(0,r.kt)("inlineCode",{parentName:"p"},"-autofree")," flag."),(0,r.kt)("p",null,"For developers willing to have more low level control, autofree can be disabled with\n",(0,r.kt)("inlineCode",{parentName:"p"},"-manualfree"),", or by adding a ",(0,r.kt)("inlineCode",{parentName:"p"},"[manualfree]")," on each function that wants manage its\nmemory manually. (See ",(0,r.kt)("a",{parentName:"p",href:"#attributes"},"attributes"),")."),(0,r.kt)("p",null,"Note 2: Autofree is still WIP. Until it stabilises and becomes the default, please\navoid using it. Right now allocations are handled by a minimal and well performing GC\nuntil V's autofree engine is production ready."),(0,r.kt)("h2",{id:"examples"},"Examples"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-v"},"import strings\n\nfn draw_text(s string, x int, y int) {\n    // ...\n}\n\nfn draw_scene() {\n    // ...\n    name1 := 'abc'\n    name2 := 'def ghi'\n    draw_text('hello $name1', 10, 10)\n    draw_text('hello $name2', 100, 10)\n    draw_text(strings.repeat(`X`, 10000), 10, 50)\n    // ...\n}\n")),(0,r.kt)("p",null,"The strings don't escape ",(0,r.kt)("inlineCode",{parentName:"p"},"draw_text"),", so they are cleaned up when\nthe function exits."),(0,r.kt)("p",null,"In fact, with the ",(0,r.kt)("inlineCode",{parentName:"p"},"-prealloc")," flag, the first two calls won't result in any allocations at all.\nThese two strings are small, so V will use a preallocated buffer for them."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-v"},"struct User {\n    name string\n}\n\nfn test() []int {\n    number := 7 // stack variable\n    user := User{} // struct allocated on stack\n    numbers := [1, 2, 3] // array allocated on heap, will be freed as the function exits\n    println(number)\n    println(user)\n    println(numbers)\n    numbers2 := [4, 5, 6] // array that's being returned, won't be freed here\n    return numbers2\n}\n")),(0,r.kt)("h2",{id:"stack-and-heap"},"Stack and Heap"),(0,r.kt)("h3",{id:"stack-and-heap-basics"},"Stack and Heap Basics"),(0,r.kt)("p",null,"Like with most other programming languages there are two locations where data can\nbe stored:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("em",{parentName:"li"},"stack")," allows fast allocations with almost zero administrative overhead. The\nstack grows and shrinks with the function call depth ","\u2013"," so every called\nfunction has its stack segment that remains valid until the function returns.\nNo freeing is necessary, however, this also means that a reference to a stack\nobject becomes invalid on function return. Furthermore stack space is\nlimited (typically to a few Megabytes per thread)."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("em",{parentName:"li"},"heap")," is a large memory area (typically some Gigabytes) that is administrated\nby the operating system. Heap objects are allocated and freed by special function\ncalls that delegate the administrative tasks to the OS. This means that they can\nremain valid across several function calls, however, the administration is\nexpensive.")),(0,r.kt)("h3",{id:"vs-default-approach"},"V's default approach"),(0,r.kt)("p",null,"Due to performance considerations V tries to put objects on the stack if possible\nbut allocates them on the heap when obviously necessary. Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-v"},"struct MyStruct {\n    n int\n}\n\nstruct RefStruct {\n    r &MyStruct\n}\n\nfn main() {\n    q, w := f()\n    println('q: $q.r.n, w: $w.n')\n}\n\nfn f() (RefStruct, &MyStruct) {\n    a := MyStruct{\n        n: 1\n    }\n    b := MyStruct{\n        n: 2\n    }\n    c := MyStruct{\n        n: 3\n    }\n    e := RefStruct{\n        r: &b\n    }\n    x := a.n + c.n\n    println('x: $x')\n    return e, &c\n}\n")),(0,r.kt)("p",null,"Here ",(0,r.kt)("inlineCode",{parentName:"p"},"a")," is stored on the stack since it's address never leaves the function ",(0,r.kt)("inlineCode",{parentName:"p"},"f()"),".\nHowever a reference to ",(0,r.kt)("inlineCode",{parentName:"p"},"b")," is part of ",(0,r.kt)("inlineCode",{parentName:"p"},"e")," which is returned. Also a reference to\n",(0,r.kt)("inlineCode",{parentName:"p"},"c")," is returned. For this reason ",(0,r.kt)("inlineCode",{parentName:"p"},"b")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"c")," will be heap allocated."),(0,r.kt)("p",null,"Things become less obvious when a reference to an object is passed as function argument:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-v"},"struct MyStruct {\nmut:\n    n int\n}\n\nfn main() {\n    mut q := MyStruct{\n        n: 7\n    }\n    w := MyStruct{\n        n: 13\n    }\n    x := q.f(&w) // references of `q` and `w` are passed\n    println('q: $q\\nx: $x')\n}\n\nfn (mut a MyStruct) f(b &MyStruct) int {\n    a.n += b.n\n    x := a.n * b.n\n    return x\n}\n")),(0,r.kt)("p",null,"Here the call ",(0,r.kt)("inlineCode",{parentName:"p"},"q.f(&w)")," passes references to ",(0,r.kt)("inlineCode",{parentName:"p"},"q")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"w")," because ",(0,r.kt)("inlineCode",{parentName:"p"},"a")," is\n",(0,r.kt)("inlineCode",{parentName:"p"},"mut")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"b")," is of type ",(0,r.kt)("inlineCode",{parentName:"p"},"&MyStruct")," in ",(0,r.kt)("inlineCode",{parentName:"p"},"f()"),"'s declaration, so technically\nthese references are leaving ",(0,r.kt)("inlineCode",{parentName:"p"},"main()"),". However the ",(0,r.kt)("em",{parentName:"p"},"lifetime")," of these\nreferences lies inside the scope of ",(0,r.kt)("inlineCode",{parentName:"p"},"main()")," so ",(0,r.kt)("inlineCode",{parentName:"p"},"q")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"w")," are allocated\non the stack."),(0,r.kt)("h3",{id:"manual-control-for-stack-and-heap"},"Manual Control for Stack and Heap"),(0,r.kt)("p",null,"In the last example the V compiler could put ",(0,r.kt)("inlineCode",{parentName:"p"},"q")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"w")," on the stack\nbecause it assumed that in the call ",(0,r.kt)("inlineCode",{parentName:"p"},"q.f(&w)")," these references were only\nused for reading and modifying the referred values ","\u2013"," and not to pass the\nreferences themselves somewhere else. This can be seen in a way that the\nreferences to ",(0,r.kt)("inlineCode",{parentName:"p"},"q")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"w")," are only ",(0,r.kt)("em",{parentName:"p"},"borrowed")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"f()"),"."),(0,r.kt)("p",null,"Things become different if ",(0,r.kt)("inlineCode",{parentName:"p"},"f()")," is doing something with a reference itself:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-v"},"struct RefStruct {\nmut:\n    r &MyStruct\n}\n\n// see discussion below\n[heap]\nstruct MyStruct {\n    n int\n}\n\nfn main() {\n    m := MyStruct{}\n    mut r := RefStruct{\n        r: &m\n    }\n    r.g()\n    println('r: $r')\n}\n\nfn (mut r RefStruct) g() {\n    s := MyStruct{\n        n: 7\n    }\n    r.f(&s) // reference to `s` inside `r` is passed back to `main() `\n}\n\nfn (mut r RefStruct) f(s &MyStruct) {\n    r.r = s // would trigger error without `[heap]`\n}\n")),(0,r.kt)("p",null,"Here ",(0,r.kt)("inlineCode",{parentName:"p"},"f()")," looks quite innocent but is doing nasty things ","\u2013"," it inserts a\nreference to ",(0,r.kt)("inlineCode",{parentName:"p"},"s")," into ",(0,r.kt)("inlineCode",{parentName:"p"},"r"),". The problem with this is that ",(0,r.kt)("inlineCode",{parentName:"p"},"s")," lives only as long\nas ",(0,r.kt)("inlineCode",{parentName:"p"},"g()")," is running but ",(0,r.kt)("inlineCode",{parentName:"p"},"r")," is used in ",(0,r.kt)("inlineCode",{parentName:"p"},"main()")," after that. For this reason\nthe compiler would complain about the assignment in ",(0,r.kt)("inlineCode",{parentName:"p"},"f()")," because ",(0,r.kt)("inlineCode",{parentName:"p"},"s")," ",(0,r.kt)("em",{parentName:"p"},'"might\nrefer to an object stored on stack"'),". The assumption made in ",(0,r.kt)("inlineCode",{parentName:"p"},"g()")," that the call\n",(0,r.kt)("inlineCode",{parentName:"p"},"r.f(&s)")," would only borrow the reference to ",(0,r.kt)("inlineCode",{parentName:"p"},"s")," is wrong."),(0,r.kt)("p",null,"A solution to this dilemma is the ",(0,r.kt)("inlineCode",{parentName:"p"},"[heap]")," attribute at the declaration of\n",(0,r.kt)("inlineCode",{parentName:"p"},"struct MyStruct"),". It instructs the compiler to ",(0,r.kt)("em",{parentName:"p"},"always")," allocate ",(0,r.kt)("inlineCode",{parentName:"p"},"MyStruct"),"-objects\non the heap. This way the reference to ",(0,r.kt)("inlineCode",{parentName:"p"},"s")," remains valid even after ",(0,r.kt)("inlineCode",{parentName:"p"},"g()")," returns.\nThe compiler takes into consideration that ",(0,r.kt)("inlineCode",{parentName:"p"},"MyStruct")," objects are always heap\nallocated when checking ",(0,r.kt)("inlineCode",{parentName:"p"},"f()")," and allows assigning the reference to ",(0,r.kt)("inlineCode",{parentName:"p"},"s")," to the\n",(0,r.kt)("inlineCode",{parentName:"p"},"r.r")," field."),(0,r.kt)("p",null,"There is a pattern often seen in other programming languages:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-v",metastring:"failcompile",failcompile:!0},"fn (mut a MyStruct) f() &MyStruct {\n    // do something with a\n    return &a // would return address of borrowed object\n}\n")),(0,r.kt)("p",null,"Here ",(0,r.kt)("inlineCode",{parentName:"p"},"f()")," is passed a reference ",(0,r.kt)("inlineCode",{parentName:"p"},"a")," as receiver that is passed back to the caller and returned\nas result at the same time. The intention behind such a declaration is method chaining like\n",(0,r.kt)("inlineCode",{parentName:"p"},"y = x.f().g()"),". However, the problem with this approach is that a second reference\nto ",(0,r.kt)("inlineCode",{parentName:"p"},"a")," is created ","\u2013"," so it is not only borrowed and ",(0,r.kt)("inlineCode",{parentName:"p"},"MyStruct")," has to be\ndeclared as ",(0,r.kt)("inlineCode",{parentName:"p"},"[heap]"),"."),(0,r.kt)("p",null,"In V the better approach is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-v"},"struct MyStruct {\nmut:\n    n int\n}\n\nfn (mut a MyStruct) f() {\n    // do something with `a`\n}\n\nfn (mut a MyStruct) g() {\n    // do something else with `a`\n}\n\nfn main() {\n    x := MyStruct{} // stack allocated\n    mut y := x\n    y.f()\n    y.g()\n    // instead of `mut y := x.f().g()\n}\n")),(0,r.kt)("p",null,"This way the ",(0,r.kt)("inlineCode",{parentName:"p"},"[heap]")," attribute can be avoided ","\u2013"," resulting in better performance."),(0,r.kt)("p",null,"However, stack space is very limited as mentioned above. For this reason the ",(0,r.kt)("inlineCode",{parentName:"p"},"[heap]"),"\nattribute might be suitable for very large structures even if not required by use cases\nlike those mentioned above."),(0,r.kt)("p",null,"There is an alternative way to manually control allocation on a case to case basis. This\napproach is not recommended but shown here for the sake of completeness:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-v"},"struct MyStruct {\n    n int\n}\n\nstruct RefStruct {\nmut:\n    r &MyStruct\n}\n\n// simple function - just to overwrite stack segment previously used by `g()`\nfn use_stack() {\n    x := 7.5\n    y := 3.25\n    z := x + y\n    println('$x $y $z')\n}\n\nfn main() {\n    m := MyStruct{}\n    mut r := RefStruct{\n        r: &m\n    }\n    r.g()\n    use_stack() // to erase invalid stack contents\n    println('r: $r')\n}\n\nfn (mut r RefStruct) g() {\n    s := &MyStruct{ // `s` explicitly refers to a heap object\n        n: 7\n    }\n    // change `&MyStruct` -> `MyStruct` above and `r.f(s)` -> `r.f(&s)` below\n    // to see data in stack segment being overwritten\n    r.f(s)\n}\n\nfn (mut r RefStruct) f(s &MyStruct) {\n    r.r = unsafe { s } // override compiler check\n}\n")),(0,r.kt)("p",null,"Here the compiler check is suppressed by the ",(0,r.kt)("inlineCode",{parentName:"p"},"unsafe")," block. To make ",(0,r.kt)("inlineCode",{parentName:"p"},"s")," be heap\nallocated even without ",(0,r.kt)("inlineCode",{parentName:"p"},"[heap]")," attribute the ",(0,r.kt)("inlineCode",{parentName:"p"},"struct")," literal is prefixed with\nan ampersand: ",(0,r.kt)("inlineCode",{parentName:"p"},"&MyStruct{...}"),"."),(0,r.kt)("p",null,"This last step would not be required by the compiler but without it the reference\ninside ",(0,r.kt)("inlineCode",{parentName:"p"},"r")," becomes invalid (the memory area pointed to will be overwritten by\n",(0,r.kt)("inlineCode",{parentName:"p"},"use_stack()"),") and the program might crash (or at least produce an unpredictable\nfinal output). That's why this approach is ",(0,r.kt)("em",{parentName:"p"},"unsafe")," and should be avoided!"))}u.isMDXComponent=!0}}]);