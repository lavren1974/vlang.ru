"use strict";(self.webpackChunkvlang_ru=self.webpackChunkvlang_ru||[]).push([[7206],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>u});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),c=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=c(e.components);return a.createElement(s.Provider,{value:n},e.children)},h={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(t),u=r,m=d["".concat(s,".").concat(u)]||d[u]||h[u]||o;return t?a.createElement(m,i(i({ref:n},p),{},{components:t})):a.createElement(m,i({ref:n},p))}));function u(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=d;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var c=2;c<o;c++)i[c]=t[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},494:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var a=t(7462),r=(t(7294),t(3905));const o={sidebar_position:21},i="Concurrency",l={unversionedId:"documentation/concurrency",id:"documentation/concurrency",title:"Concurrency",description:"Spawning Concurrent Tasks",source:"@site/docs/documentation/concurrency.md",sourceDirName:"documentation",slug:"/documentation/concurrency",permalink:"/docs/documentation/concurrency",draft:!1,tags:[],version:"current",sidebarPosition:21,frontMatter:{sidebar_position:21},sidebar:"tutorialSidebar",previous:{title:"Generics",permalink:"/docs/documentation/generics"},next:{title:"JSON",permalink:"/docs/documentation/json"}},s={},c=[{value:"Spawning Concurrent Tasks",id:"spawning-concurrent-tasks",level:2},{value:"Channels",id:"channels",level:2},{value:"Syntax and Usage",id:"syntax-and-usage",level:3},{value:"Channel Select",id:"channel-select",level:3},{value:"Special Channel Features",id:"special-channel-features",level:3},{value:"Shared Objects",id:"shared-objects",level:2}],p={toc:c};function h(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"concurrency"},"Concurrency"),(0,r.kt)("h2",{id:"spawning-concurrent-tasks"},"Spawning Concurrent Tasks"),(0,r.kt)("p",null,"V's model of concurrency is going to be very similar to Go's.\nFor now, ",(0,r.kt)("inlineCode",{parentName:"p"},"go foo()")," runs ",(0,r.kt)("inlineCode",{parentName:"p"},"foo()")," concurrently in a different thread:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-v"},"import math\n\nfn p(a f64, b f64) { // ordinary function without return value\n    c := math.sqrt(a * a + b * b)\n    println(c)\n}\n\nfn main() {\n    go p(3, 4)\n    // p will be run in parallel thread\n    // It can also be written as follows\n    // go fn (a f64, b f64) {\n    //  c := math.sqrt(a * a + b * b)\n    //  println(c)\n    // }(3, 4)\n}\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"In V 0.4 ",(0,r.kt)("inlineCode",{parentName:"p"},"go foo()")," will be automatically renamed via vfmt to ",(0,r.kt)("inlineCode",{parentName:"p"},"spawn foo()"),",\nand there will be a way to launch a coroutine (a lightweight thread managed by the runtime).")),(0,r.kt)("p",null,"Sometimes it is necessary to wait until a parallel thread has finished. This can\nbe done by assigning a ",(0,r.kt)("em",{parentName:"p"},"handle")," to the started thread and calling the ",(0,r.kt)("inlineCode",{parentName:"p"},"wait()")," method\nto this handle later:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-v"},"import math\n\nfn p(a f64, b f64) { // ordinary function without return value\n    c := math.sqrt(a * a + b * b)\n    println(c) // prints `5`\n}\n\nfn main() {\n    h := go p(3, 4)\n    // p() runs in parallel thread\n    h.wait()\n    // p() has definitely finished\n}\n")),(0,r.kt)("p",null,"This approach can also be used to get a return value from a function that is run in a\nparallel thread. There is no need to modify the function itself to be able to call it\nconcurrently."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-v"},"import math { sqrt }\n\nfn get_hypot(a f64, b f64) f64 { //       ordinary function returning a value\n    c := sqrt(a * a + b * b)\n    return c\n}\n\nfn main() {\n    g := go get_hypot(54.06, 2.08) // spawn thread and get handle to it\n    h1 := get_hypot(2.32, 16.74) //   do some other calculation here\n    h2 := g.wait() //                 get result from spawned thread\n    println('Results: $h1, $h2') //   prints `Results: 16.9, 54.1`\n}\n")),(0,r.kt)("p",null,"If there is a large number of tasks, it might be easier to manage them\nusing an array of threads."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-v"},"import time\n\nfn task(id int, duration int) {\n    println('task $id begin')\n    time.sleep(duration * time.millisecond)\n    println('task $id end')\n}\n\nfn main() {\n    mut threads := []thread{}\n    threads << go task(1, 500)\n    threads << go task(2, 900)\n    threads << go task(3, 100)\n    threads.wait()\n    println('done')\n}\n\n// Output:\n// task 1 begin\n// task 2 begin\n// task 3 begin\n// task 3 end\n// task 1 end\n// task 2 end\n// done\n")),(0,r.kt)("p",null,"Additionally for threads that return the same type, calling ",(0,r.kt)("inlineCode",{parentName:"p"},"wait()"),"\non the thread array will return all computed values."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-v"},"fn expensive_computing(i int) int {\n    return i * i\n}\n\nfn main() {\n    mut threads := []thread int{}\n    for i in 1 .. 10 {\n        threads << go expensive_computing(i)\n    }\n    // Join all tasks\n    r := threads.wait()\n    println('All jobs finished: $r')\n}\n\n// Output: All jobs finished: [1, 4, 9, 16, 25, 36, 49, 64, 81]\n")),(0,r.kt)("h2",{id:"channels"},"Channels"),(0,r.kt)("p",null,"Channels are the preferred way to communicate between threads. V's channels work basically like\nthose in Go. You can push objects into a channel on one end and pop objects from the other end.\nChannels can be buffered or unbuffered and it is possible to ",(0,r.kt)("inlineCode",{parentName:"p"},"select")," from multiple channels."),(0,r.kt)("h3",{id:"syntax-and-usage"},"Syntax and Usage"),(0,r.kt)("p",null,"Channels have the type ",(0,r.kt)("inlineCode",{parentName:"p"},"chan objtype"),". An optional buffer length can specified as the ",(0,r.kt)("inlineCode",{parentName:"p"},"cap")," field\nin the declaration:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-v"},'ch := chan int{} // unbuffered - "synchronous"\nch2 := chan f64{cap: 100} // buffer length 100\n')),(0,r.kt)("p",null,"Channels do not have to be declared as ",(0,r.kt)("inlineCode",{parentName:"p"},"mut"),". The buffer length is not part of the type but\na field of the individual channel object. Channels can be passed to threads like normal\nvariables:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-v"},"fn f(ch chan int) {\n    // ...\n}\n\nfn main() {\n    ch := chan int{}\n    go f(ch)\n    // ...\n}\n")),(0,r.kt)("p",null,"Objects can be pushed to channels using the arrow operator. The same operator can be used to\npop objects from the other end:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-v"},"// make buffered channels so pushing does not block (if there is room in the buffer)\nch := chan int{cap: 1}\nch2 := chan f64{cap: 1}\nn := 5\n// push\nch <- n\nch2 <- 7.3\nmut y := f64(0.0)\nm := <-ch // pop creating new variable\ny = <-ch2 // pop into existing variable\n")),(0,r.kt)("p",null,"A channel can be closed to indicate that no further objects can be pushed. Any attempt\nto do so will then result in a runtime panic (with the exception of ",(0,r.kt)("inlineCode",{parentName:"p"},"select")," and\n",(0,r.kt)("inlineCode",{parentName:"p"},"try_push()")," - see below). Attempts to pop will return immediately if the\nassociated channel has been closed and the buffer is empty. This situation can be\nhandled using an or branch (see ",(0,r.kt)("a",{parentName:"p",href:"#handling-optionals"},"Handling Optionals"),")."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-v",metastring:"wip",wip:!0},"ch := chan int{}\nch2 := chan f64{}\n// ...\nch.close()\n// ...\nm := <-ch or {\n    println('channel has been closed')\n}\n\n// propagate error\ny := <-ch2 ?\n")),(0,r.kt)("h3",{id:"channel-select"},"Channel Select"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"select")," command allows monitoring several channels at the same time\nwithout noticeable CPU load.  It consists of a list of possible transfers and associated branches\nof statements - similar to the ",(0,r.kt)("a",{parentName:"p",href:"#match"},"match")," command:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-v"},"import time\n\nfn main() {\n    ch := chan f64{}\n    ch2 := chan f64{}\n    ch3 := chan f64{}\n    mut b := 0.0\n    c := 1.0\n    // ... setup go threads that will send on ch/ch2\n    go fn (the_channel chan f64) {\n        time.sleep(5 * time.millisecond)\n        the_channel <- 1.0\n    }(ch)\n    go fn (the_channel chan f64) {\n        time.sleep(1 * time.millisecond)\n        the_channel <- 1.0\n    }(ch2)\n    go fn (the_channel chan f64) {\n        _ := <-the_channel\n    }(ch3)\n\n    select {\n        a := <-ch {\n            // do something with `a`\n            eprintln('> a: $a')\n        }\n        b = <-ch2 {\n            // do something with predeclared variable `b`\n            eprintln('> b: $b')\n        }\n        ch3 <- c {\n            // do something if `c` was sent\n            time.sleep(5 * time.millisecond)\n            eprintln('> c: $c was send on channel ch3')\n        }\n        500 * time.millisecond {\n            // do something if no channel has become ready within 0.5s\n            eprintln('> more than 0.5s passed without a channel being ready')\n        }\n    }\n    eprintln('> done')\n}\n")),(0,r.kt)("p",null,"The timeout branch is optional. If it is absent ",(0,r.kt)("inlineCode",{parentName:"p"},"select")," waits for an unlimited amount of time.\nIt is also possible to proceed immediately if no channel is ready in the moment ",(0,r.kt)("inlineCode",{parentName:"p"},"select")," is called\nby adding an ",(0,r.kt)("inlineCode",{parentName:"p"},"else { ... }")," branch. ",(0,r.kt)("inlineCode",{parentName:"p"},"else")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"<timeout>")," are mutually exclusive."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"select")," command can be used as an ",(0,r.kt)("em",{parentName:"p"},"expression")," of type ",(0,r.kt)("inlineCode",{parentName:"p"},"bool"),"\nthat becomes ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," if all channels are closed:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-v",metastring:"wip",wip:!0},"if select {\n    ch <- a {\n        // ...\n    }\n} {\n    // channel was open\n} else {\n    // channel is closed\n}\n")),(0,r.kt)("h3",{id:"special-channel-features"},"Special Channel Features"),(0,r.kt)("p",null,"For special purposes there are some builtin fields and methods:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-v"},"struct Abc {\n    x int\n}\n\na := 2.13\nch := chan f64{}\nres := ch.try_push(a) // try to perform `ch <- a`\nprintln(res)\nl := ch.len // number of elements in queue\nc := ch.cap // maximum queue length\nis_closed := ch.closed // bool flag - has `ch` been closed\nprintln(l)\nprintln(c)\nmut b := Abc{}\nch2 := chan Abc{}\nres2 := ch2.try_pop(mut b) // try to perform `b = <-ch2`\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"try_push/pop()")," methods will return immediately with one of the results\n",(0,r.kt)("inlineCode",{parentName:"p"},".success"),", ",(0,r.kt)("inlineCode",{parentName:"p"},".not_ready")," or ",(0,r.kt)("inlineCode",{parentName:"p"},".closed")," - dependent on whether the object has been transferred or\nthe reason why not.\nUsage of these methods and fields in production is not recommended -\nalgorithms based on them are often subject to race conditions. Especially ",(0,r.kt)("inlineCode",{parentName:"p"},".len")," and\n",(0,r.kt)("inlineCode",{parentName:"p"},".closed")," should not be used to make decisions.\nUse ",(0,r.kt)("inlineCode",{parentName:"p"},"or")," branches, error propagation or ",(0,r.kt)("inlineCode",{parentName:"p"},"select")," instead (see ",(0,r.kt)("a",{parentName:"p",href:"#syntax-and-usage"},"Syntax and Usage"),"\nand ",(0,r.kt)("a",{parentName:"p",href:"#channel-select"},"Channel Select")," above)."),(0,r.kt)("h2",{id:"shared-objects"},"Shared Objects"),(0,r.kt)("p",null,"Data can be exchanged between a thread and the calling thread via a shared variable.\nSuch variables should be created as ",(0,r.kt)("inlineCode",{parentName:"p"},"shared")," and passed to the thread as such, too.\nThe underlying ",(0,r.kt)("inlineCode",{parentName:"p"},"struct")," contains a hidden ",(0,r.kt)("em",{parentName:"p"},"mutex")," that allows locking concurrent access\nusing ",(0,r.kt)("inlineCode",{parentName:"p"},"rlock")," for read-only and ",(0,r.kt)("inlineCode",{parentName:"p"},"lock")," for read/write access."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-v"},"struct St {\nmut:\n    x int // data to be shared\n}\n\nfn (shared b St) g() {\n    lock b {\n        // read/modify/write b.x\n    }\n}\n\nfn main() {\n    shared a := St{\n        x: 10\n    }\n    go a.g()\n    // ...\n    rlock a {\n        // read a.x\n    }\n}\n")),(0,r.kt)("p",null,"Shared variables must be structs, arrays or maps."))}h.isMDXComponent=!0}}]);