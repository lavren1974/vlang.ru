"use strict";(self.webpackChunkvlang_ru=self.webpackChunkvlang_ru||[]).push([[6127],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>d});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=r.createContext({}),p=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},u=function(e){var n=p(e.components);return r.createElement(s.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),m=p(t),d=a,f=m["".concat(s,".").concat(d)]||m[d]||c[d]||i;return t?r.createElement(f,o(o({ref:n},u),{},{components:t})):r.createElement(f,o({ref:n},u))}));function d(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,o=new Array(i);o[0]=m;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var p=2;p<i;p++)o[p]=t[p];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},2640:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var r=t(7462),a=(t(7294),t(3905));const i={sidebar_position:10},o="Statements & expressions",l={unversionedId:"documentation/statements-expressions",id:"documentation/statements-expressions",title:"Statements & expressions",description:"If",source:"@site/docs/documentation/statements-expressions.md",sourceDirName:"documentation",slug:"/documentation/statements-expressions",permalink:"/docs/documentation/statements-expressions",draft:!1,tags:[],version:"current",sidebarPosition:10,frontMatter:{sidebar_position:10},sidebar:"tutorialSidebar",previous:{title:"Module imports",permalink:"/docs/documentation/module-imports"},next:{title:"Structs",permalink:"/docs/documentation/structs"}},s={},p=[{value:"If",id:"if",level:2},{value:"Type checks and casts",id:"type-checks-and-casts",level:3},{value:"In operator",id:"in-operator",level:2},{value:"For loop",id:"for-loop",level:2},{value:"<code>for</code>/<code>in</code>",id:"forin",level:3},{value:"Array <code>for</code>",id:"array-for",level:4},{value:"Custom iterators",id:"custom-iterators",level:4},{value:"Map <code>for</code>",id:"map-for",level:4},{value:"Range <code>for</code>",id:"range-for",level:4},{value:"Condition <code>for</code>",id:"condition-for",level:3},{value:"Bare <code>for</code>",id:"bare-for",level:3},{value:"C <code>for</code>",id:"c-for",level:3},{value:"Labelled break &amp; continue",id:"labelled-break--continue",level:3},{value:"Match",id:"match",level:2},{value:"Defer",id:"defer",level:2}],u={toc:p};function c(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,r.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"statements--expressions"},"Statements & expressions"),(0,a.kt)("h2",{id:"if"},"If"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-v"},"a := 10\nb := 20\nif a < b {\n    println('$a < $b')\n} else if a > b {\n    println('$a > $b')\n} else {\n    println('$a == $b')\n}\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"if")," statements are pretty straightforward and similar to most other languages.\nUnlike other C-like languages,\nthere are no parentheses surrounding the condition and the braces are always required."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"if")," can be used as an expression:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-v"},"num := 777\ns := if num % 2 == 0 { 'even' } else { 'odd' }\nprintln(s)\n// \"odd\"\n")),(0,a.kt)("h3",{id:"type-checks-and-casts"},"Type checks and casts"),(0,a.kt)("p",null,"You can check the current type of a sum type using ",(0,a.kt)("inlineCode",{parentName:"p"},"is")," and its negated form ",(0,a.kt)("inlineCode",{parentName:"p"},"!is"),"."),(0,a.kt)("p",null,"You can do it either in an ",(0,a.kt)("inlineCode",{parentName:"p"},"if"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-v",metastring:"cgen",cgen:!0},"struct Abc {\n    val string\n}\n\nstruct Xyz {\n    foo string\n}\n\ntype Alphabet = Abc | Xyz\n\nx := Alphabet(Abc{'test'}) // sum type\nif x is Abc {\n    // x is automatically casted to Abc and can be used here\n    println(x)\n}\nif x !is Abc {\n    println('Not Abc')\n}\n")),(0,a.kt)("p",null,"or using ",(0,a.kt)("inlineCode",{parentName:"p"},"match"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-v",metastring:"oksyntax",oksyntax:!0},"match x {\n    Abc {\n        // x is automatically casted to Abc and can be used here\n        println(x)\n    }\n    Xyz {\n        // x is automatically casted to Xyz and can be used here\n        println(x)\n    }\n}\n")),(0,a.kt)("p",null,"This works also with struct fields:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-v"},"struct MyStruct {\n    x int\n}\n\nstruct MyStruct2 {\n    y string\n}\n\ntype MySumType = MyStruct | MyStruct2\n\nstruct Abc {\n    bar MySumType\n}\n\nx := Abc{\n    bar: MyStruct{123} // MyStruct will be converted to MySumType type automatically\n}\nif x.bar is MyStruct {\n    // x.bar is automatically casted\n    println(x.bar)\n} else if x.bar is MyStruct2 {\n    new_var := x.bar as MyStruct2\n    // ... or you can use `as` to create a type cast an alias manually:\n    println(new_var)\n}\nmatch x.bar {\n    MyStruct {\n        // x.bar is automatically casted\n        println(x.bar)\n    }\n    else {}\n}\n")),(0,a.kt)("p",null,"Mutable variables can change, and doing a cast would be unsafe.\nHowever, sometimes it's useful to type cast despite mutability.\nIn such cases the developer must mark the expression with the ",(0,a.kt)("inlineCode",{parentName:"p"},"mut")," keyword\nto tell the compiler that they know what they're doing."),(0,a.kt)("p",null,"It works like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-v",metastring:"oksyntax",oksyntax:!0},"mut x := MySumType(MyStruct{123})\nif mut x is MyStruct {\n    // x is casted to MyStruct even if it's mutable\n    // without the mut keyword that wouldn't work\n    println(x)\n}\n// same with match\nmatch mut x {\n    MyStruct {\n        // x is casted to MyStruct even if it's mutable\n        // without the mut keyword that wouldn't work\n        println(x)\n    }\n}\n")),(0,a.kt)("h2",{id:"in-operator"},"In operator"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"in")," allows to check whether an array or a map contains an element.\nTo do the opposite, use ",(0,a.kt)("inlineCode",{parentName:"p"},"!in"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-v"},"nums := [1, 2, 3]\nprintln(1 in nums) // true\nprintln(4 !in nums) // true\nm := {\n    'one': 1\n    'two': 2\n}\nprintln('one' in m) // true\nprintln('three' !in m) // true\n")),(0,a.kt)("p",null,"It's also useful for writing boolean expressions that are clearer and more compact:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-v"},"enum Token {\n    plus\n    minus\n    div\n    mult\n}\n\nstruct Parser {\n    token Token\n}\n\nparser := Parser{}\nif parser.token == .plus || parser.token == .minus || parser.token == .div || parser.token == .mult {\n    // ...\n}\nif parser.token in [.plus, .minus, .div, .mult] {\n    // ...\n}\n")),(0,a.kt)("p",null,"V optimizes such expressions,\nso both ",(0,a.kt)("inlineCode",{parentName:"p"},"if")," statements above produce the same machine code and no arrays are created."),(0,a.kt)("h2",{id:"for-loop"},"For loop"),(0,a.kt)("p",null,"V has only one looping keyword: ",(0,a.kt)("inlineCode",{parentName:"p"},"for"),", with several forms."),(0,a.kt)("h3",{id:"forin"},(0,a.kt)("inlineCode",{parentName:"h3"},"for"),"/",(0,a.kt)("inlineCode",{parentName:"h3"},"in")),(0,a.kt)("p",null,"This is the most common form. You can use it with an array, map or\nnumeric range."),(0,a.kt)("h4",{id:"array-for"},"Array ",(0,a.kt)("inlineCode",{parentName:"h4"},"for")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-v"},"numbers := [1, 2, 3, 4, 5]\nfor num in numbers {\n    println(num)\n}\nnames := ['Sam', 'Peter']\nfor i, name in names {\n    println('$i) $name')\n    // Output: 0) Sam\n    //         1) Peter\n}\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"for value in arr")," form is used for going through elements of an array.\nIf an index is required, an alternative form ",(0,a.kt)("inlineCode",{parentName:"p"},"for index, value in arr")," can be used."),(0,a.kt)("p",null,"Note, that the value is read-only.\nIf you need to modify the array while looping, you need to declare the element as mutable:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-v"},"mut numbers := [0, 1, 2]\nfor mut num in numbers {\n    num++\n}\nprintln(numbers) // [1, 2, 3]\n")),(0,a.kt)("p",null,"When an identifier is just a single underscore, it is ignored."),(0,a.kt)("h4",{id:"custom-iterators"},"Custom iterators"),(0,a.kt)("p",null,"Types that implement a ",(0,a.kt)("inlineCode",{parentName:"p"},"next")," method returning an ",(0,a.kt)("inlineCode",{parentName:"p"},"Option")," can be iterated\nwith a ",(0,a.kt)("inlineCode",{parentName:"p"},"for")," loop."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-v"},"struct SquareIterator {\n    arr []int\nmut:\n    idx int\n}\n\nfn (mut iter SquareIterator) next() ?int {\n    if iter.idx >= iter.arr.len {\n        return error('')\n    }\n    defer {\n        iter.idx++\n    }\n    return iter.arr[iter.idx] * iter.arr[iter.idx]\n}\n\nnums := [1, 2, 3, 4, 5]\niter := SquareIterator{\n    arr: nums\n}\nfor squared in iter {\n    println(squared)\n}\n")),(0,a.kt)("p",null,"The code above prints:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"1\n4\n9\n16\n25\n")),(0,a.kt)("h4",{id:"map-for"},"Map ",(0,a.kt)("inlineCode",{parentName:"h4"},"for")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-v"},"m := {\n    'one': 1\n    'two': 2\n}\nfor key, value in m {\n    println('$key -> $value')\n    // Output: one -> 1\n    //         two -> 2\n}\n")),(0,a.kt)("p",null,"Either key or value can be ignored by using a single underscore as the identifier."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-v"},"m := {\n    'one': 1\n    'two': 2\n}\n// iterate over keys\nfor key, _ in m {\n    println(key)\n    // Output: one\n    //         two\n}\n// iterate over values\nfor _, value in m {\n    println(value)\n    // Output: 1\n    //         2\n}\n")),(0,a.kt)("h4",{id:"range-for"},"Range ",(0,a.kt)("inlineCode",{parentName:"h4"},"for")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-v"},"// Prints '01234'\nfor i in 0 .. 5 {\n    print(i)\n}\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"low..high")," means an ",(0,a.kt)("em",{parentName:"p"},"exclusive")," range, which represents all values\nfrom ",(0,a.kt)("inlineCode",{parentName:"p"},"low")," up to ",(0,a.kt)("em",{parentName:"p"},"but not including")," ",(0,a.kt)("inlineCode",{parentName:"p"},"high"),"."),(0,a.kt)("h3",{id:"condition-for"},"Condition ",(0,a.kt)("inlineCode",{parentName:"h3"},"for")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-v"},'mut sum := 0\nmut i := 0\nfor i <= 100 {\n    sum += i\n    i++\n}\nprintln(sum) // "5050"\n')),(0,a.kt)("p",null,"This form of the loop is similar to ",(0,a.kt)("inlineCode",{parentName:"p"},"while")," loops in other languages.\nThe loop will stop iterating once the boolean condition evaluates to false.\nAgain, there are no parentheses surrounding the condition, and the braces are always required."),(0,a.kt)("h3",{id:"bare-for"},"Bare ",(0,a.kt)("inlineCode",{parentName:"h3"},"for")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-v"},'mut num := 0\nfor {\n    num += 2\n    if num >= 10 {\n        break\n    }\n}\nprintln(num) // "10"\n')),(0,a.kt)("p",null,"The condition can be omitted, resulting in an infinite loop."),(0,a.kt)("h3",{id:"c-for"},"C ",(0,a.kt)("inlineCode",{parentName:"h3"},"for")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-v"},"for i := 0; i < 10; i += 2 {\n    // Don't print 6\n    if i == 6 {\n        continue\n    }\n    println(i)\n}\n")),(0,a.kt)("p",null,"Finally, there's the traditional C style ",(0,a.kt)("inlineCode",{parentName:"p"},"for")," loop. It's safer than the ",(0,a.kt)("inlineCode",{parentName:"p"},"while")," form\nbecause with the latter it's easy to forget to update the counter and get\nstuck in an infinite loop."),(0,a.kt)("p",null,"Here ",(0,a.kt)("inlineCode",{parentName:"p"},"i")," doesn't need to be declared with ",(0,a.kt)("inlineCode",{parentName:"p"},"mut")," since it's always going to be mutable by definition."),(0,a.kt)("h3",{id:"labelled-break--continue"},"Labelled break & continue"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"break")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"continue")," control the innermost ",(0,a.kt)("inlineCode",{parentName:"p"},"for")," loop by default.\nYou can also use ",(0,a.kt)("inlineCode",{parentName:"p"},"break")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"continue")," followed by a label name to refer to an outer ",(0,a.kt)("inlineCode",{parentName:"p"},"for"),"\nloop:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-v"},"outer: for i := 4; true; i++ {\n    println(i)\n    for {\n        if i < 7 {\n            continue outer\n        } else {\n            break outer\n        }\n    }\n}\n")),(0,a.kt)("p",null,"The label must immediately precede the outer loop.\nThe above code prints:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"4\n5\n6\n7\n")),(0,a.kt)("h2",{id:"match"},"Match"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-v"},"os := 'windows'\nprint('V is running on ')\nmatch os {\n    'darwin' { println('macOS.') }\n    'linux' { println('Linux.') }\n    else { println(os) }\n}\n")),(0,a.kt)("p",null,"A match statement is a shorter way to write a sequence of ",(0,a.kt)("inlineCode",{parentName:"p"},"if - else")," statements.\nWhen a matching branch is found, the following statement block will be run.\nThe else branch will be run when no other branches match."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-v"},"number := 2\ns := match number {\n    1 { 'one' }\n    2 { 'two' }\n    else { 'many' }\n}\n")),(0,a.kt)("p",null,"A match statement can also to be used as an ",(0,a.kt)("inlineCode",{parentName:"p"},"if - else if - else")," alternative:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-v"},"match true {\n    2 > 4 { println('if') }\n    3 == 4 { println('else if') }\n    2 == 2 { println('else if2') }\n    else { println('else') }\n}\n// 'else if2' should be printed\n")),(0,a.kt)("p",null,"or as an ",(0,a.kt)("inlineCode",{parentName:"p"},"unless")," alternative: ",(0,a.kt)("a",{parentName:"p",href:"https://www.tutorialspoint.com/ruby/ruby_if_else.htm"},"unless Ruby")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-v"},"match false {\n    2 > 4 { println('if') }\n    3 == 4 { println('else if') }\n    2 == 2 { println('else if2') }\n    else { println('else') }\n}\n// 'if' should be printed\n")),(0,a.kt)("p",null,"A match expression returns the value of the final expression from the matching branch."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-v"},"enum Color {\n    red\n    blue\n    green\n}\n\nfn is_red_or_blue(c Color) bool {\n    return match c {\n        .red, .blue { true } // comma can be used to test multiple values\n        .green { false }\n    }\n}\n")),(0,a.kt)("p",null,"A match statement can also be used to branch on the variants of an ",(0,a.kt)("inlineCode",{parentName:"p"},"enum"),"\nby using the shorthand ",(0,a.kt)("inlineCode",{parentName:"p"},".variant_here")," syntax. An ",(0,a.kt)("inlineCode",{parentName:"p"},"else")," branch is not allowed\nwhen all the branches are exhaustive."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-v"},"c := `v`\ntyp := match c {\n    `0`...`9` { 'digit' }\n    `A`...`Z` { 'uppercase' }\n    `a`...`z` { 'lowercase' }\n    else { 'other' }\n}\nprintln(typ)\n// 'lowercase'\n")),(0,a.kt)("p",null,"You can also use ranges as ",(0,a.kt)("inlineCode",{parentName:"p"},"match")," patterns. If the value falls within the range\nof a branch, that branch will be executed."),(0,a.kt)("p",null,"Note that the ranges use ",(0,a.kt)("inlineCode",{parentName:"p"},"...")," (three dots) rather than ",(0,a.kt)("inlineCode",{parentName:"p"},"..")," (two dots). This is\nbecause the range is ",(0,a.kt)("em",{parentName:"p"},"inclusive")," of the last element, rather than exclusive\n(as ",(0,a.kt)("inlineCode",{parentName:"p"},"..")," ranges are). Using ",(0,a.kt)("inlineCode",{parentName:"p"},"..")," in a match branch will throw an error."),(0,a.kt)("p",null,"Note: ",(0,a.kt)("inlineCode",{parentName:"p"},"match")," as an expression is not usable in ",(0,a.kt)("inlineCode",{parentName:"p"},"for")," loop and ",(0,a.kt)("inlineCode",{parentName:"p"},"if")," statements."),(0,a.kt)("h2",{id:"defer"},"Defer"),(0,a.kt)("p",null,"A defer statement defers the execution of a block of statements\nuntil the surrounding function returns."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-v"},"import os\n\nfn read_log() {\n    mut ok := false\n    mut f := os.open('log.txt') or { panic(err) }\n    defer {\n        f.close()\n    }\n    // ...\n    if !ok {\n        // defer statement will be called here, the file will be closed\n        return\n    }\n    // ...\n    // defer statement will be called here, the file will be closed\n}\n")),(0,a.kt)("p",null,"If the function returns a value the ",(0,a.kt)("inlineCode",{parentName:"p"},"defer")," block is executed ",(0,a.kt)("em",{parentName:"p"},"after")," the return\nexpression is evaluated:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-v"},"import os\n\nenum State {\n    normal\n    write_log\n    return_error\n}\n\n// write log file and return number of bytes written\nfn write_log(s State) ?int {\n    mut f := os.create('log.txt')?\n    defer {\n        f.close()\n    }\n    if s == .write_log {\n        // `f.close()` will be called after `f.write()` has been\n        // executed, but before `write_log()` finally returns the\n        // number of bytes written to `main()`\n        return f.writeln('This is a log file')\n    } else if s == .return_error {\n        // the file will be closed after the `error()` function\n        // has returned - so the error message will still report\n        // it as open\n        return error('nothing written; file open: $f.is_opened')\n    }\n    // the file will be closed here, too\n    return 0\n}\n\nfn main() {\n    n := write_log(.return_error) or {\n        println('Error: $err')\n        0\n    }\n    println('$n bytes written')\n}\n")))}c.isMDXComponent=!0}}]);