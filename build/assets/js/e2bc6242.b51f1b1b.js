"use strict";(self.webpackChunkvlang_ru=self.webpackChunkvlang_ru||[]).push([[9e3],{3905:(e,n,t)=>{t.d(n,{Zo:()=>s,kt:()=>m});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var c=r.createContext({}),u=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},s=function(e){var n=u(e.components);return r.createElement(c.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),d=u(t),m=a,f=d["".concat(c,".").concat(m)]||d[m]||p[m]||o;return t?r.createElement(f,i(i({ref:n},s),{},{components:t})):r.createElement(f,i({ref:n},s))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=d;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var u=2;u<o;u++)i[u]=t[u];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},7173:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>l,toc:()=>u});var r=t(7462),a=(t(7294),t(3905));const o={sidebar_position:14},i="References",l={unversionedId:"documentation/references",id:"documentation/references",title:"References",description:"If a function argument is immutable (like foo in the examples above)",source:"@site/docs/documentation/references.md",sourceDirName:"documentation",slug:"/documentation/references",permalink:"/docs/documentation/references",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/documentation/references.md",tags:[],version:"current",sidebarPosition:14,frontMatter:{sidebar_position:14},sidebar:"tutorialSidebar",previous:{title:"Functions 2",permalink:"/docs/documentation/functions2"},next:{title:"Constants",permalink:"/docs/documentation/constants"}},c={},u=[{value:"Parameter evaluation order",id:"parameter-evaluation-order",level:2}],s={toc:u};function p(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,r.Z)({},s,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"references"},"References"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-v"},"struct Foo {}\n\nfn (foo Foo) bar_method() {\n    // ...\n}\n\nfn bar_function(foo Foo) {\n    // ...\n}\n")),(0,a.kt)("p",null,"If a function argument is immutable (like ",(0,a.kt)("inlineCode",{parentName:"p"},"foo")," in the examples above)\nV can pass it either by value or by reference. The compiler will decide,\nand the developer doesn't need to think about it."),(0,a.kt)("p",null,"You no longer need to remember whether you should pass the struct by value\nor by reference."),(0,a.kt)("p",null,"You can ensure that the struct is always passed by reference by\nadding ",(0,a.kt)("inlineCode",{parentName:"p"},"&"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-v"},"struct Foo {\n    abc int\n}\n\nfn (foo &Foo) bar() {\n    println(foo.abc)\n}\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"foo")," is still immutable and can't be changed. For that,\n",(0,a.kt)("inlineCode",{parentName:"p"},"(mut foo Foo)")," must be used."),(0,a.kt)("p",null,"In general, V's references are similar to Go pointers and C++ references.\nFor example, a generic tree structure definition would look like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-v"},"struct Node<T> {\n    val   T\n    left  &Node<T>\n    right &Node<T>\n}\n")),(0,a.kt)("p",null,"To dereference a reference, use the ",(0,a.kt)("inlineCode",{parentName:"p"},"*")," operator, just like in C."),(0,a.kt)("h2",{id:"parameter-evaluation-order"},"Parameter evaluation order"),(0,a.kt)("p",null,"The evaluation order of the parameters of function calls is ",(0,a.kt)("em",{parentName:"p"},"NOT")," guaranteed.\nTake for example the following program:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-v"},"fn f(a1 int, a2 int, a3 int) {\n    dump(a1 + a2 + a3)\n}\n\nfn main() {\n    f(dump(100), dump(200), dump(300))\n}\n")),(0,a.kt)("p",null,"V currently does not guarantee, that it will print 100, 200, 300 in that order.\nThe only guarantee is that 600 (from the body of ",(0,a.kt)("inlineCode",{parentName:"p"},"f"),"), will be printed after all of them.\nThat ",(0,a.kt)("em",{parentName:"p"},"may")," change in V 1.0 ."))}p.isMDXComponent=!0}}]);