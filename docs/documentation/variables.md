---
sidebar_position: 7
---

# Переменные

```v
name := 'Bob'
age := 20
large_number := i64(9999999999)
println(name)
println(age)
println(large_number)
```

Переменные объявляются и инициализируются с помощью `:=`. Это единственный способ объявить переменные в V. Это означает, что переменные всегда имеют начальное значение.

Тип переменной выводится из значения в правой части. Чтобы выбрать другой тип, используйте преобразование типов: выражение `T(v)` преобразует значение `v` в тип `T`.

В отличие от большинства других языков, V позволяет определять переменные только в функциях. Глобальные переменные (уровня модуля) не допускаются. В V нет глобального состояния.

Для согласованности между различными базами кода все имена переменных и функций должны использовать `snake_case` стиль, в отличие от имен типов, которые должны использовать `PascalCase`.

## Изменяемые переменные

```v
mut age := 20
println(age)
age = 21
println(age)
```

Чтобы изменить значение переменной, используйте `=`. В V переменные неизменяемы по умолчанию. Чтобы иметь возможность изменить значение переменной, вы должны объявить ее с помощью `mut`.

Попробуйте скомпилировать программу выше после удаления `mut` из первой строки.

## Инициализация и назначение

Обратите внимание на (важную) разницу между `:=` и `=`.
`:=` используется для объявления и инициализации, `=` используется для присваивания.

```v failcompile
fn main() {
	age = 21
}
```

Этот код не скомпилируется, потому что переменная `age` не объявлена. Все переменные должны быть объявлены в V.

```v
fn main() {
	age := 21
}
```

Значения нескольких переменных можно изменить в одной строке. Таким образом, их значения можно поменять местами без промежуточной переменной.

```v
mut a := 0
mut b := 1
println('$a, $b') // 0, 1
a, b = b, a
println('$a, $b') // 1, 0
```

## Ошибки объявления

В режиме разработки компилятор предупредит вас, что вы не использовали переменную (вы получите предупреждение "неиспользуемая переменная"). В рабочем режиме (включаемом передачей `-prod` флага v — `v -prod foo.v`) он вообще не будет компилироваться (как в Go).

```v
fn main() {
	a := 10
	if true {
		a := 20 // ошибка: переопределение `a`
	}
	// предупреждение: неиспользуемая переменная `a`
}
```

В отличие от большинства языков, затенение переменных не допускается. Объявление переменной с именем, которое уже используется в родительской области, вызовет ошибку компиляции.

Однако вы можете скрывать импортированные модули, так как в некоторых ситуациях это очень полезно:

```v
import ui
import gg

fn draw(ctx &gg.Context) {
	gg := ctx.parent.get_ui().gg
	gg.draw_rect(10, 10, 100, 50)
}
```