---
sidebar_position: 1
---

# Примитивные типы

```v ignore
bool

string

i8    i16  int  i64      i128 (скоро)
u8    u16  u32  u64      u128 (скоро)

rune // представляет кодовую точку Unicode

f32 f64

isize, usize // зависит от платформы, размер — это количество байтов, необходимое для ссылки на любое место в памяти.

voidptr // этот в основном используется для совместимости C

any // похож на void* в C и интерфейс Go{}
```

Обратите внимание, что в отличие от C и Go, `int` это всегда 32-битное целое число.

Существует исключение из правила, согласно которому все операторы в V должны иметь значения одного и того же типа с обеих сторон. Небольшой примитивный тип на одной стороне может быть автоматически повышен, если он полностью соответствует диапазону данных типа на другой стороне. Это разрешенные возможности:

```v
   i8 → i16 → int → i64
                  ↘     ↘
                    f32 → f64
                  ↗     ↗
   u8 → u16 → u32 → u64 ⬎
      ↘     ↘     ↘      ptr
   i8 → i16 → int → i64 ⬏
```
Например `int`, значение может быть автоматически повышено до `f64` или , `i64` но не до `u32`. ( `u32` означало бы потерю знака для отрицательных значений). Однако переход от `int` к `f32` в настоящее время выполняется автоматически (но может привести к потере точности для больших значений).

Литералы типа `123` или `4.56` обрабатываются особым образом. Они не приводят к повышению типа, однако они по умолчанию `int` и `f64`, соответственно, когда необходимо определить их тип:

```v
u := u16(12)
v := 13 + u    // v имеет тип `u16` - без продвижения
x := f32(45.6)
y := x + 3.14  // x имеет тип `f32` - без продвижения
a := 75        // a имеет тип `int` - по умолчанию для литерала int
b := 14.7      // b имеет тип `f64` - по умолчанию для литерала с плавающей запятой
c := u + a     // c имеет тип `int` - автоматическое повышение значения `u`
d := b + x     // d имеет тип `f64` - автоматическое продвижение значения `x`
```